<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="这里记录你的故事！">
<meta property="og:type" content="website">
<meta property="og:title" content="一个写代码的地方">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="一个写代码的地方">
<meta property="og:description" content="这里记录你的故事！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一个写代码的地方">
<meta name="twitter:description" content="这里记录你的故事！">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> 一个写代码的地方 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一个写代码的地方</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">记录你的学习</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/14/view_to_scroll/" itemprop="url">
                  Android 开发艺术探索第3章 3.2-3.3 View 滑动和弹性滑动读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-14T21:53:40+08:00" content="2016-08-14">
              2016-08-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-View-学习/" itemprop="url" rel="index">
                    <span itemprop="name">Android View 学习</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/14/view_to_scroll/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/14/view_to_scroll/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="3-2-View-的滑动"><a href="#3-2-View-的滑动" class="headerlink" title="3.2 View 的滑动"></a>3.2 View 的滑动</h2><p>3.1节中介绍了View的基础知识，有了这些基础知识和概念，我们就可以根据需要对 View 做一些操作，在Android设备上，最常见的一个操作就是滑动，如此可见滑动是很重要的知识，只有具备了滑动的基础知识才能做出更复杂炫酷的滑动效果，复杂的效果是由不同的滑动基础组成，通常View 的滑动可以由三种方式：使用scrollTo或scrollBy、通过动画给View 添加平移效果实现滑动、通过改变 View 的布局参数 LayoutParams 实现滑动，下面进行逐一分析。</p>
<h3 id="3-2-1-使用scrollTo或scrollBy进行滑动"><a href="#3-2-1-使用scrollTo或scrollBy进行滑动" class="headerlink" title="3.2.1 使用scrollTo或scrollBy进行滑动"></a>3.2.1 使用scrollTo或scrollBy进行滑动</h3><p>Android 中 View 为我们提供了两个专门的方法 scrollTo或scrollBy 来实现  View 的滑动，scrollTo 是滑动到某一坐标，是绝对滑动，View 调用的时候只能进行一次滑动，比如将 View 从 A 点滑动到 B 点；而scrollBy是滑动一段距离，是相对滑动，可以进行连续滑动，View 每次进行调用的时候都会将 View 滑动指定的距离。下面看一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * 绝对滑动</div><div class="line">  * <span class="doctag">@param</span> x 指定水平方向滑动像素</div><div class="line">  * <span class="doctag">@param</span> y 指定竖直方向滑动像素</div><div class="line">  */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">      <span class="comment">//位置发生了改变</span></div><div class="line">        <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</div><div class="line">            <span class="keyword">int</span> oldX = mScrollX;</div><div class="line">            <span class="keyword">int</span> oldY = mScrollY;</div><div class="line">            mScrollX = x;</div><div class="line">            mScrollY = y;d</div><div class="line">          <span class="comment">//使父视图清出子view，作用是重新创建显示的内容</span></div><div class="line">          <span class="comment">//主要应用场景是view 的渐变度改变，滑动，旋转等</span></div><div class="line">            invalidateParentCaches();</div><div class="line">          <span class="comment">//使View内容进行滑动</span></div><div class="line">            onScrollChanged(mScrollX, mScrollY, oldX, oldY);	</div><div class="line">          <span class="comment">//触发scrollbars进行绘制		              	      </span></div><div class="line">          <span class="comment">//如果正在动画播放完毕返回</span></div><div class="line">          <span class="comment">//ture 否则返回false</span></div><div class="line">            <span class="keyword">if</span> (!awakenScrollBars()) &#123;</div><div class="line">              <span class="comment">//在动画期间（下一个动画开始)，使view重新绘制</span></div><div class="line">                postInvalidateOnAnimation();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">  * 进行相对滑动</div><div class="line">  * <span class="doctag">@param</span> x  指定水平方向滑动像素</div><div class="line">  * <span class="doctag">@param</span> y 指定竖直方向滑动像素</div><div class="line">  */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        scrollTo(mScrollX + x, mScrollY + y);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过源码可以看出实际上scrollBy调用了scrollTo方法，实现了基于当前位置的相对滑动。其中 mScrollX 、mScrollY 这两个参数表示View内容的偏移量，单位为px，可以通过getScrollX 和 getScrollY 得到，mScrollX  是等于View的左边缘和View内容左边缘在水平方向的距离，并且当View内容左边缘在View左边缘的右侧的时候，mScrollX为负，反之为正,View边缘是指 View 的位置，由四个顶点组成，而 View内容边缘是指 View 的内容边缘；同理，mScrollY是等于View的上边缘和View内容上边缘在数值方向的距离，并且 View 内容上边缘在View上边缘下侧的时候，mScrollY为负，反之为正；scrollTo或scrollBy只能改变 View内容的位置不能改变View 在布局中的位置（即View的布局参数比如Top、Left、X、Y等不会改变），即不能改变 View 本身的位置，对于一个View来说，其本身是一个容器，而View内容是容器里面的东西，对于一个ViewGroup来说，那么它的内容是它的所有子View。</p>
<p>为了方便理解，下面用几幅图描述mScrollX、mScrollY和View内容的关系：</p>
<p><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/view_scroll.png?raw=true" alt="view_scroll"></p>
<h3 id="3-2-2-使用动画"><a href="#3-2-2-使用动画" class="headerlink" title="3.2.2 使用动画"></a>3.2.2 使用动画</h3><p>使用动画来移动view主要是操作view的translationX和translationY属性，既可以使用传统的view动画，也可以使用属性动画，使用后者需要考虑兼容性问题，如果要兼容Android 3.0以下版本系统的话推荐使用开元动画库<a href="http://nineoldandroids.com/" target="_blank" rel="external">nineoldandroids</a>。采用 View 动画 示例代码如下，此动画可以使 View在100ms内从原始位置向右下角移动100个像素。在项目的res目录中，创建一个名为anim的目录，创建动画资源文件 translation.xml 代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;set xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    android:fillAfter="true"&gt;</div><div class="line">    &lt;translate</div><div class="line">        android:duration="100"</div><div class="line">        android:fromXDelta="0"</div><div class="line">        android:fromYDelta="0"</div><div class="line">        android:toXDelta="100"</div><div class="line">        android:toYDelta="100" /&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure>
<p>java 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Animation animation = AnimationUtils.loadAnimation(<span class="keyword">this</span>,R.anim.translation);</div><div class="line"><span class="comment">//开始动画平移</span></div><div class="line">targetView.startAnimation(animation);</div></pre></td></tr></table></figure>
<p>注意，使用这种方式进行平移，View动画只是对View的影像做操作，它并不能真正改变View的位置参数，如果这个View设置了点击事件，点击动画后的新位置无法触发点击事件的，点击原来的位置可以出发事件，这这是因为View本身位置其实没有变化造成，解决方案是通过在目标位置创建一个一模一样的隐藏的view，设置同样的点击事件，当view移动到目标位置后，隐藏被移动的view，显示目标位置view，这样就可以达到点击效果。使用属性动画没有此问题，但3.0之前系统无属性动画，这个时候可以使用动画兼容库<a href="http://nineoldandroids.com/" target="_blank" rel="external">nineoldandroids</a>来实现属性动画，尽管如此，使用动画兼容库在3.0以后手机上实现属性动画本质上还是View动画。在100ms内将view向右平移100个像素代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, <span class="string">"translationX"</span>, <span class="number">0.0f</span>, <span class="number">100.0f</span>);</div><div class="line">animator.setDuration(<span class="number">100</span>).start();</div></pre></td></tr></table></figure>
<p>fFloat()方法的第一个参数表示动画操作的对象（可以是任意对象），第二个参数表示操作对象的属性名字（只要是对象有的属性都可以）,第三个参数之后就是动画过渡值。过度值可以有一个到N个，如果是一个值的话默认这个值是动画过渡值的结束值。如果有N个值，动画就在这N个值之间过渡。</p>
<h3 id="3-2-3-改变布局参数"><a href="#3-2-3-改变布局参数" class="headerlink" title="3.2.3 改变布局参数"></a>3.2.3 改变布局参数</h3><p>改变布局参数实现滑动，即改变LayoutParams,如想将一个View右平移100px，只需要将该View的LayoutParams里的marginLeft增加100px即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) view.getLayoutParams();  <span class="comment">//获取view的布局参数</span></div><div class="line">params.leftMargin += <span class="number">100</span>;     <span class="comment">//修改leftMargin的值，相当于xml布局文件中的margin_left的值</span></div><div class="line">view.setLayoutParams(params);  <span class="comment">//将新的params值设置进view</span></div><div class="line"><span class="comment">//或者调用   view.requestLayout();</span></div></pre></td></tr></table></figure>
<p>作者还提供了另一种思路是：可以在目标View 旁边放置一个宽度为0的view，当需要移动目标view 的时候，只需要给旁边的view设定需要移动的宽度即可，这样目标view自然就会被挤到目标位置。</p>
<p>针对以上三种view滑动总结如下：</p>
<ol>
<li>scrollTo/scrollBy:只适合对view的内容的滑动</li>
<li>属性动画：操作简单，功能强大，能实现复杂的动画效果，不建议用于有交互的View。</li>
<li>改变布局参数:适用于交互性强的View。</li>
</ol>
<p>根据以上三种滑动原理我们选择一种来实现一个可以在全屏进行滑动的view，实现原理是通过重写view 的TouchEvent方法，处理ACTION_MOVE方法，那么我们选择哪一种方式合适呢？第一种scrollBy方式，由于scrollBy是能实现view的内容滑动，而view本身没有滑动，所以所以不能满足需求，而属性动画和改变view布局方式，都可以满足，下面是选择较为简单方式，通过动画动画兼容库<a href="http://nineoldandroids.com/" target="_blank" rel="external">nineoldandroids</a>方式实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestButton</span> <span class="keyword">extends</span> <span class="title">TextView</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"TestButton"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mScaledTouchSlop;</div><div class="line"><span class="comment">// 分别记录上次滑动的坐标</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mLastX = <span class="number">0</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mLastY = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestButton</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestButton</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(context, attrs);</div><div class="line">    init();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestButton</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">    init();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">    mScaledTouchSlop = ViewConfiguration.get(getContext())</div><div class="line">            .getScaledTouchSlop();</div><div class="line">    Log.d(TAG, <span class="string">"sts:"</span> + mScaledTouchSlop);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressLint</span>(<span class="string">"ClickableViewAccessibility"</span>)</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">  <span class="comment">//获取当前点击事件在屏幕中的坐标，注意：不是相对view本身坐标，不能用getX 和getY</span></div><div class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getRawX();</div><div class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getRawY();</div><div class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">        <span class="comment">//按下手势，无需处理</span></div><div class="line">    <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">        <span class="comment">//在此处理滑动事件</span></div><div class="line">    <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</div><div class="line">      <span class="comment">//计算滑动距离</span></div><div class="line">        <span class="keyword">int</span> deltaX = x - mLastX;</div><div class="line">        <span class="keyword">int</span> deltaY = y - mLastY;</div><div class="line">        Log.d(TAG, <span class="string">"move, deltaX:"</span> + deltaX + <span class="string">" deltaY:"</span> + deltaY);</div><div class="line">      <span class="comment">//就算偏移距离</span></div><div class="line">        <span class="keyword">int</span> translationX = (<span class="keyword">int</span>)ViewHelper.getTranslationX(<span class="keyword">this</span>) + deltaX;</div><div class="line">        <span class="keyword">int</span> translationY = (<span class="keyword">int</span>)ViewHelper.getTranslationY(<span class="keyword">this</span>) + deltaY;</div><div class="line">      <span class="comment">//进行滑动</span></div><div class="line">        ViewHelper.setTranslationX(<span class="keyword">this</span>, translationX);</div><div class="line">        ViewHelper.setTranslationY(<span class="keyword">this</span>, translationY);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">        <span class="comment">//抬起手势无需处理</span></div><div class="line">    <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//记录滑动后坐标</span></div><div class="line">    mLastX = x;</div><div class="line">    mLastY = y;</div><div class="line">  <span class="comment">//事件消费，返回false，无法滑动，后面会讲到view的事件分发机制有关。</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-3-弹性滑动"><a href="#3-3-弹性滑动" class="headerlink" title="3.3 弹性滑动"></a>3.3 弹性滑动</h2><p>实现弹性滑动的原理是：将一次大的滑动分成若干次小的滑动，并在一个时间段内完成。可以通过scroller、Handler#postDelayed 以及Thread#Sleep来完成，下面逐一介绍。</p>
<h3 id="3-3-1-使用Scroller"><a href="#3-3-1-使用Scroller" class="headerlink" title="3.3.1 使用Scroller"></a>3.3.1 使用Scroller</h3><p>在3.1.4章节介绍过通过Scroller实现滑动的典型代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Scroller mScroller = <span class="keyword">new</span> Scroller(mContext);</div><div class="line"><span class="comment">// 缓慢滚动到指定的位置  </span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX, <span class="keyword">int</span> destY)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> scrollX = getScrollX();</div><div class="line">    <span class="keyword">int</span> deltaX = destX - scrollX;</div><div class="line">    <span class="comment">// 以 1000ms 内滑向 destX， 效果是慢慢滑动  </span></div><div class="line">    mScroller.startScroll(scrollX, destY, deltaX , <span class="number">0</span>, <span class="number">1000</span>);</div><div class="line">    <span class="comment">// View 的重绘  </span></div><div class="line">    invalidate();</div><div class="line">&#125;</div><div class="line">  <span class="comment">// 重写 computeScroll 方法，并在内部完成平滑滚动的逻辑  </span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">//判断view是在指定时间内是否完成滑动</span></div><div class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset())&#123;</div><div class="line">      <span class="comment">//通过mScroller获取当前位置，实现滑动</span></div><div class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</div><div class="line">        <span class="comment">// 再次进行重绘  </span></div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面分析一下Scroller是如何实现弹性滑动的，上面代码我们调用了mScroller.startScroll(scrollX, destY, deltaX , 0, 1000);方法，下面一起来看一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> startX 水平方向开始滑动像素. 正值代表内容向左滑动.</div><div class="line"> * <span class="doctag">@param</span> startY 竖直方向开始滑动像素. 正值代表内容向上滑动</div><div class="line"> * <span class="doctag">@param</span> dx 水平方向滑动距离. 正值代表内容向左滑动</div><div class="line"> * <span class="doctag">@param</span> dy 竖直方向滑动距离，正值代表向上滑动</div><div class="line"> * <span class="doctag">@param</span> duration 滑动时间.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span> </span>&#123;</div><div class="line">    mMode = SCROLL_MODE;</div><div class="line">  <span class="comment">//滑动是否完成标志</span></div><div class="line">    mFinished = <span class="keyword">false</span>;</div><div class="line">  <span class="comment">//滑动时间</span></div><div class="line">    mDuration = duration;</div><div class="line">  <span class="comment">//获取当前时间</span></div><div class="line">    mStartTime = AnimationUtils.currentAnimationTimeMillis();</div><div class="line">  <span class="comment">//水平方向滑动起点</span></div><div class="line">    mStartX = startX;</div><div class="line">  <span class="comment">//竖直方向滑动起点</span></div><div class="line">    mStartY = startY;</div><div class="line">  <span class="comment">//滑动终点</span></div><div class="line">    mFinalX = startX + dx;</div><div class="line">    mFinalY = startY + dy;</div><div class="line">  <span class="comment">//水平方向要滑动距离</span></div><div class="line">    mDeltaX = dx;</div><div class="line">  <span class="comment">//竖直方向要滑动距离</span></div><div class="line">    mDeltaY = dy;</div><div class="line">  <span class="comment">//滑动时间的倒数</span></div><div class="line">    mDurationReciprocal = <span class="number">1.0f</span> / (<span class="keyword">float</span>) mDuration;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意以上滑动是实现view的内容滑动，而且可以看到startScroll方法竟然没有做任何滑动的事情，只是将要进行滑动的参数传递进来并进行了保存，因此仅仅调用startScroll方法是无法实现滑动的，而正在使view 进行滑动的关键代码是invalidate()，为什么呢？因为调用invalidate()方法后会使 view进行重新绘制，这样就会调用view的 draw 方法，view 的draw方法又会去调用computeScroll() 方法，computeScroll方法在view 内部是一个空方法，需要我们自己去实现，上面典型代码中我们调用scrollTo方法，因此实现了view 的滑动，接着又调用postInvalidate（）方法，使view进行第二次重新绘制，这样绘制过程又和第一次一样重新走一遍，这样反复调用就完成了view 的滑动；那么什么时候完成停止绘制呢?判断条件就是mScroller.computeScrollOffset()，这个方法会根据时间的流逝计算当前Scrollx和ScrollYD 值，返回ture表示滑动未结束。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">computeScrollOffset</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mFinished) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> timePassed = (<span class="keyword">int</span>)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);</div><div class="line">    <span class="keyword">if</span> (timePassed &lt; mDuration) &#123;</div><div class="line">        <span class="keyword">switch</span> (mMode) &#123;</div><div class="line">        <span class="keyword">case</span> SCROLL_MODE:</div><div class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</div><div class="line">            mCurrX = mStartX + Math.round(x * mDeltaX);</div><div class="line">            mCurrY = mStartY + Math.round(x * mDeltaY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">           ......</div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        mCurrX = mFinalX;</div><div class="line">        mCurrY = mFinalY;</div><div class="line">        mFinished = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结： Scroller 本身不能实现 View 的滑动，它需要配合 View 的 computeScroll 方法才能完成弹性滑动的效果。通过不断地让 View 重绘，而每一次重绘距离滑动其实起始时间会有一个时间间隔，通过这个时间间隔 Scroller 得出 View 当前的滑动位置，知道了滑动位置就可以通过 scrollTo 方法完成 View 的滑动。 View 的每一次重绘都会导致 View 的小幅度滑动，而多次的小幅度滑动组成了弹性滑动，这就是 Scroller 滑动的工作机制。</p>
<h3 id="3-3-2-通过动画"><a href="#3-3-2-通过动画" class="headerlink" title="3.3.2 通过动画"></a>3.3.2 通过动画</h3><p>动画本身就是一个循序渐进的过程，因此使用动画进行滑动自然就具有弹性效果，比如以下代码就可以让一个View 在100ms内向右移动100像素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, <span class="string">"translationX"</span>, <span class="number">0.0f</span>, <span class="number">100.0f</span>);</div><div class="line">animator.setDuration(<span class="number">100</span>).start();</div></pre></td></tr></table></figure>
<p>这里我们是直接使用属性动画作用于 view 使其进行滑动，很简单，下面要作者提供了一个有意思的思路实现同样的效果，就是利用属性动画的特性结合ScrollTo 方法实现 Scroller 弹性滑动效果，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scroller</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="comment">//动画起始位置</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> startX = <span class="number">0</span>;</div><div class="line">  <span class="comment">//动画要滑动的距离</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> deltax = <span class="number">1000</span>;</div><div class="line">    <span class="keyword">final</span> ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">1</span>).setDuration(<span class="number">2000</span>);</div><div class="line">  <span class="comment">//动画添加监听器</span></div><div class="line">    animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">          <span class="comment">//获取动画完成比例值</span></div><div class="line">            <span class="keyword">float</span> fraction = animator.getAnimatedFraction();</div><div class="line">          <span class="comment">//根据比例值对目标view进行滑动</span></div><div class="line">            targetView.scrollTo(startX +(<span class="keyword">int</span>)(deltax * fraction), <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">  <span class="comment">//开始执行</span></div><div class="line">    animator.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码属性动画animator 对象没有作用于任何 view 对象上，它的作用只是在2000ms内完成整个动画的过程，利用这个特性就可以在动画每一帧到来时获取动画完成比例，然后再根据这个比例计算出当前 view 所要滑动的距离，注意由于这里是使用的scrollTo() 方法，所以实质滑动的是 view 的内容。这个方法实现的思路其实和 Scroller 比较类似，都是通过计算 改变一个百分比配合 Scroller 实现 view 滑动，但是这个方法中我们还可以在onAnimationUpdate方法中添加一些我们想要实现的操作，使用更加灵活。</p>
<h3 id="3-3-3-使用延时策略"><a href="#3-3-3-使用延时策略" class="headerlink" title="3.3.3 使用延时策略"></a>3.3.3 使用延时策略</h3><p>延时策略的思想是通过发送一系列的消息从而达到一种渐进式的效果，具体来说就是使用 Handler 或 View 的 postDelayed 方法，也可以使用线程的 sleep 方法。对于postDelayed 来说可以发送一个延时消息，然后在消息中对 view 进行滑动，连续不断的发送消息，就可以对 view 实现弹性滑动。对于sleep 来说，可以通过在while 循环中不断的对 view 进行滑动和 sleep，这样把整个滑动过程切成无数个小的滑动操作达到弹性滑动的效果。</p>
<p>采用Handler大约在1000ms内将 view 向左滑动100像素，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_SCROLL_TO = <span class="number">1</span>;</div><div class="line"><span class="comment">//发送消息次数，即要滑动次数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRAME_COUNT = <span class="number">30</span>;</div><div class="line"><span class="comment">//延时时间</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAYED_TIME = <span class="number">33</span>;</div><div class="line"><span class="comment">//从0次开始</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span>  mCount = <span class="number">0</span>;</div><div class="line"><span class="meta">@SuppressLint</span>(<span class="string">"HandlerLeak"</span>)</div><div class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_SCROLL_TO:</div><div class="line">            mCount++;</div><div class="line">            <span class="keyword">if</span>(mCount &lt;= FRAME_COUNT) &#123;</div><div class="line">              <span class="comment">//计算滑动百分比</span></div><div class="line">                <span class="keyword">float</span> fraction = mCount / (<span class="keyword">float</span>) FRAME_COUNT;</div><div class="line">              <span class="comment">//计算每次要滑动距离</span></div><div class="line">                <span class="keyword">int</span> scrollX = (<span class="keyword">int</span>) (fraction * <span class="number">100</span>);</div><div class="line">              <span class="comment">//开始滑动</span></div><div class="line">                view.scrollTo(scrollX, <span class="number">0</span>);</div><div class="line">              <span class="comment">//循环发送消息实现滑动</span></div><div class="line">                mHandler.sendEmptyMessageDelayed(MESSAGE_SCROLL_TO,DELAYED_TIME);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以上是关于 view 滑动的基础知识基本讲解完毕！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/10/yongyu_20160810_View3.1 basic_knowledge/" itemprop="url">
                  Android 开发艺术探索第3章 3.1View 基础知识读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-10T23:53:03+08:00" content="2016-08-10">
              2016-08-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-View/" itemprop="url" rel="index">
                    <span itemprop="name">Android View</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/10/yongyu_20160810_View3.1 basic_knowledge/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/10/yongyu_20160810_View3.1 basic_knowledge/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载请附原文链接：<a href="http://yongyu.itscoder.com/2016/08/10/yongyu_20160810_View3.1%20basic_knowledge/" target="_blank" rel="external">Android 开发艺术探索第3章 3.1View 基础知识读书笔记</a> </p>
<h1 id="3-1-View-基础知识"><a href="#3-1-View-基础知识" class="headerlink" title="3.1 View 基础知识"></a>3.1 View 基础知识</h1><p>主要介绍内容：View 的位置参数、MotionEvent 和 TouchSlop对象、VelocityTracker, GestureDetector 和 Scroller对象。</p>
<h2 id="3-11-什么是-View"><a href="#3-11-什么是-View" class="headerlink" title="3.11 什么是 View"></a>3.11 什么是 View</h2><p>View 是Android中所有控件的基类，例如Button和TextView、ViewGroup 等常见控件他们的基类都是View，View是一种界面层的控件的一种抽象，代表了一个控件。View 本身可以是单个控件也可以是由多个控件组成的一组控件，通过这种关系就形成了View 树的结构，与Web前端中的DOM树概念相似。</p>
<h2 id="3-1-2-View的位置参数"><a href="#3-1-2-View的位置参数" class="headerlink" title="3.1.2 View的位置参数"></a>3.1.2 View的位置参数</h2><p>View 的位置主要有四个顶点决定的， top（左上角纵坐标）、left（左上角横坐标）、right（右下角横坐标）、bottom（右下角纵坐标），这些顶点的坐标是相对于 View 的父容器来说，是一种相对坐标。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/View_%20XYZ.png?raw=true" alt="View_ XYZ"></h2><p>根据上图View的坐标位置关系可以得出以下view的宽度（width)和高度（height)：</p>
<p>View的宽高和坐标关系：width = right - left，height = top - bottom。</p>
<p>view 源码中他们对应于mLeft、mRight、mTop、mBottom这四个成员变量，获取方式如下：</p>
<p>Left=getLeft() 、Right=getRight() 、Top=getTop() 、Bottom=getBottom() </p>
<p>从Android 3.0开始，view增加了：x、y、translationX、translationY 四个参数，这几个参数也是相对于父容器的坐标。x和y是左上角的坐标（偏移前或者偏移后左上角坐标，即当前坐标），而translationX和translationY是view左上角相对于父容器的偏移量(偏移坐标），默认值都是0。View 也提供了相应的方法，通过这几个坐标可以得到如下换算关系：</p>
<p>x = left + translationX  其中：x为左上角偏移后当前横坐标，left为view原始位置横坐标即可以通过getLeft（）获取，translationX  为view相对于父容器偏移横坐标。</p>
<p>y = top + translationY  其中y为左上角偏移后当前纵坐标，left为view原始位置纵坐标可以通过getTop（）获取，translationY 为view相对于父容器偏移纵坐标。</p>
<p>注意：在 View 平移的过程中， top 和 left 表示的是原始左上角的位置信息， 其值并不会发生变化， 改变的是 x, y, traslationX 和 translation Y 。</p>
<h2 id="3-1-3-MotionEvent-和-TouchSlop"><a href="#3-1-3-MotionEvent-和-TouchSlop" class="headerlink" title="3.1.3 MotionEvent 和 TouchSlop"></a>3.1.3 MotionEvent 和 TouchSlop</h2><ol>
<li>MotionEvent 是指用户手指触摸屏幕产生的一系列事件 分为  ACTION_DOWN（手指刚接触屏幕）, ACTION_MOVE（手指在屏幕上滑动）, ACTION_UP（手指从屏幕上松开瞬间）。</li>
<li>点击屏幕后松开，事件序列 DOWN-&gt;UP点击屏幕滑动一会再松开，事件序列为 DOWN-&gt;MOVE-&gt;…-&gt;MOVE-&gt;UP。</li>
<li>getX/getY获取相对当前View左上角的x和y坐标；getRawX/getRawY获取相对手机屏幕左上角的x和y坐标。</li>
<li>TouchSlop 是系统能识别滑动的最小距离，是系统常量，与设备有关，不同设备，值可能不同，当手指在屏幕上滑动，小于这个距离，系统不认为你在进行滑动操作；可通过ViewConfiguration.get（getContext()).getScaledTouchSlop()方法来获取;可以利用此参数进行一些滑动过滤，当未达到此值的时候可以认为未达到滑距离的临界值。 </li>
</ol>
<h2 id="3-1-4-VelocityTracker-、GestureDetector-和Scroller"><a href="#3-1-4-VelocityTracker-、GestureDetector-和Scroller" class="headerlink" title="3.1.4 VelocityTracker  、GestureDetector 和Scroller"></a>3.1.4 VelocityTracker  、GestureDetector 和Scroller</h2><ol>
<li><p>VelocityTracker 用于追踪手指在滑动过程中的速度。如在View的onTouchEvent方法中追踪当前单击事件的速度方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取VelocityTracker对象</span></div><div class="line">VelocityTracker velocityTracker = VelocityTracker.obtain(); </div><div class="line"><span class="comment">//将事件event添加进去</span></div><div class="line">velocityTracker.addMovement(event); </div><div class="line"><span class="comment">//获取当前滑动速度计算方法</span></div><div class="line"><span class="comment">//这里的速度是指一段时间内手指滑动过的像素数</span></div><div class="line"><span class="comment">//获取速度前需输入计算速度参数时间间隔单位ms，即计算在1000ms内手指滑动过的像素数</span></div><div class="line">velocityTracker.computeCurrentVelocity(<span class="number">1000</span>);  </div><div class="line"><span class="comment">//获取x轴速度</span></div><div class="line"><span class="keyword">int</span> xVelocity = (<span class="keyword">int</span>)velocityTracker.getXVelocity(); </div><div class="line"><span class="comment">//获取y轴速度</span></div><div class="line"><span class="keyword">int</span> yVelocity = (<span class="keyword">int</span>)velocityTracker.getYVelocity();</div></pre></td></tr></table></figure>
<p>注意：这里的速度可以为负数，手指从右向左滑动，水平方向速度即为负数，计算公式为：</p>
<p>速度 = （终点位置 - 起点位置）/ 时间段</p>
<p>计算得到的速度即为在给定时间间隔内水平方向或者竖直方向所滑动的像素数。</p>
<p>最后如果不在使用，需要调用clear进行清除和回收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重置和回收</span></div><div class="line">mVelocityTracker.clear(); <span class="comment">//一般在MotionEvent.ACTION_UP的时候调用</span></div><div class="line">mVelocityTracker.recycle(); <span class="comment">//一般在onDetachedFromWindow中调用</span></div></pre></td></tr></table></figure>
</li>
<li><p>GestureDetector</p>
<p>用于辅助检测用户的单击、滑动、长按、双击等行为；下面笔者写一个小的demo如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GestureActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span>  <span class="keyword">implements</span> <span class="title">GestureDetector</span>.<span class="title">OnGestureListener</span>,<span class="title">GestureDetector</span>.<span class="title">OnDoubleTapListener</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG =<span class="string">"GestureActivity"</span> ;</div><div class="line">    <span class="keyword">private</span> GestureDetector gestureDetector;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="comment">//创建GestureDetector对象,并设置OnGestureListener监听</span></div><div class="line">        <span class="comment">//第一个this参数为context，第二个参数为OnGestureListener</span></div><div class="line">        gestureDetector =<span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>,<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//设置双击监听</span></div><div class="line">        gestureDetector.setOnDoubleTapListener(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//解决长按屏幕无法拖拽的现象</span></div><div class="line">        gestureDetector.setIsLongpressEnabled(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//重写Activity 的onTouchEvent将MotionEvent事件设置给gestureDetector</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="comment">//接管目标 View 的 onTouchEvent 方法</span></div><div class="line">        gestureDetector.onTouchEvent(event);</div><div class="line">        <span class="comment">//返回事件处理结果</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDown</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指轻轻触摸屏幕的瞬间，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onDown"</span>+e.toString());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShowPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指轻触屏幕，尚未松开或者拖动，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onShowPress"</span>+e.toString());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指松开，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onSingleTapUp"</span>+e.toString());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指按下屏幕并拖动，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onScroll"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指长按，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onLongPress"</span>+e.toString());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</div><div class="line">        <span class="comment">// 用户按下触摸屏，快速移动后松开，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onFling"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapConfirmed</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//单击行为；根据需要处理事件</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDoubleTap</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//表示双击行为，在双击的期间,根据需要处理事件</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDoubleTapEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">       <span class="comment">// 双击，由两次连续的单击组成，根据需要处理事件</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本例子中是将手势监听设置给了整个Activity，你也可以根据实际需求设置给某个view，同样是在onTouchEvent方法中设置。</p>
<p><strong>OnGestureListener 接口的方法</strong></p>
<p>onDown : 手指轻轻触摸屏幕的瞬间，由一个 ACTION_DOWN 触发；</p>
<p>onShowPress : 手指轻触屏幕，尚未松开或者拖动， 由一个 ACTION_DOWN 触发；</p>
<p>onSingTapUp : 手指松开，由 ACTION_DOWN 触发， 这是单击行为；</p>
<p>onScroll: 手指按下屏幕并拖动，由一个 ACTION_DOWN , 多个 ACTION_MOVE 触发， 这是拖动行为；</p>
<p>onLongPress: 用户长久地按着屏幕不放，即长按；</p>
<p>onFling: 用户按下触摸屏，快速移动后松开，由一个 ACTION_DWON、多个 ACTION_MOVE 和一个 ACTION_UP 触发，快速滑动行为；</p>
<p><strong>OnDoubleTapListener 接口中的方法</strong></p>
<p>onDoubleTap: 双击，由两次连续的单击组成，不能和 onSingleTapConfirmed 共存；</p>
<p>onSingleTapConfirmed: 单击行为；</p>
<p>onDoubleEvent: 表示双击行为，在双击的期间， ACTION_DOWN、ACTION_MOVE、ACTION_UP 都不会触发此回调。</p>
<p>在实际开发中可以不使用 GestureDetector ，完全可以在View的 onTouchEvent 方法中根据MotionEvent类型以及滑动速度等条件实现所需的监听，作者建议：如果只是监听滑动相关的推荐在onTouchEvent中实现，如果需要监听双击，使用GeststureDetector。</p>
</li>
<li><p>Scroller</p>
<p>用来实现View的弹性滑动，View的scrollTo/scrollBy是瞬间完成的，Scroller本身并不能实现view的滑动，使用Scroller配合View的computeScroll方法配合使用达到弹性滑动的效果，它不断地让view重绘，而每一次重绘距滑动起始时间会有一个时间间隔，通过这个时间间隔Scroller就可以得出view的当前的滑动位置，知道了滑动位置就可以通过scrollTo方法来完成view的滑动。就这样，view的每一次重绘都会导致view进行小幅度的滑动，而多次的小幅度滑动就组成了弹性滑动，这就是Scroller的工作原理，下面3.2节会详细介绍，典型固定代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Scroller mScroller = <span class="keyword">new</span> Scroller(mContext);</div><div class="line"><span class="comment">// 缓慢滚动到指定的位置  </span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX, <span class="keyword">int</span> destY)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> scrollX = getScrollX();</div><div class="line">    <span class="keyword">int</span> deltaX = destX - scrollX;</div><div class="line">    <span class="comment">// 以 1000ms 内滑向 destX， 效果是慢慢滑动  </span></div><div class="line">    mScroller.startScroll(scrollX, destY, deltaX , <span class="number">0</span>, <span class="number">1000</span>);</div><div class="line">    <span class="comment">// View 的重绘  </span></div><div class="line">    invalidate();</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 重写 computeScroll 方法，并在内部完成平滑滚动的逻辑  </span></div><div class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset())&#123;</div><div class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</div><div class="line">        <span class="comment">// 再次进行重绘  </span></div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此关于View的基础知识基本结束，如有笔误，或者理解错误的地方，望多多指导！！</p>
<p>​</p>
<p>​</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/07/yongyu_20160803_volley_use_and_source_code_study/" itemprop="url">
                  Volley学习笔记之简单使用及部分源码详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-07T22:49:40+08:00" content="2016-08-07">
              2016-08-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android源码学习/" itemprop="url" rel="index">
                    <span itemprop="name">Android源码学习</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/07/yongyu_20160803_volley_use_and_source_code_study/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/07/yongyu_20160803_volley_use_and_source_code_study/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载请附原文链接：<a href="http://yongyu.itscoder.com/2016/08/07/yongyu_20160803_volley_use_and_source_code_study/" target="_blank" rel="external">Volley学习笔记之简单使用及部分源码详解</a> </p>
<h2 id="一、使用背景简介"><a href="#一、使用背景简介" class="headerlink" title="一、使用背景简介"></a>一、使用背景简介</h2><p>现在大多数手机 App 几乎都离不开网络技术，需要手机端与网络服务端进行数据交互，Android 系统中主要提供了两种方式来进行HTTP通信，HttpURLConnection 和 HttpClient，在初学 Android 的时候，这两个类是我们最开始学着使用的，但是在使用过程中需要调取各种API，进行封，然后请求到的结果需要自己去解析，最后再将解析到的数据进行封装存到数据库，整个过程，相当复杂，而且重复性很高，于是针对这种情况，网络上就有大神封装了各种第三方框架供我们使用，将这些复杂冗余操作进行组合优化，使得整个编写过程得以简化，只需简单配置几行代码就可以完成整个流程操作。今天我们介绍的 Volley  就是其中一个优秀第三方框架。笔者所在公司目前项目使用的就是Volley ，所以在使用的同时决定写一系列笔记分析，从学会简单使用，到最后的 Volley 源码分析一系列循序渐进的流程来理解Volley的实现原理。</p>
<h2 id="二、Volley简介"><a href="#二、Volley简介" class="headerlink" title="二、Volley简介"></a>二、Volley简介</h2><p>Volley 是 Google在 Google I/O 2013 大会上 推出的 Android 异步网络请求和图片加载框架。</p>
<ul>
<li><p>主要作用 ：实现异步网络请求、图片加载。</p>
</li>
<li><p>主要特点：</p>
<p>(1).  Volley基于接口设计，扩展性强，我们可以根据我们的需求定制自己想要的请求方式方法。<br>(2).  一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。<br>(3).  默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现。</p>
<p>(4). 支持指定请求的优先级。</p>
<p>(5). 高并发网络连接。</p>
</li>
<li><p>使用下载地址：<a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="external">https://android.googlesource.com/platform/frameworks/volley</a></p>
<p>可以使用git 下载命令 git clone  <a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="external">https://android.googlesource.com/platform/frameworks/volley</a></p>
<ul>
<li>编译jar：<br><code>android update project -p . ant jar</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>添加volley.jar到你的项目中</p>
<p>  <strong>不过已经有人将volley的代码放到github上了：</strong><br>  <a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="external">https://github.com/mcxiaoke/android-volley</a>，你可以使用更加简单的方式来使用volley</p>
</li>
</ul>
<h2 id="三、简单使用"><a href="#三、简单使用" class="headerlink" title="三、简单使用"></a>三、简单使用</h2><p>使用Volley框架实现网络数据请求主要有以下三个步骤：</p>
<ol>
<li>创建RequestQueue对象，定义网络请求队列，RequestQueue内部的设计就是非常合适高并发的，因此我们不必为每一次HTTP请求都创建一个RequestQueue对象，避免非常浪费资源的，一般全局使用一个就可以。</li>
<li>创建XXXRequest对象(XXXRequest对象可以自己继承Request类进行封装定义，也可以使用Volley已经为我们提供的的StringReqeust、JsonArrayRequest、JsonObjectRequest)，这个类主要是功能是传入请求网址、解析返回数据、回调监听返回数据等功能的实现，也是我们经常继承包装的类，在这里可以实现我们想要的返回数据类型。</li>
<li>把XXXRequest对象添加到RequestQueue中，开始执行网络请求。</li>
</ol>
<p>怎么样，这样看来整个网络请求是否是变得便捷，不需要你去考虑，如何调取Http请求各种API，不需要考虑异步等问题，Volley已经帮助我们完成，下面简单以StringReqeust为例子发起一个Get请求，编写一个小的Demo用例，结合代码，加深理解：</p>
<p>网络请求队列一般都是整个APP内使用的全局性对象，因此最好写入Application类中，全局只使用一个，避免浪费资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"><span class="comment">// 建立请求队列</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue queue;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    queue = Volley.newRequestQueue(getApplicationContext());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">getVolleyRequestQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> queue;</div><div class="line"> &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们还需要修改AndroidManifest.xml文件，使APP的Application对象为我们刚定义的MyApplication，并添加INTERNET权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</div><div class="line"></div><div class="line">&lt;application</div><div class="line"></div><div class="line">    android:name=&quot;.MyApplication&quot;</div><div class="line"></div><div class="line">    android:allowBackup=&quot;true&quot;</div><div class="line"></div><div class="line">    android:icon=&quot;@mipmap/ic_launcher&quot;</div><div class="line"></div><div class="line">    android:label=&quot;@string/app_name&quot;</div><div class="line"></div><div class="line">    android:supportsRtl=&quot;true&quot;</div><div class="line"></div><div class="line">    android:theme=&quot;@style/AppTheme&quot; &gt;</div><div class="line"></div><div class="line">&lt;/application&gt;</div></pre></td></tr></table></figure>
<p>创建StringReqeust对象，并将其添加到RequestQueue中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Request.Method.GET 指定请求方法，如果不输入，默认为Get方法</div><div class="line">  *  new Response.Listener &lt;String&gt; 请求成功回调接口</div><div class="line">  *   new Response.ErrorListener() 请求失败回到接口</div><div class="line">  * <span class="doctag">@param</span> url 要请求的网址</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">     StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Request.Method.GET,url, <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</div><div class="line">             <span class="comment">//这里得到我们请求成功的结果</span></div><div class="line">             Log.d(<span class="string">"TAG"</span>, response);</div><div class="line">         &#125;</div><div class="line">     &#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</div><div class="line">             <span class="comment">//这里得到我们请求请求失败的信息</span></div><div class="line">             Log.e(<span class="string">"TAG"</span>, error.getMessage());</div><div class="line">         &#125;</div><div class="line">     &#125;);</div><div class="line">     <span class="comment">//将stringRequest添加到RequestQueue中</span></div><div class="line">     MyApplication.getVolleyRequestQueue().add(stringRequest);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>好了，这样我们就完成完成了StringRequest请求操作，在onResponse方法内得到我们想要的请求结果String 类型数据。</p>
<h2 id="四、使用思考"><a href="#四、使用思考" class="headerlink" title="四、使用思考"></a>四、使用思考</h2><p>在上面使用StringRequest请求过程中，我们只需要简单三步就完成了整个请求，那么有没有想过，Volley内部是如何实现的呢，思考以下几个问题：</p>
<ol>
<li>如何实现高并发请求</li>
<li>如何实现异步请求</li>
<li>如何实现数据缓存</li>
<li>内部是如何各种继承，组合封装最后几行代码就可以实现请求功能，但是使用拓展性又那么强。</li>
</ol>
<p>相信不想只做代码搬运工的你在使用过程中也会有这些甚至更多疑问，笔者在使用过程中一直好奇这些，否则在项目中只是简单调用人家已经封装好的几行代码，总感觉自己是一个搬运工，不知其所以然，所以现在决定，静下心来，去尝试分析一下Volley源码，以此记录分享。</p>
<h2 id="五、源码分析"><a href="#五、源码分析" class="headerlink" title="五、源码分析"></a>五、源码分析</h2><p>首先我们来看看Volley官方给出的一张Volley工作流程图 </p>
<p><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/operating_principle.png?raw=true" alt="“Volley工作原理如”"></p>
<p>下面将这张图翻译如下：</p>
<p><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/operating%20principle-cn.png?raw=true" alt="“Volley工作原理如”"></p>
<p>通过上面这张图我们可以对Volley工作流程有一个大概的印象，下面我们根据这张流程图以及Volley使用过程来结源码进行分析：</p>
<p>首先从我们使用的入口Volley.newRequestQueue(context)方法来来作为我们分析的切入点，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用volley的入口，一般默认调用这个方法即可创建一个默认的网络请求列队，启动一个请求队列RequestQueue，</div><div class="line"> * 只需要往这个RequestQueue不断 add Request 即可发起请求</div><div class="line"> * <span class="doctag">@param</span> context用于创建缓存文件夹</div><div class="line"> * <span class="doctag">@return</span> 返回 instance.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法仅仅只有一行代码，只是调用了newRequestQueue()的方法重载，并给第二个参数传入null。那我们接着分析带有两个参数的newRequestQueue()方法中的代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> context A 用于创建缓存文件夹</div><div class="line"> * <span class="doctag">@param</span> stack HttpStack处理http网络请求包装，可以自己定义，如果传入null，</div><div class="line"> *那么就使用系统默认的HttpStack</div><div class="line"> * <span class="doctag">@return</span> A 返回 instance.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">return</span> newRequestQueue(context, stack, -<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法也很简单，直接调用了含三个参数的构造方法，那么我们接着看看含三个参数的构造方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> context A 用于创建缓存文件夹</div><div class="line">     * <span class="doctag">@param</span> stack HttpStack处理http网络请求包装，内部就是我		</div><div class="line">     *们使用过的HttpURLConnection或者HttpClient，进行包装处</div><div class="line">     *理，可以自己定义，也可以传入null，那么就使用系统默认的HttpStack</div><div class="line">     * <span class="doctag">@param</span> maxDiskCacheBytes 设置最大sd卡缓存,如果传入-1</div><div class="line">     *就使用默认缓存</div><div class="line">     * <span class="doctag">@return</span> A 返回 instance.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack, <span class="keyword">int</span> maxDiskCacheBytes)</span> </span>&#123;</div><div class="line">        <span class="comment">//创建指定缓存文件</span></div><div class="line">        File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * UA一般都用于统计与识别</div><div class="line">         * User-Agent是Http协议中的一部分，属于头域的组成部</div><div class="line">         *分，User Agent也简称UA。用较为普通的一点来说</div><div class="line">         * ，是一种向访问网站提供你所使用的浏览器类型、操作系统</div><div class="line">         *及版本、CPU 类型、浏览器渲染引擎、浏览器语言、浏览器插</div><div class="line">         *件等信息的标识。</div><div class="line">         * UA字符串在每次浏览器 HTTP 请求时发送到服务器</div><div class="line">         */</div><div class="line">        String userAgent = <span class="string">"volley/0"</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//获取包名</span></div><div class="line">            String packageName = context.getPackageName();</div><div class="line">            <span class="comment">//获取包信息</span></div><div class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</div><div class="line">            <span class="comment">//获取userAgent</span></div><div class="line">            userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</div><div class="line">        &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//如果传入stack参数为null，那么创建默认的stack</span></div><div class="line">        <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//如果 API 大于9采用基于 HttpURLConnection 的 //HurlStack</span></div><div class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</div><div class="line">                stack = <span class="keyword">new</span> HurlStack();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// API小于9采用基于 HttpClient 的 //HttpClientStack</span></div><div class="line">            stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="comment">//new一个网络请求包装对象，并传入stack</span></div><div class="line">        Network network = <span class="keyword">new</span> BasicNetwork(stack);</div><div class="line">        RequestQueue queue;</div><div class="line">        <span class="keyword">if</span> (maxDiskCacheBytes &lt;= -<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//没有设置最大缓存maxDiskCacheBytes，创建默认大小缓存</span></div><div class="line">           queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">//设置最大缓存大小为maxDiskCacheBytes</span></div><div class="line">           queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir, maxDiskCacheBytes), network);</div><div class="line">        &#125;</div><div class="line"><span class="comment">//启动列队</span></div><div class="line">        queue.start();</div><div class="line"><span class="comment">//返回列队instance</span></div><div class="line">        <span class="keyword">return</span> queue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法代码稍微多一点，代码已经注释，这个构造方法主要是new 了一个 负责处理网络请求部分的stack对象，然后 用BasicNetwork将stack进行包装处理，又new了一个负责缓存部分的DiskBasedCache对象，并将这两个参数传入了列队queue中，并启动了列队；这里说明一下，在创建HttpStack对象的时候是比较了一下版本号，如果Build.VERSION.SDK_INT &gt;= 9（ API大于9）， stack = new HurlStack();这里是因为在Android 2.2版本之前，HttpURLConnection一直存在着一些令人厌烦的bug，在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量。到这里我们就完成使用volley的第一步分析，即获取RequestQueue对象，那么接下来我们分析下RequestQueue构造方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 创建请求列队，传入sd卡缓存包装类，和网络请求包装类</div><div class="line"> * 会调用含三个参数的构造方法，并传入参数默认参数DEFAULT_NETWORK_THREAD_POOL_SIZE为4，即默认</div><div class="line"> *线程数为4</div><div class="line"> * <span class="doctag">@param</span> cache sd卡缓存类</div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面分析含三个参数的构造方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 调用含四个参数的构造方法并传递默认 new ExecutorDelivery(new Handler(Looper.getMainLooper()))参数</div><div class="line"> * <span class="doctag">@param</span> cache sd卡缓存类</div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> * <span class="doctag">@param</span> threadPoolSize 网络请求线程的数量，这里threadPoolSize为DEFAULT_NETWORK_THREAD_POOL_SIZE</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(cache, network, threadPoolSize,</div><div class="line">            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>含四个参数的构造方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> cache sd卡缓存类 </div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> * <span class="doctag">@param</span> threadPoolSize 网络请求线程的数量</div><div class="line"> * <span class="doctag">@param</span> delivery用来回调网络请求结果的事件分发类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,</span></span></div><div class="line">        ResponseDelivery delivery) &#123;</div><div class="line">    mCache = cache;</div><div class="line">    mNetwork = network;</div><div class="line">    <span class="comment">//创建数量为DEFAULT_NETWORK_THREAD_POOL_SIZE 即数量为4的NetworkDispatcher数组</span></div><div class="line">    mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</div><div class="line">    <span class="comment">//mDelivery为含有三个参数构造函数调用传入的new ExecutorDelivery(new </span></div><div class="line">    <span class="comment">//Handler(Looper.getMainLooper()))对象</span></div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里我们来我们发现从调用含有两个参数的RequestQueue构造方法是逐渐调用三个、四个参数构造方法，那么最终实现了：mCachesd卡缓存类的实例化，network网络请求包装类 的实例化，创建了一个数量为4的NetworkDispatcher数组，mDelivery=new ExecutorDelivery(new Handler(Looper.getMainLooper())网络请求结果回调类的实例化。那么这里我们看一下回调网络请求结果类ExecutorDelivery构造方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> 创建一个回调网络请求结果的对象</div><div class="line"> * <span class="doctag">@param</span> handler 利用handler将runnable发送出去</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">//创建一个excuter包含了一个handler，然后利用传递进来的handler来将runnable发送出去</span></div><div class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">            handler.post(command);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的handler为new Handler(Looper.getMainLooper())，即handler是创建在主线程中，所以当调用 handler.post(command)的时候，是将网络请求结果发送到主线程主去处理，这样就完成了异步任务，将子线程中网络请求的结果发送到主线程中去处理。以上就完成了构造RequestQueue对象过程中的代码分析。</p>
<p>下面还有一个疑问要分析就是我们在调用volley的时候执行的RequestQueue.add()方法，分析一下是如何将请求添加到缓存列队和网络请求列队，以及如何进行管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 该方法用于向列队中添加请求request</div><div class="line"> * 其中包含了几种列队，起到不同的作用</div><div class="line"> * mCurrentRequests列队，用于存储目前正在进行但是尚未完成的请求</div><div class="line"> * mNetworkQueue网络请求列队，用于存储走网络的请求</div><div class="line"> * mWaitingRequests 如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将当前请求和处理请求的queue进行关联，这样当该请求结束的时候就会通知负责处理该请求的queue</span></div><div class="line">    request.setRequestQueue(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">      <span class="comment">//将请求添加到当前请求列队中</span></div><div class="line">        mCurrentRequests.add(request);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//添加序列号</span></div><div class="line">    request.setSequence(getSequenceNumber());</div><div class="line">    <span class="comment">//添加标记</span></div><div class="line">    request.addMarker(<span class="string">"add-to-queue"</span>);</div><div class="line">    <span class="comment">//如果请求不能缓存，直接添加到网络请求列队，结束方法</span></div><div class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;</div><div class="line">        mNetworkQueue.add(request);</div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//如果方法走到这一步说明，我们使用了缓存功能</span></div><div class="line">    <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">      <span class="comment">//取出请求的缓存键</span></div><div class="line">        String cacheKey = request.getCacheKey();</div><div class="line">      </div><div class="line">        <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class="line">            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class="line">            <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</div><div class="line">                stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果mWaitingRequests已经包含该请求，那么将该请求添加到mWaitingRequests中</span></div><div class="line">            stagedRequests.add(request);</div><div class="line">            mWaitingRequests.put(cacheKey, stagedRequests);</div><div class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//如果该请求不在正在执行等待的类列队mWaitingRequests中，直接添加到mCacheQueue中</span></div><div class="line">            mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</div><div class="line">            mCacheQueue.add(request);</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//返回当前请求</span></div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们来捋一捋request是如何被添加到请求列队中的步骤如下：</p>
<p>1、当add一个请求request时候，首先该请求会被添加当当前请求列队mCurrentRequests中。</p>
<p>2、如果该请求不使用缓存那么直接被添加到网络请求列队mNetworkQueue结束方法。</p>
<p>3、如果该请求使用了缓存，那么先判断mWaitingRequests列队中是否有该请求，如果有那么添加到mWaitingRequests中，如果没有直接添加到缓存请求列队mCacheQueue中。</p>
<p>到这里我们理解了一个请求是如何被添加到列队中，但是同时会产生一个疑问就是mCurrentRequests和mWaitingRequests这两个列队的作用是什么，以及如何调用的，我们初略猜想一下，这两个列队中维护的请求应该在一个请求结束的时候，将该请求移除，那么应该是RequestQueue的finish方法中进行调用，那么下面我们来看一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 该方法会在Request的方法中进行调用finish(String)，表明当前请求已经结束</div><div class="line"> * 需要从mCurrentRequests和mWaitingRequests中移除保存的请求Request</div><div class="line"> */</div><div class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">      <span class="comment">//从当前请求列队mCurrentRequests中移除请求request</span></div><div class="line">        mCurrentRequests.remove(request);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (mFinishedListeners) &#123;</div><div class="line">      <span class="keyword">for</span> (RequestFinishedListener&lt;T&gt; listener : mFinishedListeners) &#123;</div><div class="line">        listener.onRequestFinished(request);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (request.shouldCache()) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">            String cacheKey = request.getCacheKey();</div><div class="line">            <span class="comment">//如果请求可以使用缓存，将mWaitingRequests中存储的waitingRequests移除</span></div><div class="line">            Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class="line">         </div><div class="line">            <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                    VolleyLog.v(<span class="string">"Releasing %d waiting requests for cacheKey=%s."</span>,</div><div class="line">                            waitingRequests.size(), cacheKey);</div><div class="line">                &#125;</div><div class="line">                 <span class="comment">//如果移除当前结束的请求后，如果移除的waitingRequests！=null，</span></div><div class="line">            <span class="comment">// 那么将其添加到缓存列队mCacheQueue</span></div><div class="line">                mCacheQueue.addAll(waitingRequests);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码只需要看注释部分即可，并不复杂，那么RequestQueue的finish应该是什么时候调用呢，我们猜想应该是在一个request方法请求结束的时候，我们来看一下在Request类的finish方法中代码是否如此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">final</span> String tag)</span> </span>&#123;</div><div class="line">  <span class="comment">//调用处</span></div><div class="line">    <span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) &#123;</div><div class="line">        mRequestQueue.finish(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (MarkerLog.ENABLED) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> threadId = Thread.currentThread().getId();</div><div class="line">        <span class="keyword">if</span> (Looper.myLooper() != Looper.getMainLooper()) &#123;</div><div class="line">            Handler mainThread = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">            mainThread.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    mEventLog.add(tag, threadId);</div><div class="line">                    mEventLog.finish(<span class="keyword">this</span>.toString());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mEventLog.add(tag, threadId);</div><div class="line">        mEventLog.finish(<span class="keyword">this</span>.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码我们在第三行看到了mRequestQueue.finish(this);那么request方法结束请求有三种可能分别是：手动调用request.cancel方法取消请求、request请求成功回调成功结果、request请求失败回调失败结果，这三种请求都是表面当前request请求结束，那么我们分别看一下这三处的代码是否进行了调用，我们以网络请求线程NetworkDispatcher为例（缓存线程调度原理相同）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行网络请求线程，耗时任务的执行</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      ........</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                    <span class="comment">//如果请求取消，结束请求</span></div><div class="line">                    request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                  <span class="comment">//继续从列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">          ........</div><div class="line">               </div><div class="line">                <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                   <span class="comment">//如果networkResponse状态为304，并且已经返回了响应结果，那么结束请求不进行第二次返回</span></div><div class="line">                    request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                  <span class="comment">//继续请求列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">               ..........</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后看一下请求结果回调类ExecutorDelivery的run，执行了该方法表明将request请求结果进行了回调，所以request.finish()方法在此处也有调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//调用处</span></div><div class="line">        <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</div><div class="line">            mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">       ........</div><div class="line">        <span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">          <span class="comment">//如果这个请求需要刷新那么这个请求又被添加到了列队中，所以还在列队中，不要finish</span></div><div class="line">            mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">//否则调用finish</span></div><div class="line">            mRequest.finish(<span class="string">"done"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">.......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样mCurrentRequests和mWaitingRequests这两个列队的管理基本就捋清楚了。</p>
<p>下面我们就要思考获取到requestQueue对象，调用requestQueue.add（request）方法后，是如何启动网络请求的，那么我们看到在RequestQueue构造方法中有一行代码    queue.start()方法，那么接下来我们来分析一下这个方法具体内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 开始执行在列队中的各个线程分发调度</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//停止所有当前正在执行分发调度事件</span></div><div class="line">    stop();  </div><div class="line">    <span class="comment">//创建一个执行缓存分发调度线程，并将mCacheQueue缓存列队, mNetworkQueue网络请求列队, mCache缓存对象, mDelivery事件分发对象传递进去</span></div><div class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class="line">    <span class="comment">//启动缓存事件分发</span></div><div class="line">    mCacheDispatcher.start();</div><div class="line">    <span class="comment">//当i &lt; mDispatchers.length时循环创建networkDispatcher对象</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">       <span class="comment">//创建一个网络请求线程调度networkDispatcher线程，并将 mCacheQueue缓存列队, mNetworkQueue网络</span></div><div class="line">       <span class="comment">//请求列队, mCache负责处理缓存对象, mDelivery事件分发对象传递进去</span></div><div class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class="line">                mCache, mDelivery);</div><div class="line">        mDispatchers[i] = networkDispatcher;</div><div class="line">        <span class="comment">//启动网络缓存线程</span></div><div class="line">        networkDispatcher.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码主要实现功能是创建一个缓存事件调度线程并启动，然后循环创建了n个网络请求线程调度networkDispatcher对象，这里n= mDispatchers.length。mDispatchers数组的长度即是构造RequestQueue过程中传入的参数DEFAULT_NETWORK_THREAD_POOL_SIZE 即数量为4，也就是说创建了4个负责网络请求调度的线程。下面我们一起分析一下CacheDispatcher缓存调度线程代码，CacheDispatcher 继承自Thread，是一个线程，先看一下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> cacheQueue 缓存列队</div><div class="line"> * <span class="doctag">@param</span> networkQueue 网络请求列队</div><div class="line"> * <span class="doctag">@param</span> cache 缓存类</div><div class="line"> * <span class="doctag">@param</span> delivery 请求结果回调分发类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheDispatcher</span><span class="params">(</span></span></div><div class="line">        BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue, BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,</div><div class="line">        Cache cache, ResponseDelivery delivery) &#123;</div><div class="line">    mCacheQueue = cacheQueue;</div><div class="line">    mNetworkQueue = networkQueue;</div><div class="line">    mCache = cache;</div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后主要看一下run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//复写Run方法，这里执行耗时操作，在子线程中执行</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</div><div class="line">    <span class="comment">//设置线程优先级</span></div><div class="line"> Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">    <span class="comment">//初始化缓存类</span></div><div class="line">    mCache.initialize();</div><div class="line">  <span class="comment">//循环从列队中读取请求并执行</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//从列队的首部取出一个request</span></div><div class="line">            <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</div><div class="line">            <span class="comment">//添加一个标记</span></div><div class="line">            request.addMarker(<span class="string">"cache-queue-take"</span>);</div><div class="line">            <span class="comment">//如果取出的请求取消，那么结束请求</span></div><div class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                request.finish(<span class="string">"cache-discard-canceled"</span>);</div><div class="line">              <span class="comment">//继续循环从缓存列队中拿请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//从缓存中读取缓存数据</span></div><div class="line">            Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//如果请求结果为null，那么添加标记</span></div><div class="line">                request.addMarker(<span class="string">"cache-miss"</span>);</div><div class="line">                 <span class="comment">//然后将请求发送到网络请求列队</span></div><div class="line">                mNetworkQueue.put(request);</div><div class="line">               <span class="comment">//然后继续循环去缓存列队中拿取请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (entry.isExpired()) &#123;</div><div class="line">                <span class="comment">//如果缓存过期，添加标记</span></div><div class="line">                request.addMarker(<span class="string">"cache-hit-expired"</span>);</div><div class="line">                request.setCacheEntry(entry);</div><div class="line">              <span class="comment">//将请求发送到网络请求列队</span></div><div class="line">                mNetworkQueue.put(request);</div><div class="line">              <span class="comment">//然后继续去缓存列队中拿取请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//走到这一步，说明已经拿到缓存，添加标记命中</span></div><div class="line">            request.addMarker(<span class="string">"cache-hit"</span>);</div><div class="line">            <span class="comment">//解析网络缓存数据NetworkResponse得到Response&lt;T&gt; 结果</span></div><div class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">                    <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line">            <span class="comment">//标记解析完成</span></div><div class="line">            request.addMarker(<span class="string">"cache-hit-parsed"</span>);</div><div class="line">            <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</div><div class="line">                <span class="comment">//如果不需要刷新，那么直接将解析结果回调</span></div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//如果需要刷新，那么添加标记</span></div><div class="line">                request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</div><div class="line">                request.setCacheEntry(entry);</div><div class="line">                response.intermediate = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">//返回数据，并将将请求添加到网络请求列队，但是是发送出去到主线程中执行</span></div><div class="line">                mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            mNetworkQueue.put(request);</div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="comment">//调用mQuit方法结束循环</span></div><div class="line">            <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">          <span class="comment">//否则继续缓存列队中取出request</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个run方法主要作用是：启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code> 去执行，将请求结果发送到主线程中。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入<code>NetworkDispatcher</code>去调度处理。这里有一行代码mDelivery.postResponse(request, response);是将请求结果发送到主线程中，前面我们提到是利用handler.post()方法执行，那么我们看看ExecutorDelivery 类的postResponse的具体细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</div><div class="line">    <span class="comment">//直接调用三个参数的post方法</span></div><div class="line">    postResponse(request, response, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就一行代码，调用含三个参数的构造方法，那么我们继续追溯：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</div><div class="line">    request.markDelivered();</div><div class="line">    request.addMarker(<span class="string">"post-response"</span>);</div><div class="line">    <span class="comment">//通过ResponseDeliveryRunnable将request, response, runnable包装后发送出去到主线程handle中</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的mResponsePoster就是在构造ExecutorDelivery 时候生成的Executor对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">// Make an Executor that just wraps the handler.</span></div><div class="line">    <span class="comment">//创建一个excuter包含了一个handler，handler来将runnable发送出去</span></div><div class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">          <span class="comment">//将Runnable对象发送到主线程</span></div><div class="line">            handler.post(command);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而ResponseDeliveryRunnable继承Runnable，所以当调用mResponsePoster.execut（new ResponseDeliveryRunnable(request, response, runnable)）方法时候就会将ResponseDeliveryRunnable对象发送到主线程中，那么我们看一下ResponseDeliveryRunnable类的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在主线程中运行</span></div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</div><div class="line">              <span class="comment">//如果请求取消，那么结束方法</span></div><div class="line">                mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</div><div class="line">              <span class="comment">//如果请求成功调用mRequest.deliverResponse，这个方法在我们自定义request时候需要重写的，每一条网络请求的响应都是回调到这个方法中，主线程中运行</span></div><div class="line">            mRequest.deliverResponse(mResponse.result);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="comment">//请求失败回调</span></div><div class="line">                mRequest.deliverError(mResponse.error);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">                mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mRequest.finish(<span class="string">"done"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="comment">//如果传入Runnable不为空，那么执行Runnable</span></div><div class="line">                mRunnable.run();</div><div class="line">            &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码我们看自定义Request时候需要复写的方法   mRequest.deliverResponse(mResponse.result);和mRequest.deliverError(mResponse.error)。到这里请求回调的疑问我们已经解决。</p>
<p>下面我们先分析一下NetworkDispatcher网络缓存线程，NetworkDispatcher 继承自Thread，也就是说NetworkDispatcher 是一个线程先看一下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> queue 网络请求列队</div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> * <span class="doctag">@param</span> cache 缓存类</div><div class="line"> * <span class="doctag">@param</span> delivery 请求结果回调分发类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkDispatcher</span><span class="params">(BlockingQueue&lt;Request&lt;?&gt;&gt; queue,</span></span></div><div class="line">        Network network, Cache cache,</div><div class="line">        ResponseDelivery delivery) &#123;</div><div class="line">    mQueue = queue;</div><div class="line">    mNetwork = network;</div><div class="line">    mCache = cache;</div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后看一下复写的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行网络请求线程，耗时任务的执行,在子线程中执行</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">//设置线程优先级</span></div><div class="line"> Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        Request&lt;?&gt; request;</div><div class="line">      <span class="comment">//从网络请求列队中循环读取request并执行请求</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">long</span> startTimeMs = SystemClock.elapsedRealtime();</div><div class="line">            request = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//从网络请求列队中拿到一个请求</span></div><div class="line">                request = mQueue.take();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                <span class="comment">//如果调用了mQuit就直接结束该方法</span></div><div class="line">                <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">              <span class="comment">//否则继续从列队中拿请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//添加拿到标记</span></div><div class="line">                request.addMarker(<span class="string">"network-queue-take"</span>);</div><div class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                    <span class="comment">//如果请求取消，结束请求</span></div><div class="line">                    request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                  <span class="comment">//继续从列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//设置线程状态</span></div><div class="line">                addTrafficStatsTag(request);</div><div class="line">                <span class="comment">//执行网络请求，得到请求结果NetworkResponse</span></div><div class="line">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">                <span class="comment">//添加执行请求完成状态</span></div><div class="line">                request.addMarker(<span class="string">"network-http-complete"</span>);</div><div class="line">               </div><div class="line">                <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                   <span class="comment">//如果networkResponse状态为304，并且已经传递了响应结果，那么结束请求不进行第二次返回</span></div><div class="line">                    request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                  <span class="comment">//继续请求列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//将networkResponse解析成  Response&lt;?&gt; response，这个解析方法我们可以自己在</span></div><div class="line">              <span class="comment">//Request类进行复写，自己定义解析方法</span></div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">              <span class="comment">//添加解析完成标记</span></div><div class="line">                request.addMarker(<span class="string">"network-parse-complete"</span>);</div><div class="line">                <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//如果请求使用了缓存，并且响应结果不为空，那么将请求结果存入缓存</span></div><div class="line">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">                  <span class="comment">//添加完成缓存标记</span></div><div class="line">                    request.addMarker(<span class="string">"network-cache-written"</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//添加请求结果回调标记</span></div><div class="line">                request.markDelivered();</div><div class="line">              <span class="comment">//回调响应结果，即将请求响应结果，发送到主线程</span></div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</div><div class="line">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">              <span class="comment">//请求网络失败回调</span></div><div class="line">                parseAndDeliverNetworkError(request, volleyError);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</div><div class="line">                VolleyError volleyError = <span class="keyword">new</span> VolleyError(e);</div><div class="line">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">              <span class="comment">//请求失败回调</span></div><div class="line">                mDelivery.postError(request, volleyError);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>run方法启动后会不断从网络请求队列中取请求处理，队列为空则等待，拿到请求后，则执行网络请求，请求处理结束则将结果传递给 ResponseDelivery 去执行后续处理，并判断结果是否要进行缓存。</p>
<p>下面我们来捋一捋volley如如何进行网络请求、缓存请求和请求结果的回调，步骤如下：</p>
<p>1、创建了一个缓存事件调度线程CacheDispatcher，负责从缓存列队中读取请求，然后从缓存中读取数据，进行解析返回，从缓存中读取数据为null，或者数据过期、需要刷新，那么将请求添加到网络请求列队。</p>
<p>2、创建了四个网络请求事件调度线程NetworkDispatcher，负责处理网络请求，并解析请求结果进行返回，并将结果缓存到本地。</p>
<p>3、创建了一个请求结果回调类ResponseDelivery，负责将请求结果返回到主线程，原理是利用handler将结果post到主线程。</p>
<p>到这里volley框架的主要流程我们基本梳理通顺了，下面我们在看一下细节方面，网络请求是如何执行的，上面代码中执行网络请求代码mNetwork.performRequest(request)，其中mNetwork就是我们在构造RequestQueue时候传入的BasicNetwork对象，那么看一下具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 通过HttpStack，即执行http网络请求请求</div><div class="line"> * 并将HttpStack请求结果包装成NetworkResponse返回NetworkRespons</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</div><div class="line">    <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="comment">//http请求头文件包装信息</span></div><div class="line">        HttpResponse httpResponse = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//请求返回内容body</span></div><div class="line">        <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//生成一个map对象</span></div><div class="line">        Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">            <span class="comment">//添加请求头文件信息，entry即是定义request类时候复写setCacheEntry传入</span></div><div class="line">            addCacheHeaders(headers, request.getCacheEntry());</div><div class="line">            <span class="comment">//执行mHttpStack操作返回请求结果httpResponse</span></div><div class="line">            httpResponse = mHttpStack.performRequest(request, headers);</div><div class="line">            <span class="comment">//获取到请求状态</span></div><div class="line">            StatusLine statusLine = httpResponse.getStatusLine();</div><div class="line">            <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</div><div class="line">            <span class="comment">//取出httpResponse中header添加到responseHeaders</span></div><div class="line">            responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class="line">            <span class="comment">//如果是304状态没有更新状态</span></div><div class="line">            <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class="line">                <span class="comment">//缓存中取出entry对象</span></div><div class="line">                Entry entry = request.getCacheEntry();</div><div class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//如果entry为null，返回一个entry为null的NetworkResponse</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, <span class="keyword">null</span>,</div><div class="line">                            responseHeaders, <span class="keyword">true</span>,</div><div class="line">                            SystemClock.elapsedRealtime() - requestStart);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                entry.responseHeaders.putAll(responseHeaders);</div><div class="line">                <span class="comment">//如果entry不为null，返回一个entry的NetworkResponse</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class="line">                        entry.responseHeaders, <span class="keyword">true</span>,</div><div class="line">                        SystemClock.elapsedRealtime() - requestStart);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//301/302 Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</span></div><div class="line">            <span class="keyword">if</span> (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class="line">               String newUrl = responseHeaders.get(<span class="string">"Location"</span>);</div><div class="line">               request.setRedirectUrl(newUrl);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//获取entry不为null,将entry转换为byte类型</span></div><div class="line">              responseContents = entityToBytes(httpResponse.getEntity());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//否则new 一个responseContents对象</span></div><div class="line">              responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class="line">            <span class="comment">//打印请求生命周期，请求，响应内容，和状态</span></div><div class="line">            logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class="line">            <span class="comment">//根据状态码抛出异常</span></div><div class="line">            <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//返回包含响应entry和header的NetworkResponse</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>,</div><div class="line">                    SystemClock.elapsedRealtime() - requestStart);</div><div class="line">            <span class="comment">//抛出各种异常</span></div><div class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</div><div class="line">            attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</div><div class="line">        ...........</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段方法中大多都是一些网络请求细节方面的东西，部分已经添加注释，我们抓重点看即可，其中httpResponse = mHttpStack.performRequest(request, headers);这一行代码中的mHttpStack就是我们在构造RequestQueue的时候传入的HttpStack对象，负责处理http网络请求的，然后就是有几处代码是return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,        responseHeaders, true,        SystemClock.elapsedRealtime() - requestStart))，其中区别就是参数不同，所以这个方法其实只要实现功能就是调用<code>HttpStack</code>处理网络请求，并将结果进行包装转换为可被<code>ResponseDelivery</code>处理的<code>NetworkResponse</code>对象返回。</p>
<p>下面我们看一下mHttpStack.performRequest(request, headers)这个方法是如何处理网络请求的（以HurlStack类为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 封装执行HttpURLConnection网络请求，返回HttpResponse对象</div><div class="line"> * <span class="doctag">@param</span> request the request to perform</div><div class="line"> * <span class="doctag">@param</span> additionalHeaders 附加的请求头文件信息</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException, AuthFailureError &#123;</div><div class="line">    <span class="comment">//获取网络请求url</span></div><div class="line">    String url = request.getUrl();</div><div class="line">    <span class="comment">//new 一个map对象</span></div><div class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">    <span class="comment">//将请求header信息添加进去</span></div><div class="line">    map.putAll(request.getHeaders());</div><div class="line">    map.putAll(additionalHeaders);</div><div class="line">    <span class="keyword">if</span> (mUrlRewriter != <span class="keyword">null</span>) &#123;</div><div class="line">        String rewritten = mUrlRewriter.rewriteUrl(url);</div><div class="line">        <span class="keyword">if</span> (rewritten == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"URL blocked by rewriter: "</span> + url);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取到url</span></div><div class="line">        url = rewritten;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//解析url</span></div><div class="line">    URL parsedUrl = <span class="keyword">new</span> URL(url);</div><div class="line">    <span class="comment">//创建HttpURLConnection网络请求连接</span></div><div class="line">    HttpURLConnection connection = openConnection(parsedUrl, request);</div><div class="line">    <span class="keyword">for</span> (String headerName : map.keySet()) &#123;</div><div class="line">        <span class="comment">//添加请求头信息</span></div><div class="line">        connection.addRequestProperty(headerName, map.get(headerName));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置连接参数，主要设置各种请求类型</span></div><div class="line">    setConnectionParametersForRequest(connection, request);</div><div class="line">  ........</div><div class="line">    <span class="comment">//解析请求body请求体</span></div><div class="line">    response.setEntity(entityFromConnection(connection));</div><div class="line">    <span class="keyword">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</div><div class="line">        <span class="keyword">if</span> (header.getKey() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//解析请求header添加请求头</span></div><div class="line">            Header h = <span class="keyword">new</span> BasicHeader(header.getKey(), header.getValue().get(<span class="number">0</span>));</div><div class="line">            response.addHeader(h);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//请求结果返回</span></div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码中我们终于看见了我们熟悉的HttpURLConnection对象，并进行了一系列的参数设置，解析返回数据返回HttpResponse对象。到这里负责执行网络请求部分的内容我们也梳理结束。</p>
<p>至此，关于volley的学习笔记到此结束，如有理解错误地方，还请指教！！</p>
<p>最后其实网络上关 Volley源码分析有很多文章，东西都差不多，但是每个人的侧重点和分析角度以及能否把事情讲的通俗易懂差别就大了，关键是要找到适合自己的，如果感觉本人分析你读着比较懵逼，那可能是我写的不清真，那么可以出门左拐<a href="http://yongyu.itscoder.com/2016/08/01/Volley%20Study/" target="_blank" rel="external"><a href="http://extremej.itscoder.com/volley_source/" target="_blank" rel="external">黑丫山上的小帅比 对Volley的深入分析</a></a> 和郭霖大神的博客去看一下，如果还是看不懂，那就有肯能是你理解的不清真了（just a joke) !!</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://github.com/yongyu0102/Images/blob/master/avatar/avatar.png?raw=true"
               alt="Yongyu" />
          <p class="site-author-name" itemprop="name">Yongyu</p>
          <p class="site-description motion-element" itemprop="description">这里记录你的故事！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://extremej.itscoder.com/" title="Joe" target="_blank">Joe</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yongyu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
 </script>
 </br>本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"yongyu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>

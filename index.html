<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>一个写代码的地方</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="一个写代码的地方">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="一个写代码的地方">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一个写代码的地方">
  
    <link rel="alternative" href="/atom.xml" title="一个写代码的地方" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null/images/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Yongyu</a></h1>
		</hgroup>

		
		<p class="header-subtitle">记录你的学习</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">Android开发</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/yongyu0102" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Yongyu</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="null/images/avatar.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Yongyu</h1>
			</hgroup>
			
			<p class="header-subtitle">记录你的学习</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">Android开发</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/yongyu0102" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-Volley Study" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/01/Volley Study/" class="article-date">
  	<time datetime="2016-08-01T14:41:25.127Z" itemprop="datePublished">2016-08-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/01/Volley Study/">Volley学习笔记之简单使用及部分源码详解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载请附原文链接：<a href="http://yongyu.itscoder.com/2016/08/01/Volley%20Study/" target="_blank" rel="external">Volley学习笔记之简单使用及部分源码详解</a> </p>
<h2 id="一、使用背景简介"><a href="#一、使用背景简介" class="headerlink" title="一、使用背景简介"></a>一、使用背景简介</h2><p>现在大多数手机App几乎都离不开网络技术，需要手机端与网络服务端进行数据交互，Android系统中主要提供了两种方式来进行HTTP通信，HttpURLConnection和HttpClient，在初学Android的时候，这两个类是我们最开始学着使用的，但是在使用过程中需要调取各种API，进行封，然后请求到的结果需要自己去解析，最后再将解析到的数据进行封装存到数据库，整个过程，相当复杂，而且重复性很高，于是针对这种情况，网络上就有大神封装了各种第三方使用库供我们使用，将这些流程封装组合包装优化，使得整个流程得以简化，只需简单配置，几行代码就完成整个过程。今天我们介绍的Volley 就是其中一个优秀第三方框架。笔者所在公司目前项目使用的就是Volley ，所以在使用的同时决定写一系列笔记分析，从学会简单使用，到最后的Volley源码分析一系列循序渐进的流程来理解Volley的实现原理。</p>
<h2 id="二、Volley简介"><a href="#二、Volley简介" class="headerlink" title="二、Volley简介"></a>二、Volley简介</h2><p>Volley 是 Google在 Google I/O 2013 大会上 推出的 Android 异步网络请求和图片加载框架。</p>
<ul>
<li><p>主要作用 ：实现异步网络请求、图片加载、本地数据缓存功能框架。</p>
</li>
<li><p>主要特点：</p>
<p>(1).  Volley基于接口设计，扩展性强，我们可以根据我们的需求定制自己想要的请求方式方法。<br>(2).  一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。<br>(3).  默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现。</p>
<p>(4). 支持指定请求的优先级。</p>
<p>(4). 高并发网络连接。</p>
</li>
<li><p>使用下载地址：<a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="external">https://android.googlesource.com/platform/frameworks/volley</a></p>
<p>可以使用git 下载命令 git clone  <a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="external">https://android.googlesource.com/platform/frameworks/volley</a></p>
<ul>
<li>编译jar：<br><code>android update project -p . ant jar</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>添加volley.jar到你的项目中</p>
<p>  <strong>不过已经有人将volley的代码放到github上了：</strong><br>  <a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="external">https://github.com/mcxiaoke/android-volley</a>，你可以使用更加简单的方式来使用volley</p>
</li>
</ul>
<h2 id="三、简单使用"><a href="#三、简单使用" class="headerlink" title="三、简单使用"></a>三、简单使用</h2><p>使用Volley框架实现网络数据请求主要有以下三个步骤：</p>
<ol>
<li>创建RequestQueue对象，定义网络请求队列，RequestQueue内部的设计就是非常合适高并发的，因此我们不必为每一次HTTP请求都创建一个RequestQueue对象，避免非常浪费资源的，一般全局使用一个就可以。</li>
<li>创建XXXRequest对象(XXXRequest对象可以自己继承Request类进行封装定义，也可以使用Volley已经为我们提供的的StringReqeust、JsonArrayRequest、JsonObjectRequest)，这个类主要是功能是传入请求网址、解析返回数据、回调监听返回数据等功能的实现，也是我们经常继承包装的类，在这里可以实现我们想要的返回数据类型。</li>
<li>把XXXRequest对象添加到RequestQueue中，开始执行网络请求。</li>
</ol>
<p>怎么样，这样看来整个网络请求是否是变得便捷，不需要你去考虑，如何调取Http请求各种API，不需要考虑异步等问题，Volley已经帮助我们完成，下面简单以StringReqeust为例子发起一个Get请求，编写一个小的Demo用例，结合代码，加深理解：</p>
<p>网络请求队列一般都是整个APP内使用的全局性对象，因此最好写入Application类中，全局只使用一个，避免浪费资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"><span class="comment">// 建立请求队列</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue queue;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    queue = Volley.newRequestQueue(getApplicationContext());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">getVolleyRequestQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> queue;</div><div class="line"> &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们还需要修改AndroidManifest.xml文件，使APP的Application对象为我们刚定义的MyApplication，并添加INTERNET权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</div><div class="line"></div><div class="line">&lt;application</div><div class="line"></div><div class="line">    android:name=&quot;.MyApplication&quot;</div><div class="line"></div><div class="line">    android:allowBackup=&quot;true&quot;</div><div class="line"></div><div class="line">    android:icon=&quot;@mipmap/ic_launcher&quot;</div><div class="line"></div><div class="line">    android:label=&quot;@string/app_name&quot;</div><div class="line"></div><div class="line">    android:supportsRtl=&quot;true&quot;</div><div class="line"></div><div class="line">    android:theme=&quot;@style/AppTheme&quot; &gt;</div><div class="line"></div><div class="line">&lt;/application&gt;</div></pre></td></tr></table></figure>
<p>创建StringReqeust对象，并将其添加到RequestQueue中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Request.Method.GET 指定请求方法，如果不输入，默认为Get方法</div><div class="line">  *  new Response.Listener &lt;String&gt; 请求成功回调接口</div><div class="line">  *   new Response.ErrorListener() 请求失败回到接口</div><div class="line">  * <span class="doctag">@param</span> url 要请求的网址</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">     StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Request.Method.GET,url, <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</div><div class="line">             <span class="comment">//这里得到我们请求成功的结果</span></div><div class="line">             Log.d(<span class="string">"TAG"</span>, response);</div><div class="line">         &#125;</div><div class="line">     &#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</div><div class="line">             <span class="comment">//这里得到我们请求请求失败的信息</span></div><div class="line">             Log.e(<span class="string">"TAG"</span>, error.getMessage());</div><div class="line">         &#125;</div><div class="line">     &#125;);</div><div class="line">     <span class="comment">//将stringRequest添加到RequestQueue中</span></div><div class="line">     MyApplication.getVolleyRequestQueue().add(stringRequest);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>好了，这样我们就完成完成了StringRequest请求操作，在onResponse方法内得到我们想要的请求结果String 类型数据。</p>
<h2 id="四、使用思考"><a href="#四、使用思考" class="headerlink" title="四、使用思考"></a>四、使用思考</h2><p>在上面使用StringRequest请求过程中，我们只需要简单三步就完成了整个请求，那么有没有想过，Volley内部是如何实现的呢，思考以下几个问题：</p>
<ol>
<li>如何实现高并发请求</li>
<li>如何实现异步请求</li>
<li>如何实现数据缓存</li>
<li>内部是如何各种继承，组合封装最后几行代码就可以实现请求功能，但是使用拓展性又那么强。</li>
</ol>
<p>相信不想只做代码搬运工的你在使用过程中也会有这些甚至更多疑问，笔者在使用过程中一直好奇这些，否则在项目中只是简单调用人家已经封装好的几行代码，总感觉自己是一个搬运工，不知其所以然，所以现在决定，静下心来，去尝试分析一下Volley源码，以此记录分享。</p>
<h2 id="五、源码分析"><a href="#五、源码分析" class="headerlink" title="五、源码分析"></a>五、源码分析</h2><p>首先我们来看看Volley官方给出的一张Volley工作流程图 </p>
<p><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/operating%20principle.png?raw=true" alt="“Volley工作原理如”"></p>
<p>下面将这张图翻译如下：</p>
<p><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/operating%20principle-cn.png?raw=true" alt="“Volley工作原理如”"></p>
<p>通过上面这张图我们可以对Volley工作流程有一个大概的印象，下面我们根据这张流程图以及Volley使用过程来结源码进行分析：</p>
<p>首先从我们使用的入口Volley.newRequestQueue(context)方法来来作为我们分析的切入点，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用volley的入口，一般默认调用这个方法即可创建一个默认的网络请求列队，启动一个请求队列RequestQueue，</div><div class="line"> * 只需要往这个RequestQueue不断 add Request 即可发起请求</div><div class="line"> * <span class="doctag">@param</span> context用于创建缓存文件夹</div><div class="line"> * <span class="doctag">@return</span> 返回 instance.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法仅仅只有一行代码，只是调用了newRequestQueue()的方法重载，并给第二个参数传入null。那我们接着分析带有两个参数的newRequestQueue()方法中的代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> context A 用于创建缓存文件夹</div><div class="line"> * <span class="doctag">@param</span> stack HttpStack处理http网络请求包装，可以自己定义，如果传入null，那么就使用系统默认的HttpStack</div><div class="line"> * <span class="doctag">@return</span> A 返回 instance.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">return</span> newRequestQueue(context, stack, -<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法也很简单，直接调用了含三个参数的构造方法，那么我们接着看看含三个参数的构造方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> context A 用于创建缓存文件夹</div><div class="line">     * <span class="doctag">@param</span> stack HttpStack处理http网络请求包装，内部就是我		*们使用过的HttpURLConnection或者HttpClient，进行包装处</div><div class="line">     *理，可以自己定义，也可以传入null，那么就使用系统默认的		 *HttpStack</div><div class="line">     * <span class="doctag">@param</span> maxDiskCacheBytes 设置最大sd卡缓存,如果传入-1</div><div class="line">     *就使用默认缓存</div><div class="line">     * <span class="doctag">@return</span> A 返回 instance.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack, <span class="keyword">int</span> maxDiskCacheBytes)</span> </span>&#123;</div><div class="line">        <span class="comment">//创建指定缓存文件</span></div><div class="line">        File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * UA一般都用于统计与识别</div><div class="line">         * User-Agent是Http协议中的一部分，属于头域的组成部</div><div class="line">         *分，User Agent也简称UA。用较为普通的一点来说</div><div class="line">         * ，是一种向访问网站提供你所使用的浏览器类型、操作系统</div><div class="line">         *及版本、CPU 类型、浏览器渲染引擎、浏览器语言、浏览器插</div><div class="line">         *件等信息的标识。</div><div class="line">         * UA字符串在每次浏览器 HTTP 请求时发送到服务器</div><div class="line">         */</div><div class="line">        String userAgent = <span class="string">"volley/0"</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//获取包名</span></div><div class="line">            String packageName = context.getPackageName();</div><div class="line">            <span class="comment">//获取包信息</span></div><div class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</div><div class="line">            <span class="comment">//获取userAgent</span></div><div class="line">            userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</div><div class="line">        &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//如果传入stack参数为null，那么创建默认的stack</span></div><div class="line">        <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//如果版本号大于9采用基于 HttpURLConnection 的 //HurlStack</span></div><div class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</div><div class="line">                stack = <span class="keyword">new</span> HurlStack();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//版本号小于9采用基于 HttpClient 的 //HttpClientStack</span></div><div class="line">            stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="comment">//new一个网络请求包装对象，并传入stack</span></div><div class="line">        Network network = <span class="keyword">new</span> BasicNetwork(stack);</div><div class="line">        RequestQueue queue;</div><div class="line">        <span class="keyword">if</span> (maxDiskCacheBytes &lt;= -<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//没有设置最大缓存maxDiskCacheBytes，创建默认大小缓存</span></div><div class="line">           queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">//设置最大缓存大小为maxDiskCacheBytes</span></div><div class="line">           queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir, maxDiskCacheBytes), network);</div><div class="line">        &#125;</div><div class="line"><span class="comment">//启动列队</span></div><div class="line">        queue.start();</div><div class="line"><span class="comment">//返回列队instance</span></div><div class="line">        <span class="keyword">return</span> queue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法代码稍微多一点，代码已经注释，这个构造方法主要是new 了一个 负责处理网络请求部分的stack对象，然后 用BasicNetwork将stack进行包装处理，又new了一个负责缓存部分的DiskBasedCache对象，并将这两个参数传入了列队queue中，并启动了列队；这里说明一下，在创建HttpStack对象的时候是比较了一下版本号，如果Build.VERSION.SDK_INT &gt;= 9， stack = new HurlStack();这里是因为在Android 2.2版本之前，HttpURLConnection一直存在着一些令人厌烦的bug，在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量。到这里我们就完成使用volley的第一步分析，即获取RequestQueue对象，那么接下来我们分析下RequestQueue构造方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 创建请求列队，传入sd卡缓存包装类，和网络请求包装类</div><div class="line"> * 会调用含三个参数的构造方法，并传入参数默认参数DEFAULT_NETWORK_THREAD_POOL_SIZE为4，即默认</div><div class="line"> *线程数为4</div><div class="line"> * <span class="doctag">@param</span> cache sd卡缓存类</div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面分析含三个参数的构造方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 调用含四个参数的构造方法并传递默认 new ExecutorDelivery(new Handler(Looper.getMainLooper()))参数</div><div class="line"> * <span class="doctag">@param</span> cache sd卡缓存类</div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> * <span class="doctag">@param</span> threadPoolSize 网络请求线程的数量，这里threadPoolSize为DEFAULT_NETWORK_THREAD_POOL_SIZE</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(cache, network, threadPoolSize,</div><div class="line">            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>含四个参数的构造方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> cache sd卡缓存类 </div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> * <span class="doctag">@param</span> threadPoolSize 网络请求线程的数量</div><div class="line"> * <span class="doctag">@param</span> delivery用来回调网络请求结果的事件分发类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,</span></span></div><div class="line">        ResponseDelivery delivery) &#123;</div><div class="line">    mCache = cache;</div><div class="line">    mNetwork = network;</div><div class="line">    <span class="comment">//创建数量为DEFAULT_NETWORK_THREAD_POOL_SIZE 即数量为4的NetworkDispatcher数组</span></div><div class="line">    mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</div><div class="line">    <span class="comment">//mDelivery为含有三个参数构造函数调用传入的new ExecutorDelivery(new </span></div><div class="line">    <span class="comment">//Handler(Looper.getMainLooper()))对象</span></div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里我们来我们发现从调用含有两个参数的RequestQueue构造方法是逐渐调用三个、四个参数构造方法，那么最终实现了：mCachesd卡缓存类的实例化，network网络请求包装类 的实例化，创建了一个数量为4的NetworkDispatcher数组，mDelivery=new ExecutorDelivery(new Handler(Looper.getMainLooper())网络请求结果回调类的实例化。那么这里我们看一下回调网络请求结果类ExecutorDelivery构造方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> 创建一个回调网络请求结果的对象</div><div class="line"> * <span class="doctag">@param</span> handler 利用handler将runnable发送出去</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">//创建一个excuter包含了一个handler，然后利用传递进来的handler来将runnable发送出去</span></div><div class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">            handler.post(command);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的handler为new Handler(Looper.getMainLooper())，即handler是创建在主线程中，所以当调用 handler.post(command)的时候，是将网络请求结果发送到主线程主去处理，这样就完成了异步任务，将子线程中网络请求的结果发送到主线程中去处理。以上就完成了构造RequestQueue对象过程中的代码分析。</p>
<p>下面还有一个疑问要分析就是我们在调用volley的时候执行的RequestQueue.add()方法，分析一下是如何将请求添加到缓存列队和网络请求列队，以及如何进行管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 该方法用于向列队中添加请求request</div><div class="line"> * 其中包含了几种列队，起到不同的作用</div><div class="line"> * mCurrentRequests列队，用于存储目前正在进行但是尚未完成的请求</div><div class="line"> * mNetworkQueue网络请求列队，用于存储走网络的请求</div><div class="line"> * mWaitingRequests 如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将当前请求和处理请求的queue进行关联，这样当该请求结束的时候就会通知负责处理该请求的queue</span></div><div class="line">    request.setRequestQueue(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">      <span class="comment">//将请求添加到当前请求列队中</span></div><div class="line">        mCurrentRequests.add(request);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//添加序列号</span></div><div class="line">    request.setSequence(getSequenceNumber());</div><div class="line">    <span class="comment">//添加标记</span></div><div class="line">    request.addMarker(<span class="string">"add-to-queue"</span>);</div><div class="line">    <span class="comment">//如果请求不能缓存，直接添加到网络请求列队，结束方法</span></div><div class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;</div><div class="line">        mNetworkQueue.add(request);</div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//如果方法走到这一步说明，我们使用了缓存功能</span></div><div class="line">    <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">      <span class="comment">//取出请求的缓存键</span></div><div class="line">        String cacheKey = request.getCacheKey();</div><div class="line">      </div><div class="line">        <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class="line">            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class="line">            <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</div><div class="line">                stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果mWaitingRequests已经包含该请求，那么将该请求添加到mWaitingRequests中</span></div><div class="line">            stagedRequests.add(request);</div><div class="line">            mWaitingRequests.put(cacheKey, stagedRequests);</div><div class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//如果该请求不在正在执行等待的类列队mWaitingRequests中，直接添加到mCacheQueue中</span></div><div class="line">            mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</div><div class="line">            mCacheQueue.add(request);</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//返回当前请求</span></div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们来捋一捋request是如何被添加到请求列队中的步骤如下：</p>
<p>1、当add一个请求request时候，首先该请求会被添加当当前请求列队mCurrentRequests中。</p>
<p>2、如果该请求不使用缓存那么直接被添加到网络请求列队mNetworkQueue结束方法。</p>
<p>3、如果该请求使用了缓存，那么先判断mWaitingRequests列队中是否有该请求，如果有那么添加到mWaitingRequests中，如果没有直接添加到缓存请求列队mCacheQueue中。</p>
<p>到这里我们理解了一个请求是如何被添加到列队中，但是同时会产生一个疑问就是mCurrentRequests和mWaitingRequests这两个列队的作用是什么，以及如何调用的，我们初略猜想一下，这两个列队中维护的请求应该在一个请求结束的时候，将该请求移除，那么应该是RequestQueue的finish方法中进行调用，那么下面我们来看一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 该方法会在Request的方法中进行调用finish(String)，表明当前请求已经结束</div><div class="line"> * 需要从mCurrentRequests和mWaitingRequests中移除保存的请求Request</div><div class="line"> */</div><div class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">      <span class="comment">//从当前请求列队mCurrentRequests中移除请求request</span></div><div class="line">        mCurrentRequests.remove(request);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (mFinishedListeners) &#123;</div><div class="line">      <span class="keyword">for</span> (RequestFinishedListener&lt;T&gt; listener : mFinishedListeners) &#123;</div><div class="line">        listener.onRequestFinished(request);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (request.shouldCache()) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">            String cacheKey = request.getCacheKey();</div><div class="line">            <span class="comment">//如果请求可以使用缓存，将mWaitingRequests中存储的waitingRequests移除</span></div><div class="line">            Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class="line">         </div><div class="line">            <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                    VolleyLog.v(<span class="string">"Releasing %d waiting requests for cacheKey=%s."</span>,</div><div class="line">                            waitingRequests.size(), cacheKey);</div><div class="line">                &#125;</div><div class="line">                 <span class="comment">//如果移除当前结束的请求后，如果移除的waitingRequests！=null，</span></div><div class="line">            <span class="comment">// 那么将其添加到缓存列队mCacheQueue</span></div><div class="line">                mCacheQueue.addAll(waitingRequests);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码只需要看注释部分即可，并不复杂，那么RequestQueue的finish应该是什么时候调用呢，我们猜想应该是在一个request方法请求结束的时候，我们来看一下在Request类的finish方法中代码是否如此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">final</span> String tag)</span> </span>&#123;</div><div class="line">  <span class="comment">//调用处</span></div><div class="line">    <span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) &#123;</div><div class="line">        mRequestQueue.finish(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (MarkerLog.ENABLED) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> threadId = Thread.currentThread().getId();</div><div class="line">        <span class="keyword">if</span> (Looper.myLooper() != Looper.getMainLooper()) &#123;</div><div class="line">            Handler mainThread = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">            mainThread.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    mEventLog.add(tag, threadId);</div><div class="line">                    mEventLog.finish(<span class="keyword">this</span>.toString());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mEventLog.add(tag, threadId);</div><div class="line">        mEventLog.finish(<span class="keyword">this</span>.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码我们在第三行看到了mRequestQueue.finish(this);那么request方法结束请求有三种可能分别是：手动调用request.cancel方法取消请求、request请求成功回调成功结果、request请求失败回调失败结果，这三种请求都是表面当前request请求结束，那么我们分别看一下这三处的代码是否进行了调用，我们以网络请求线程NetworkDispatcher为例（缓存线程调度原理相同）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行网络请求线程，耗时任务的执行</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      ........</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                    <span class="comment">//如果请求取消，结束请求</span></div><div class="line">                    request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                  <span class="comment">//继续从列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">          ........</div><div class="line">               </div><div class="line">                <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                   <span class="comment">//如果networkResponse状态为304，并且已经返回了响应结果，那么结束请求不进行第二次返回</span></div><div class="line">                    request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                  <span class="comment">//继续请求列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">               ..........</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后看一下请求结果回调类ExecutorDelivery的run，执行了该方法表明将request请求结果进行了回调，所以request.finish()方法在此处也有调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//调用处</span></div><div class="line">        <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</div><div class="line">            mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">       ........</div><div class="line">        <span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">          <span class="comment">//如果这个请求需要刷新那么这个请求又被添加到了列队中，所以还在列队中，不要finish</span></div><div class="line">            mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">//否则调用finish</span></div><div class="line">            mRequest.finish(<span class="string">"done"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">.......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样mCurrentRequests和mWaitingRequests这两个列队的管理基本就捋清楚了。</p>
<p>下面我们就要思考获取到requestQueue对象，调用requestQueue.add（request）方法后，是如何启动网络请求的，那么我们看到在RequestQueue构造方法中有一行代码    queue.start()方法，那么接下来我们来分析一下这个方法具体内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 开始执行在列队中的各个线程分发调度</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//停止所有当前正在执行分发调度事件</span></div><div class="line">    stop();  </div><div class="line">    <span class="comment">//创建一个执行缓存分发调度线程，并将mCacheQueue缓存列队, mNetworkQueue网络请求列队, mCache缓存对象, mDelivery事件分发对象传递进去</span></div><div class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class="line">    <span class="comment">//启动缓存事件分发</span></div><div class="line">    mCacheDispatcher.start();</div><div class="line">    <span class="comment">//当i &lt; mDispatchers.length时循环创建networkDispatcher对象</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">       <span class="comment">//创建一个网络请求线程调度networkDispatcher线程，并将 mCacheQueue缓存列队, mNetworkQueue网络</span></div><div class="line">       <span class="comment">//请求列队, mCache负责处理缓存对象, mDelivery事件分发对象传递进去</span></div><div class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class="line">                mCache, mDelivery);</div><div class="line">        mDispatchers[i] = networkDispatcher;</div><div class="line">        <span class="comment">//启动网络缓存线程</span></div><div class="line">        networkDispatcher.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码主要实现功能是创建一个缓存事件调度线程并启动，然后循环创建了n个网络请求线程调度networkDispatcher对象，这里n= mDispatchers.length。mDispatchers数组的长度即是构造RequestQueue过程中传入的参数DEFAULT_NETWORK_THREAD_POOL_SIZE 即数量为4，也就是说创建了4个负责网络请求调度的线程。下面我们一起分析一下CacheDispatcher缓存调度线程代码，CacheDispatcher 继承自Thread，是一个线程，先看一下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> cacheQueue 缓存列队</div><div class="line"> * <span class="doctag">@param</span> networkQueue 网络请求列队</div><div class="line"> * <span class="doctag">@param</span> cache 缓存类</div><div class="line"> * <span class="doctag">@param</span> delivery 请求结果回调分发类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheDispatcher</span><span class="params">(</span></span></div><div class="line">        BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue, BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,</div><div class="line">        Cache cache, ResponseDelivery delivery) &#123;</div><div class="line">    mCacheQueue = cacheQueue;</div><div class="line">    mNetworkQueue = networkQueue;</div><div class="line">    mCache = cache;</div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后主要看一下run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//复写Run方法，这里执行耗时操作，在子线程中执行</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</div><div class="line">    <span class="comment">//设置线程优先级</span></div><div class="line"> Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">    <span class="comment">//初始化缓存类</span></div><div class="line">    mCache.initialize();</div><div class="line">  <span class="comment">//循环从列队中读取请求并执行</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//从列队的首部取出一个request</span></div><div class="line">            <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</div><div class="line">            <span class="comment">//添加一个标记</span></div><div class="line">            request.addMarker(<span class="string">"cache-queue-take"</span>);</div><div class="line">            <span class="comment">//如果取出的请求取消，那么结束请求</span></div><div class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                request.finish(<span class="string">"cache-discard-canceled"</span>);</div><div class="line">              <span class="comment">//继续循环从缓存列队中拿请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//从缓存中读取缓存数据</span></div><div class="line">            Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//如果请求结果为null，那么添加标记</span></div><div class="line">                request.addMarker(<span class="string">"cache-miss"</span>);</div><div class="line">                 <span class="comment">//然后将请求发送到网络请求列队</span></div><div class="line">                mNetworkQueue.put(request);</div><div class="line">               <span class="comment">//然后继续循环去缓存列队中拿取请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (entry.isExpired()) &#123;</div><div class="line">                <span class="comment">//如果缓存过期，添加标记</span></div><div class="line">                request.addMarker(<span class="string">"cache-hit-expired"</span>);</div><div class="line">                request.setCacheEntry(entry);</div><div class="line">              <span class="comment">//将请求发送到网络请求列队</span></div><div class="line">                mNetworkQueue.put(request);</div><div class="line">              <span class="comment">//然后继续去缓存列队中拿取请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//走到这一步，说明已经拿到缓存，添加标记命中</span></div><div class="line">            request.addMarker(<span class="string">"cache-hit"</span>);</div><div class="line">            <span class="comment">//解析网络缓存数据NetworkResponse得到Response&lt;T&gt; 结果</span></div><div class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">                    <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line">            <span class="comment">//标记解析完成</span></div><div class="line">            request.addMarker(<span class="string">"cache-hit-parsed"</span>);</div><div class="line">            <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</div><div class="line">                <span class="comment">//如果不需要刷新，那么直接将解析结果回调</span></div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//如果需要刷新，那么添加标记</span></div><div class="line">                request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</div><div class="line">                request.setCacheEntry(entry);</div><div class="line">                response.intermediate = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">//返回数据，并将将请求添加到网络请求列队，但是是发送出去到主线程中执行</span></div><div class="line">                mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            mNetworkQueue.put(request);</div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="comment">//调用mQuit方法结束循环</span></div><div class="line">            <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">          <span class="comment">//否则继续缓存列队中取出request</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个run方法主要作用是：启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code> 去执行，将请求结果发送到主线程中。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入<code>NetworkDispatcher</code>去调度处理。这里有一行代码mDelivery.postResponse(request, response);是将请求结果发送到主线程中，前面我们提到是利用handler.post()方法执行，那么我们看看ExecutorDelivery 类的postResponse的具体细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</div><div class="line">    <span class="comment">//直接调用三个参数的post方法</span></div><div class="line">    postResponse(request, response, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就一行代码，调用含三个参数的构造方法，那么我们继续追溯：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</div><div class="line">    request.markDelivered();</div><div class="line">    request.addMarker(<span class="string">"post-response"</span>);</div><div class="line">    <span class="comment">//通过ResponseDeliveryRunnable将request, response, runnable包装后发送出去到主线程handle中</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的mResponsePoster就是在构造ExecutorDelivery 时候生成的Executor对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">// Make an Executor that just wraps the handler.</span></div><div class="line">    <span class="comment">//创建一个excuter包含了一个handler，handler来将runnable发送出去</span></div><div class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">          <span class="comment">//将Runnable对象发送到主线程</span></div><div class="line">            handler.post(command);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而ResponseDeliveryRunnable继承Runnable，所以当调用mResponsePoster.execut（new ResponseDeliveryRunnable(request, response, runnable)）方法时候就会将ResponseDeliveryRunnable对象发送到主线程中，那么我们看一下ResponseDeliveryRunnable类的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在主线程中运行</span></div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</div><div class="line">              <span class="comment">//如果请求取消，那么结束方法</span></div><div class="line">                mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</div><div class="line">              <span class="comment">//如果请求成功调用mRequest.deliverResponse，这个方法在我们自定义request时候需要重写的，每一条网络请求的响应都是回调到这个方法中，主线程中运行</span></div><div class="line">            mRequest.deliverResponse(mResponse.result);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="comment">//请求失败回调</span></div><div class="line">                mRequest.deliverError(mResponse.error);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">                mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mRequest.finish(<span class="string">"done"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="comment">//如果传入Runnable不为空，那么执行Runnable</span></div><div class="line">                mRunnable.run();</div><div class="line">            &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码我们看自定义Request时候需要复写的方法   mRequest.deliverResponse(mResponse.result);和mRequest.deliverError(mResponse.error)。到这里请求回调的疑问我们已经解决。</p>
<p>下面我们先分析一下NetworkDispatcher网络缓存线程，NetworkDispatcher 继承自Thread，也就是说NetworkDispatcher 是一个线程先看一下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> queue 网络请求列队</div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> * <span class="doctag">@param</span> cache 缓存类</div><div class="line"> * <span class="doctag">@param</span> delivery 请求结果回调分发类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkDispatcher</span><span class="params">(BlockingQueue&lt;Request&lt;?&gt;&gt; queue,</span></span></div><div class="line">        Network network, Cache cache,</div><div class="line">        ResponseDelivery delivery) &#123;</div><div class="line">    mQueue = queue;</div><div class="line">    mNetwork = network;</div><div class="line">    mCache = cache;</div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后看一下复写的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行网络请求线程，耗时任务的执行,在子线程中执行</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">//设置线程优先级</span></div><div class="line"> Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        Request&lt;?&gt; request;</div><div class="line">      <span class="comment">//从网络请求列队中循环读取request并执行请求</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">long</span> startTimeMs = SystemClock.elapsedRealtime();</div><div class="line">            request = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//从网络请求列队中拿到一个请求</span></div><div class="line">                request = mQueue.take();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                <span class="comment">//如果调用了mQuit就直接结束该方法</span></div><div class="line">                <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">              <span class="comment">//否则继续从列队中拿请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//添加拿到标记</span></div><div class="line">                request.addMarker(<span class="string">"network-queue-take"</span>);</div><div class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                    <span class="comment">//如果请求取消，结束请求</span></div><div class="line">                    request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                  <span class="comment">//继续从列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//设置线程状态</span></div><div class="line">                addTrafficStatsTag(request);</div><div class="line">                <span class="comment">//执行网络请求，得到请求结果NetworkResponse</span></div><div class="line">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">                <span class="comment">//添加执行请求完成状态</span></div><div class="line">                request.addMarker(<span class="string">"network-http-complete"</span>);</div><div class="line">               </div><div class="line">                <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                   <span class="comment">//如果networkResponse状态为304，并且已经传递了响应结果，那么结束请求不进行第二次返回</span></div><div class="line">                    request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                  <span class="comment">//继续请求列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//将networkResponse解析成  Response&lt;?&gt; response，这个解析方法我们可以自己在</span></div><div class="line">              <span class="comment">//Request类进行复写，自己定义解析方法</span></div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">              <span class="comment">//添加解析完成标记</span></div><div class="line">                request.addMarker(<span class="string">"network-parse-complete"</span>);</div><div class="line">                <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//如果请求使用了缓存，并且响应结果不为空，那么将请求结果存入缓存</span></div><div class="line">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">                  <span class="comment">//添加完成缓存标记</span></div><div class="line">                    request.addMarker(<span class="string">"network-cache-written"</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//添加请求结果回调标记</span></div><div class="line">                request.markDelivered();</div><div class="line">              <span class="comment">//回调响应结果，即将请求响应结果，发送到主线程</span></div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</div><div class="line">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">              <span class="comment">//请求网络失败回调</span></div><div class="line">                parseAndDeliverNetworkError(request, volleyError);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</div><div class="line">                VolleyError volleyError = <span class="keyword">new</span> VolleyError(e);</div><div class="line">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">              <span class="comment">//请求失败回调</span></div><div class="line">                mDelivery.postError(request, volleyError);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>run方法启动后会不断从网络请求队列中取请求处理，队列为空则等待，拿到请求后，则执行网络请求，请求处理结束则将结果传递给 ResponseDelivery 去执行后续处理，并判断结果是否要进行缓存。</p>
<p>下面我们来捋一捋volley如如何进行网络请求、缓存请求和请求结果的回调，步骤如下：</p>
<p>1、创建了一个缓存事件调度线程CacheDispatcher，负责从缓存列队中读取请求，然后从缓存中读取数据，进行解析返回，从缓存中读取数据为null，或者数据过期、需要刷新，那么将请求添加到网络请求列队。</p>
<p>2、创建了四个网络请求事件调度线程NetworkDispatcher，负责处理网络请求，并解析请求结果进行返回，并将结果缓存到本地。</p>
<p>3、创建了一个请求结果回调类ResponseDelivery，负责将请求结果返回到主线程，原理是利用handler将结果post到主线程。</p>
<p>到这里volley框架的主要流程我们基本梳理通顺了，下面我们在看一下细节方面，网络请求是如何执行的，上面代码中执行网络请求代码mNetwork.performRequest(request)，其中mNetwork就是我们在构造RequestQueue时候传入的BasicNetwork对象，那么看一下具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 通过HttpStack，即执行http网络请求请求</div><div class="line"> * 并将HttpStack请求结果包装成NetworkResponse返回NetworkRespons</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</div><div class="line">    <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="comment">//http请求头文件包装信息</span></div><div class="line">        HttpResponse httpResponse = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//请求返回内容body</span></div><div class="line">        <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//生成一个map对象</span></div><div class="line">        Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">            <span class="comment">//添加请求头文件信息，entry即是定义request类时候复写setCacheEntry传入</span></div><div class="line">            addCacheHeaders(headers, request.getCacheEntry());</div><div class="line">            <span class="comment">//执行mHttpStack操作返回请求结果httpResponse</span></div><div class="line">            httpResponse = mHttpStack.performRequest(request, headers);</div><div class="line">            <span class="comment">//获取到请求状态</span></div><div class="line">            StatusLine statusLine = httpResponse.getStatusLine();</div><div class="line">            <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</div><div class="line">            <span class="comment">//取出httpResponse中header添加到responseHeaders</span></div><div class="line">            responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class="line">            <span class="comment">//如果是304状态没有更新状态</span></div><div class="line">            <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class="line">                <span class="comment">//缓存中取出entry对象</span></div><div class="line">                Entry entry = request.getCacheEntry();</div><div class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//如果entry为null，返回一个entry为null的NetworkResponse</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, <span class="keyword">null</span>,</div><div class="line">                            responseHeaders, <span class="keyword">true</span>,</div><div class="line">                            SystemClock.elapsedRealtime() - requestStart);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                entry.responseHeaders.putAll(responseHeaders);</div><div class="line">                <span class="comment">//如果entry不为null，返回一个entry的NetworkResponse</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class="line">                        entry.responseHeaders, <span class="keyword">true</span>,</div><div class="line">                        SystemClock.elapsedRealtime() - requestStart);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//301/302 Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</span></div><div class="line">            <span class="keyword">if</span> (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class="line">               String newUrl = responseHeaders.get(<span class="string">"Location"</span>);</div><div class="line">               request.setRedirectUrl(newUrl);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//获取entry不为null,将entry转换为byte类型</span></div><div class="line">              responseContents = entityToBytes(httpResponse.getEntity());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//否则new 一个responseContents对象</span></div><div class="line">              responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class="line">            <span class="comment">//打印请求生命周期，请求，响应内容，和状态</span></div><div class="line">            logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class="line">            <span class="comment">//根据状态码抛出异常</span></div><div class="line">            <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//返回包含响应entry和header的NetworkResponse</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>,</div><div class="line">                    SystemClock.elapsedRealtime() - requestStart);</div><div class="line">            <span class="comment">//抛出各种异常</span></div><div class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</div><div class="line">            attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</div><div class="line">        ...........</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段方法中大多都是一些网络请求细节方面的东西，部分已经添加注释，我们抓重点看即可，其中httpResponse = mHttpStack.performRequest(request, headers);这一行代码中的mHttpStack就是我们在构造RequestQueue的时候传入的HttpStack对象，负责处理http网络请求的，然后就是有几处代码是return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,        responseHeaders, true,        SystemClock.elapsedRealtime() - requestStart))，其中区别就是参数不同，所以这个方法其实只要实现功能就是调用<code>HttpStack</code>处理网络请求，并将结果进行包装转换为可被<code>ResponseDelivery</code>处理的<code>NetworkResponse</code>对象返回。</p>
<p>下面我们看一下mHttpStack.performRequest(request, headers)这个方法是如何处理网络请求的（以HurlStack类为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 封装执行HttpURLConnection网络请求，返回HttpResponse对象</div><div class="line"> * <span class="doctag">@param</span> request the request to perform</div><div class="line"> * <span class="doctag">@param</span> additionalHeaders 附加的请求头文件信息</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException, AuthFailureError &#123;</div><div class="line">    <span class="comment">//获取网络请求url</span></div><div class="line">    String url = request.getUrl();</div><div class="line">    <span class="comment">//new 一个map对象</span></div><div class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">    <span class="comment">//将请求header信息添加进去</span></div><div class="line">    map.putAll(request.getHeaders());</div><div class="line">    map.putAll(additionalHeaders);</div><div class="line">    <span class="keyword">if</span> (mUrlRewriter != <span class="keyword">null</span>) &#123;</div><div class="line">        String rewritten = mUrlRewriter.rewriteUrl(url);</div><div class="line">        <span class="keyword">if</span> (rewritten == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"URL blocked by rewriter: "</span> + url);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取到url</span></div><div class="line">        url = rewritten;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//解析url</span></div><div class="line">    URL parsedUrl = <span class="keyword">new</span> URL(url);</div><div class="line">    <span class="comment">//创建HttpURLConnection网络请求连接</span></div><div class="line">    HttpURLConnection connection = openConnection(parsedUrl, request);</div><div class="line">    <span class="keyword">for</span> (String headerName : map.keySet()) &#123;</div><div class="line">        <span class="comment">//添加请求头信息</span></div><div class="line">        connection.addRequestProperty(headerName, map.get(headerName));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置连接参数，主要设置各种请求类型</span></div><div class="line">    setConnectionParametersForRequest(connection, request);</div><div class="line">  ........</div><div class="line">    <span class="comment">//解析请求body请求体</span></div><div class="line">    response.setEntity(entityFromConnection(connection));</div><div class="line">    <span class="keyword">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</div><div class="line">        <span class="keyword">if</span> (header.getKey() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//解析请求header添加请求头</span></div><div class="line">            Header h = <span class="keyword">new</span> BasicHeader(header.getKey(), header.getValue().get(<span class="number">0</span>));</div><div class="line">            response.addHeader(h);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//请求结果返回</span></div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码中我们终于看见了我们熟悉的HttpURLConnection对象，并进行了一系列的参数设置，解析返回数据返回HttpResponse对象。到这里负责执行网络请求部分的内容我们也梳理结束。</p>
<p>至此，关于volley的学习笔记到此结束，如有理解错误地方，还请指教！！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android源码学习/">Android源码学习</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Yongyu
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by yongyu
			<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
 </script>
 </br>
 </br>本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>
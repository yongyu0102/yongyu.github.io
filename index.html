<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>一个写代码的地方</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这里记录你的故事！">
<meta property="og:type" content="website">
<meta property="og:title" content="一个写代码的地方">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="一个写代码的地方">
<meta property="og:description" content="这里记录你的故事！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一个写代码的地方">
<meta name="twitter:description" content="这里记录你的故事！">
  
    <link rel="alternate" href="/atom.xml" title="一个写代码的地方" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">一个写代码的地方</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">记录你的学习</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-rxjava_learning_note" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/15/rxjava_learning_note/" class="article-date">
  <time datetime="2016-11-14T16:00:00.000Z" itemprop="datePublished">2016-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-RxJava/">Android RxJava</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/15/rxjava_learning_note/">RxJava 学习笔记（部分示例代码及源码）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>-文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</p>
<ul>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://github.com/yongyu0102" target="_blank" rel="external">yongyu0102</a></li>
<li>审阅者：<a href="https://github.com/hymanme" target="_blank" rel="external">hymane</a></li>
</ul>
<p>说在前面，本文较长，从观察者模式到 RxJava 原理，以及 RxJava 的一些常用操作符的使用，并且对主要涉及到的源码进行了详细分析，讲解内部实现原理，都是笔者自己的学习笔记，所以你可以选择感兴趣的地方去阅读，如果你有时间也可以慢慢品尝，希望对你有所帮助！</p>
<h1 id="一、初识-RxJava"><a href="#一、初识-RxJava" class="headerlink" title="一、初识 RxJava"></a>一、初识 RxJava</h1><p><strong>RxJava 是什么</strong> ：它就是一个实现异步操作的库，使你的程序逻辑简介清晰实现链式调用，避免代码的迷之嵌套以及各种接口回调。</p>
<p><strong>扩展的观察者模式</strong>：RxJava 的异步实现，是通过一种扩展的观察者模式来实现的，观察者模式面向的需求是：A 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。Android 开发中一个比较典型的例子是点击监听器 <code>OnClickListener</code> 。对设置<code>OnClickListener</code> 来说， View 是被观察者， <code>OnClickListener</code> 是观察者，二者通过 <code>setOnClickListener()</code>方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的<code>OnClickListener</code> 。</p>
<p><strong>RxJava 中重要概念</strong><br><strong>Observable</strong>：被观察者，这个类提供一系列方法用于被 Observers 去订阅，即在 RxJava 中 一个 Observer  观察者去 subscribe 订阅一个 Observable 被观察者，Observable 决定事件触发的时候将有怎样的行为，即事件的产生者。</p>
<p><img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase6/observable_observer.png?raw=true" alt="observable_observer"></p>
<p><strong>Observer</strong>： 观察者身份，用于观察 Observable，接受被观察者发送的事件，下面这段原文说的很形象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">After an Observer calls an  Observable&apos;s  subscribe method, the</div><div class="line">Observable calls the Observer&apos;s onNext method to provide notifications. A well-behaved</div><div class="line"> Observable will call an Observer&apos;s onCompleted method exactly once or the Observer&apos;s</div><div class="line">onError method exactly once.</div></pre></td></tr></table></figure>
<p>大概意思是：在一个观察者 Observer 调用 （calls ）一个被观察者 Observable  的 subscribe 方法之后，这个被观察者就会调用（calls ）观察者的 <code>onNext()</code> 方法来发送消息。</p>
<p> <strong>subscribe</strong>：动词订阅，执行订阅，用于 Observer 去订阅 Observable，使二者之间建立联系。</p>
<p><strong>最后三者之间的关系</strong>：Observable 和 Observer 通过 <code>subscribe()</code> 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知  Observer。</p>
<p><strong>订阅之后结果</strong>：在 Observer  观察者 subscribe 订阅了被观察者 Observaber 之后会产生 onCompleted（表示事件完成）、onNext（接受事件产生的结果）、onError（表示事件产生错误）。</p>
<p><strong>onCompleted()</strong>: 表示事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列，RxJava 规定，当不会再有新的 <code>onNext()</code> 发出时，需要触发 <code>onCompleted()</code> 方法作为结束标志。</p>
<p><strong>onNext()：</strong> 接受发送的事件，即接受数据。</p>
<p><strong>onError()</strong>: 事件队列异常。在事件处理过程中出异常时，<code>onError()</code> 会被触发，同时队列自动终止，不允许再有事件发出。在一个正确运行的事件序列中，<code>onCompleted()</code> 和 <code>onError()</code> 有且只有一个，并且是事件序列中的最后一个。需要注意的是 <code>onCompleted()</code> 和 <code>onError()</code> 二者是互斥的，即在队列中调用了其中一个，就不再调用另一个。</p>
<p>RxJava 的观察者模式大致如下图：</p>
<p><img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase6/observer_detail.png?raw=true" alt="observer_detail"></p>
<p><strong>Subscriber</strong>：Subscriber 对 Observer 接口进行了一些扩展，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Subscription</span></span></div></pre></td></tr></table></figure>
<p>也是观察者（订阅者），他的基本使用方式与 Observer 是完全一样的，在订阅者即 Subscriber 调用了被观察者 Observabler 的方法 subscribe 之后，被观察者 Observable 将会调用 Subscriber’s  的方法 onNext 发送事件，而且在事件发送完毕会调用 Subscriber 的 onCompleted 方法或者在发送事件过程中出现错误就会调用 Subscriber  的 onError 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> After a Subscriber calls an  Observable&apos;s  subscribe method, the</div><div class="line">Observable calls the Subscriber&apos;s onNext method to emit items. A well-behaved</div><div class="line">Observable will call a Subscriber&apos;s onCompleted method exactly once or the Subscriber&apos;s</div><div class="line">onError  method exactly once.</div></pre></td></tr></table></figure>
<p>而且这是一个抽象类，使用的时候必须实现其抽象方法，不可以直接 new ，可以使用匿名内部类的方式进行 new ，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line"></div><div class="line">        Log.d(tag, <span class="string">"Item: "</span> + s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.d(tag, <span class="string">"Completed!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        Log.d(tag, <span class="string">"Error!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="二、Observable-创建的几种方式及源码"><a href="#二、Observable-创建的几种方式及源码" class="headerlink" title="二、Observable 创建的几种方式及源码"></a>二、Observable 创建的几种方式及源码</h1><h2 id="2-1-Observable-create-new-Observable-OnSubscribe"><a href="#2-1-Observable-create-new-Observable-OnSubscribe" class="headerlink" title="2.1 Observable.create(new Observable.OnSubscribe()"></a>2.1 Observable.create(new Observable.OnSubscribe<t>()</t></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 传入一个 OnSubscribe 对象，用于产生被被观察者行为</div><div class="line"> */</div><div class="line">Observable&lt;String&gt; observable=Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="comment">//该方法在形成订阅关系的时候就会调用，在这里被观察者执行要执行的逻辑，发送对象</span></div><div class="line">    <span class="comment">//观察者就会接收到</span></div><div class="line">  <span class="comment">//而这个 call 方法持有观察者 Observer ，即 call(Subscriber&lt;? super String&gt; subscriber</span></div><div class="line">  <span class="comment">//中的 subscriber 就是传递就去的观察者 Observer，这里怎么把观察者传递进来的后面进行分析</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="comment">//被观察者产生行为执行逻辑</span></div><div class="line">        subscriber.onNext(<span class="string">"Hello"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"Tome"</span>);</div><div class="line">        <span class="comment">//注意这里强制抛出一个异常错误，那么 Observer 会接受到这个错误</span></div><div class="line">        <span class="comment">//然后 OnComplete()方法就不会调用， Observer 就接受不到</span></div><div class="line">        subscriber.onError(<span class="keyword">new</span> AndroidException(<span class="string">"onError"</span>));</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>看一下 OnSubscribe 这个类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *是一个实现了 Action1 类的接口，当 Observable 的 subscribe 方法被调用的时候会被调用。</div><div class="line"> * Invoked when Observable.subscribe is called.</div><div class="line"> * <span class="doctag">@param</span> &lt;T&gt; the output value type</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action1</span>&lt;<span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="comment">// cover for generics insanity</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Action1 就是对有参数且没有返回值的一类方法的处理</div><div class="line"> * A one-argument action.</div><div class="line"> * <span class="doctag">@param</span> &lt;T&gt; the first argument type</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下 <code>Observable.create</code> 源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(hook.onCreate(f));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接调用 了Observable 构造方法，只是将 OnSubscribe 参数进行了一层的包装，下面看一下如何包装的，这里的 hook 对象为 RxJavaObservableExecutionHook  类，是 RxJavaPlugins 中的一个类，用于插入一些你所需要的代码，记录，测试等，在默认的情况下，没有做任何对代码逻辑功能有影响的事情，以下是官方文档给出的解释：</p>
<blockquote>
<p>This plugin allows you to register functions that RxJava will call upon certain regular RxJava activities, for instance for logging or metrics-collection purposes.</p>
</blockquote>
<p><code>hook.onCreate(f)</code> 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">OnSubscribe&lt;T&gt; <span class="title">onCreate</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大家看一下，这里直接返回了传入的参数，所以说这个类没做对业务逻辑有影响的事情，其他调用也类似，只是做了个包装，所以我们在分析源码思路的时候可以忽略其作用。那么接着看 Observable 构造函数干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Observable</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.onSubscribe = f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，直接保存全局持有创建的 onSubscribe 对象。这里被观察者创建源码就这么简单，分析完毕。下面看一下，我们实例化观察者 Observable 对象做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一看就这么简单，就是一个接口，里面是我们实例化时候需要重写的几个方法，大家都很熟悉。</p>
<p>下面看一下订阅 <code>Observable.subscribe(observer)</code> 方法干了什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (observer <span class="keyword">instanceof</span> Subscriber) &#123;</div><div class="line">      <span class="comment">//判断 observer 是 Subscriber 类型，直接将 observer 强转为 Subscriber 类型</span></div><div class="line">      <span class="comment">//然后调用 obsaverble 的 subscribe(Subscriber&lt;? super T&gt; subscriber) 方法</span></div><div class="line">        <span class="keyword">return</span> subscribe((Subscriber&lt;? <span class="keyword">super</span> T&gt;)observer);</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//如果不是 Subscriber 类型 将 observer 包装成 Subscriber 类型，具体代码如下</span></div><div class="line">    <span class="keyword">return</span> subscribe(<span class="keyword">new</span> ObserverSubscriber&lt;T&gt;(observer));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将 Observer 包装成 Subscriber代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObserverSubscriber</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observer = observer;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">        observer.onNext(t);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        observer.onError(e);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        observer.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里也很简单，没什么好说的，接着看 subscribe 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Observable.subscribe(subscriber, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法直接调用了两个参数的 subscribe 方法，而传递进去的参数一个是我们创建的观察者 subscriber (Observer) ，一个是被观察者自己本身 Observable 即参数 this ，接着看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class="line">........</div><div class="line">  <span class="comment">//以上为非 null 判断</span></div><div class="line">    </div><div class="line">  <span class="comment">// new Subscriber so onStart it</span></div><div class="line">  <span class="comment">//调用观察者的 onStart 方法 </span></div><div class="line">    subscriber.onStart();</div><div class="line">   </div><div class="line">    <span class="comment">// if not already wrapped</span></div><div class="line">    <span class="keyword">if</span> (!(subscriber <span class="keyword">instanceof</span> SafeSubscriber)) &#123;</div><div class="line">      <span class="comment">//对 subscriber 进行安全包装，是为了使 Subscriber </span></div><div class="line">      <span class="comment">//遵守 Observable 的某种规则而进行的一次封装，</span></div><div class="line">      <span class="comment">//保证 onComplete 和 onError 互斥，onNext 在 onComplete 执行后，不再发送数据，</span></div><div class="line">      <span class="comment">//对异常做了一些操作等等。</span></div><div class="line">      <span class="comment">// assign to `observer` so we return the protected version</span></div><div class="line">        subscriber = <span class="keyword">new</span> SafeSubscriber&lt;T&gt;(subscriber);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// The code below is exactly the same an unsafeSubscribe but not used because it would </span></div><div class="line">    <span class="comment">// add a significant depth to already huge call stacks.</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// allow the hook to intercept and/or decorate</span></div><div class="line">      <span class="comment">//真正实现观察者 Subscriber 和被观察者 Observable 两者关系的核心代码</span></div><div class="line">      <span class="comment">//  hook.onSubscribeStart(observable, observable.onSubscribe) 这段代码就只是返回了</span></div><div class="line">      <span class="comment">// onSubscribe 对象，而这个对象就是我们创建 Observable 时候创建的，</span></div><div class="line">      <span class="comment">//接着调用了 onSubscribe.call(subscriber),即调用 onSubscribe 的call 方法，</span></div><div class="line">      <span class="comment">//而传入的参数就是我们创建的观察者 这样实现了观察者的回调，完成了二者的订阅关系</span></div><div class="line">      <span class="comment">//这个 call 方法相当于点击事件的 click 方法</span></div><div class="line">      <span class="comment">//传入观察者（接口）对象，然后当实现订阅 Subscribe 的时候，观察者实现的接口就会接受数据，</span></div><div class="line">      <span class="comment">//相当于点击事件执行 setClickLisner 方法传入 listner 对象，</span></div><div class="line">      <span class="comment">//然后 listner 对象实现的接口就可以接受数据一样。</span></div><div class="line">        hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);</div><div class="line">      <span class="comment">//返回被观察者 subscriber 本身,因为 subscriber 也实现了Subscription 所以</span></div><div class="line">      <span class="comment">//返回该对象可以用于订阅取消的管理</span></div><div class="line">        <span class="keyword">return</span> hook.onSubscribeReturn(subscriber);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        <span class="comment">// special handling for certain Throwable/Error/Exception types</span></div><div class="line">        Exceptions.throwIfFatal(e);</div><div class="line">        <span class="comment">// in case the subscriber can't listen to exceptions anymore</span></div><div class="line">        <span class="keyword">if</span> (subscriber.isUnsubscribed()) &#123;</div><div class="line">            RxJavaPluginUtils.handleException(hook.onSubscribeError(e));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// if an unhandled error occurs executing the onSubscribe we will propagate it</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                subscriber.onError(hook.onSubscribeError(e));</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable e2) &#123;</div><div class="line">                Exceptions.throwIfFatal(e2);</div><div class="line">                hook.onSubscribeError(r);</div><div class="line">                <span class="comment">// TODO why aren't we throwing the hook's return value.</span></div><div class="line">                <span class="keyword">throw</span> r;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-2-Observable-just-……"><a href="#2-2-Observable-just-……" class="headerlink" title="2.2 Observable.just(……)"></a>2.2 Observable.just(……)</h2><p>用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * just 函数的用法</div><div class="line"> * 将传入的参数依次全部发送出来</div><div class="line"> * <span class="doctag">@param</span> t1 依次传入的参数，这些参数是不固定个数的可以是 n 个</div><div class="line"> * <span class="doctag">@param</span> t2</div><div class="line"> * <span class="doctag">@param</span> t3</div><div class="line"> * <span class="doctag">@param</span> &lt;T&gt;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span>  <span class="title">justTest</span><span class="params">(T t1,T t2,T t3 )</span></span>&#123;</div><div class="line">    Observable.just(t1,t2,t3)</div><div class="line">            <span class="comment">//形成订阅关系</span></div><div class="line">            .subscribe(<span class="keyword">new</span> Action1&lt;T&gt;() &#123;</div><div class="line">                <span class="comment">//接受发送结果</span></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                    Log.d(TAG,t.toString());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">just</span><span class="params">(T t1, T t2)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> from((T[])<span class="keyword">new</span> Object[] &#123; t1, t2 &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>源码可以看出， 在 <code>just()</code>方法内部直接将传入的不固定个数的参数直接转换为一个数组，然后传递给 <code>from()</code> 方法，那么我们看一下 <code>from()</code>  方法的用法：</p>
<h2 id="2-3-Observable-from-T-array"><a href="#2-3-Observable-from-T-array" class="headerlink" title="2.3 Observable.from(T[] array)"></a>2.3 Observable.from(T[] array)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 实现打印数组功能</div><div class="line"> * 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FromTest</span><span class="params">()</span></span>&#123;</div><div class="line">    String [] names=&#123;<span class="string">"Tome"</span>,<span class="string">"LiLei"</span>,<span class="string">"XiaoMing"</span>&#125;;</div><div class="line">    Observable.from(names)</div><div class="line">            <span class="comment">//形成订阅关系</span></div><div class="line">            <span class="comment">//并只接受发送类型为String 类型对象</span></div><div class="line">            .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">                <span class="comment">//接受发送的结果</span></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                    Log.d(TAG,s);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用法很简单，看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/**</span></div><div class="line">     * Converts an Array into an Observable that emits the items in the Array.</div><div class="line">     * <span class="doctag">@param</span> array the source Array</div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt; the type of items in the Array and the type of items to be</div><div class="line">     * emitted by the resulting Observable</div><div class="line">     * <span class="doctag">@return</span> an Observable that emits each item in the source Array</div><div class="line">     */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">from</span><span class="params">(T[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = array.length;</div><div class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">//数组为 0</span></div><div class="line">        <span class="keyword">return</span> empty();</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</div><div class="line">      <span class="comment">//数组个数为 1</span></div><div class="line">        <span class="keyword">return</span> just(array[<span class="number">0</span>]);</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//数组个数大于 1</span></div><div class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OnSubscribeFromArray&lt;T&gt;(array));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码可以看出，这个方法的作用就是将一个数组转变为一个能够发送数组元素的 Observable 对象。</p>
<p>根据传入的数组长度分为三种情况进行调用，我们一起分析下:</p>
<p><strong>第一情况，数组长度为 0：</strong></p>
<p>这种情况调用了 <code>empty()</code> 方法，即数据为空，这种情况最终会调用  EmptyObservableHolder 类的 <code>call()</code> 方法，而 EmptyObservableHolder  继承自 OnSubscribe ，重写了 <code>call()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EmptyObservableHolder implements OnSubscribe&lt;Object&gt; &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Object&gt; child)</span> </span>&#123;</div><div class="line">      <span class="comment">//直接调用 Subscriber 的 onCompleted </span></div><div class="line">        child.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很明显，如果数组内元素个数为 0，那么直接调用了 Subscriber 的 <code>onCompleted()</code> 方法完成数据发送。</p>
<p><strong>第二情况，数组长度为1，源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line">     * Returns an Observable that emits a single item and then completes.</div><div class="line">     *返回一个发送单一数据的 Observable 对象</div><div class="line">  **/</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">just</span><span class="params">(<span class="keyword">final</span> T value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ScalarSynchronousObservable.create(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着看 <code>ScalarSynchronousObservable.create()</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs a ScalarSynchronousObservable with the given constant value.</div><div class="line"> * <span class="doctag">@return</span> the new Observable</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ScalarSynchronousObservable&lt;T&gt; <span class="title">create</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">  <span class="comment">//直接根据传入的数据 new 了一个 ScalarSynchronousObservable 对象返回</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScalarSynchronousObservable&lt;T&gt;(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看 ScalarSynchronousObservable 含一个参数的构造方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ScalarSynchronousObservable</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</div><div class="line">  <span class="comment">//直接调用父类构造方法并传入 JustOnSubscribe 对象</span></div><div class="line">    <span class="keyword">super</span>(hook.onCreate(<span class="keyword">new</span> JustOnSubscribe&lt;T&gt;(t)));</div><div class="line">  <span class="comment">//将传入参数保存为成员变量</span></div><div class="line">    <span class="keyword">this</span>.t = t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法很关键，ScalarSynchronousObservable 这个类继承自 Observable 类，所以 </p>
<p><code>super(hook.onCreate(new JustOnSubscribe&lt;T&gt;(t)))</code> 就是调用了 Observable  含有一个参数的构造方法，然后看一下传入的参数即 <code>hook.onCreate(new JustOnSubscribe&lt;T&gt;(t))</code>这个方法 返回的对象，这里的 <code>hook</code> 就是我们前面说过的 RxJavaObservableExecutionHook 类，是RxJavaPlugins中的一个类，用于插入一些你所需要的代码，记录，测试等，最终直接返回了传入的参数，没做对业务逻辑有作用的事情，所以 <code>super(hook.onCreate(new JustOnSubscribe&lt;T&gt;(t)));</code> 方法我们就可以简化为 <code>new Observer( new JustOnSubscribe&lt;T&gt;(t))</code>，即直接 new 一个 Observable 对象，传入一个 OnSubscribe 参数，这个结果和我们前面分析的直接创建 Observable 对象的方法<code>Observable.create(OnSubscribe&lt;T&gt; f)</code>执行结果是一样的，即这个方法最终其实还是调用了我们前面直接使用的方法，豁然开朗。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Observable</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.onSubscribe = f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么再看一下这个 JustOnSubscribe 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JustOnSubscribe</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> T value;</div><div class="line"></div><div class="line">    JustOnSubscribe(T value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</div><div class="line">        s.setProducer(createProducer(s, value));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类继承自 OnSubscribe 类，并重写了 <code>call()</code> 方法，这里先看一下<code>s.setProducer(createProducer(s, value))</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Producer <span class="title">createProducer</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; s, T v)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (STRONG_MODE) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SingleProducer&lt;T&gt;(s, v);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WeakSingleProducer&lt;T&gt;(s, v);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的作用就是根据 STRONG_MODE 参数和传入的 Subscriber 参数和 泛型参数 T 创建一个数量发生器（Producer，是一个接口，它只有一个 <code>request()</code>方法，用来在 Observable 和 Subscriber 直接创建一个请求信道，允许 Subscriber 向 Observable 请求确定个数的事件，这个确定的数量将会影响调用 <code>Observer.onNext(Object)</code>方法，这样可以限制请求，一般实现该接口的类，都会包含一个 Subscriber 对象和一个待处理的数据，<code>createProducer(s, t)</code> 方法中，s 是一个 Subscriber 对象，t 是一个待处理的参数，可以在Producer 中先对 t 进行相应的处理随后，再将数据传送给 Subscriber ，STRONG_MODE  为引用模式，默认为 false，那么就会执行 <code>new WeakSingleProducer&lt;T&gt;(s, v)</code>  ，看一下这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * This is the weak version of SingleProducer that uses plain fields</div><div class="line"> * to avoid reentrancy and as such is not threadsafe for concurrent</div><div class="line"> * request() calls.</div><div class="line"> * <span class="doctag">@param</span> &lt;T&gt; the value type</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakSingleProducer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Producer</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; actual;</div><div class="line">    <span class="keyword">final</span> T value;</div><div class="line">  <span class="comment">//标记 request 是否已经调用过一次</span></div><div class="line">    <span class="keyword">boolean</span> once;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakSingleProducer</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; actual, T value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.actual = actual;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</div><div class="line">      <span class="comment">//这个方法如果调用一次，直接结束方法</span></div><div class="line">        <span class="keyword">if</span> (once) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//如果发生数据个数小于 0，不合法</span></div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0L</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"n &gt;= required but it was "</span> + n);</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//发送 0 个数据，直接结束方法</span></div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0L</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//如果这个方法调用走到这里，标记该方法已经调用一次</span></div><div class="line">        once = <span class="keyword">true</span>;</div><div class="line">        Subscriber&lt;? <span class="keyword">super</span> T&gt; a = actual;</div><div class="line">        <span class="keyword">if</span> (a.isUnsubscribed()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        T v = value;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">//调用 Subscriber 的 onNext 方法发送数据</span></div><div class="line">            a.onNext(v);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            Exceptions.throwOrReport(e, a, v);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (a.isUnsubscribed()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">// 调用 Subscriber 的 onCompleted 方法结束数据发送</span></div><div class="line">        a.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类里面主要方法就是 <code>request(long n)</code> 方法，而该方法的作用就是只执行一遍 Subscriber 的 <code>onNext()</code> 和 <code>onCompleted()</code>方法，来发送一次数据并结束订阅过程。</p>
<p>再看一下 Subscriber 的 <code>setProducer(Producer p)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducer</span><span class="params">(Producer p)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> toRequest;<span class="comment">//请求事件限制个数</span></div><div class="line">    <span class="keyword">boolean</span> passToSubscriber = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        toRequest = requested;</div><div class="line">      <span class="comment">//将 producer 进行赋值</span></div><div class="line">        producer = p;</div><div class="line">        <span class="keyword">if</span> (subscriber != <span class="keyword">null</span>) &#123;<span class="comment">//一般情况下该结果为假 </span></div><div class="line">            <span class="comment">// middle operator ... we pass through unless a request has been made</span></div><div class="line">            <span class="keyword">if</span> (toRequest == NOT_SET) &#123;</div><div class="line">                <span class="comment">// we pass through to the next producer as nothing has been requested</span></div><div class="line">              <span class="comment">//如果 subscriber != null 且 toRequest == NOT_SET </span></div><div class="line">              <span class="comment">//将 passToSubscriber 设置为 true</span></div><div class="line">                passToSubscriber = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// do after releasing lock</span></div><div class="line">    <span class="keyword">if</span> (passToSubscriber) &#123;<span class="comment">//一般情况该行结果为假  </span></div><div class="line">      <span class="comment">//如果 passToSubscriber为 true ，进行递归调用，</span></div><div class="line">      <span class="comment">//调用设定的那个 subscriber 的 setProducer 方法</span></div><div class="line">        subscriber.setProducer(producer);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// we execute the request with whatever has been requested (or Long.MAX_VALUE)</span></div><div class="line">        <span class="keyword">if</span> (toRequest == NOT_SET) &#123;</div><div class="line">          <span class="comment">//toRequest == NOT_SET 请求事件个数限制失效</span></div><div class="line">            producer.request(Long.MAX_VALUE);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">//设定请求个数限制，调用 producer 的 request 方法</span></div><div class="line">            producer.request(toRequest);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过源码可以看出 <code>setProducer(Producer p)</code> 方法主要完成的任务有：给 Subscriber 对象的 Producer 赋值，调用 <code>producer.request()</code> 方法，这样就完成了数据的发送。而上面那些个 if 语句判断情况，其实方法注释已经写的很清楚，我这里简单翻译下：如果设定了其他的 subscriber （通过调用构造函数） ，那么这个方法将会执行 <code>subscriber.setProducer(producer)</code> 方法，注意这里是调用你设定那个其他 subscriber 的  <code>setProducer(producer)</code> 方法  ；如果没有设定其他的 subscriber  并且 现在这个 subscriber  没有设定限定请求个数（toRequest == NOT_SET） ，那么 <code>producer.request(Long.MAX_VALUE)</code> 方法将会调用；如果设定了其他 subscriber   并且限制了请求事件个数（toRequest ！= NOT_SET），那么 <code>producer.request(toRequest)</code> 方法将得到执行。</p>
<p><strong>第三情况，数组长度大于 1：</strong></p>
<p>调用代码为 <code>create(new OnSubscribeFromArray&lt;T&gt;(array))</code>  ，直接调用 Observable 类的 <code>create(OnSubscribe&lt;T&gt; f)</code> 方法，这个构造方法前面我们分析过，所以直接看 <code>new OnSubscribeFromArray&lt;T&gt;(array)</code> 方法，OnSubscribeFromArray 这个类实现了 OnSubscribe 类，我们先看这个类的构造方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*<span class="doctag">@param</span> array 传入的要发送的数组对象</div><div class="line">**/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeFromArray</span><span class="params">(T[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.array = array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个构造方法很简单，就是将传递进来的参数保存为成员变量，既然 OnSubscribeFromArray 这个类实现了 OnSubscribe 类，我们肯定要去看一下重写的 <code>call(Subscriber&lt;? super T&gt; child)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; child)</span> </span>&#123;</div><div class="line">    child.setProducer(<span class="keyword">new</span> FromArrayProducer&lt;T&gt;(child, array));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 调用的 Subscriber 的 <code>setProducer(Producer p)</code> 方法前面我们分析过，所以直接看 <code>new FromArrayProducer&lt;T&gt;(child, array)</code> 方法，FromArrayProducer 这个类继承自 Producer 类，先看一下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FromArrayProducer</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; child, T[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.child = child;</div><div class="line">    <span class="keyword">this</span>.array = array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造方法就是将传递进来的 Subscriber 对象和数组 array 保存为成员变量。再看一下重写的 <code>request(long n)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</div><div class="line">  <span class="comment">//请求数量为 0 ，抛出异常</span></div><div class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"n &gt;= 0 required but it was "</span> + n);</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//请求数量没有限制调用</span></div><div class="line">    <span class="keyword">if</span> (n == Long.MAX_VALUE) </div><div class="line">        <span class="keyword">if</span> (BackpressureUtils.getAndAddRequest(<span class="keyword">this</span>, n) == <span class="number">0</span>) &#123;</div><div class="line">            fastPath();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">      <span class="comment">//请求数量做了限制调用</span></div><div class="line">    <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (BackpressureUtils.getAndAddRequest(<span class="keyword">this</span>, n) == <span class="number">0</span>) &#123;</div><div class="line">            slowPath(n);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法内部调用分了三种情况：第一种当 请求数量 n 小于 0 的时候直接抛出一个异常；第二种当 请求数量 n == Long.MAX_VALUE 的时候，首先进行了 <code>BackpressureUtils.getAndAddRequest(this, n) == 0</code> 判断，这行代码的作用是采用 CAS 操作模式将数量 n 赋值给 request 如果操作成功则返回原始值，这个原始值是 0，即返回值为 0，代表操作成功了，其中 CAS 操作模式主要应用在 Java 并发编程，大家可以 Google 了解下，然后看一下调用的 <code>fastPath()</code>  方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fastPath</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; child = <span class="keyword">this</span>.child;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (T t : array) &#123;</div><div class="line">        <span class="keyword">if</span> (child.isUnsubscribed()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        child.onNext(t);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (child.isUnsubscribed()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    child.onCompleted();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法也很简单，就是直接遍历数组 array 并调用 Subscriber 的 <code>onNext(t)</code> 发送数据，最后调用 <code>onCompleted()</code> 方法结束发送；第三种情况调用 <code>slowPath(n)</code> 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">slowPath</span><span class="params">(<span class="keyword">long</span> r)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; child = <span class="keyword">this</span>.child;</div><div class="line">    <span class="keyword">final</span> T[] array = <span class="keyword">this</span>.array;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> n = array.length;</div><div class="line">    </div><div class="line">    <span class="keyword">long</span> e = <span class="number">0L</span>;</div><div class="line">    <span class="keyword">int</span> i = index;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (r != <span class="number">0L</span> &amp;&amp; i != n) &#123;</div><div class="line">            <span class="keyword">if</span> (child.isUnsubscribed()) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果循环第 i 次时，没超过请求限制个数和数组长度并且没有取消订阅</span></div><div class="line">          <span class="comment">//那么调用 Subscriber 的 onNext 方法发送数据</span></div><div class="line">            child.onNext(array[i]);</div><div class="line">            </div><div class="line">            i++;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (i == n) &#123;</div><div class="line">                <span class="keyword">if</span> (!child.isUnsubscribed()) &#123;</div><div class="line">                    child.onCompleted();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            r--;</div><div class="line">            e--;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        r = get() + e;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (r == <span class="number">0L</span>) &#123;</div><div class="line">            index = i;</div><div class="line">            r = addAndGet(e);</div><div class="line">            <span class="keyword">if</span> (r == <span class="number">0L</span>) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            e = <span class="number">0L</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法主要作用其实还是遍历数组  array 并调用 Subscriber 的 <code>onNext(t)</code> 发送数据，最后调用 <code>onCompleted()</code> 方法结束发送，只不过是添加了请求限制个数限制条件的各种判断。</p>
<h2 id="2-4-Observable-map-Func1-lt-super-T-extends-R-gt-func"><a href="#2-4-Observable-map-Func1-lt-super-T-extends-R-gt-func" class="headerlink" title="2.4  Observable.map(Func1&lt;? super T, ? extends R&gt; func)"></a>2.4  Observable.map(Func1&lt;? super T, ? extends R&gt; func)</h2><p><code>map()</code> 函数使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * map 函数的用方法：一对一的进行转换</div><div class="line"> * 根据传入的一个泛型类类型进行转换为另一个需要的泛型类型，</div><div class="line"> * 比如被观察者泛型对象为 Integer 类型，而订阅者或者观察者需要的是 Drawable 类型</div><div class="line"> * 对象，此时使用 map 函数进行转换</div><div class="line"> * <span class="doctag">@param</span> integer 输入类型</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mapTest</span><span class="params">(Integer integer, <span class="keyword">final</span> ImageView imageView)</span></span>&#123;</div><div class="line">    <span class="comment">//指定被观察者对象类型为 Integer</span></div><div class="line">    Observable.just(integer)</div><div class="line">            <span class="comment">//使用 map 函数指定将 Integer 类型对象换换为 Drawable 类型</span></div><div class="line">            .map(<span class="keyword">new</span> Func1&lt;Integer, Drawable&gt;() &#123;</div><div class="line">                <span class="comment">//进行类型转换 并将最终转换成的类型对象返回</span></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Drawable <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> imageView.getContext().getResources()</div><div class="line">                      .getDrawable(R.drawable.icon_one);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//形成订阅关系，并指定 观察者接受的对象类型为 Drawable 类型</span></div><div class="line">            &#125;)</div><div class="line">      .subscribe(<span class="keyword">new</span> Action1&lt;Drawable&gt;() &#123;</div><div class="line">        <span class="comment">//观察者接受最终经过 map 函数转换成的对象类型为 Drawable 类型对象</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Drawable drawable)</span> </span>&#123;</div><div class="line">            <span class="comment">//观察者接受结果进行处理</span></div><div class="line">            imageView.setImageDrawable(drawable);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面看一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns an Observable that applies a specified function to each item emitted by the </div><div class="line"> * source Observable and emits the results of these function applications.</div><div class="line"> * <span class="doctag">@param</span> func a function to apply to each item emitted by the Observable</div><div class="line"> * <span class="doctag">@return</span> an Observable that emits the items from the source Observable, transformed by the specified function</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; func)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> lift(<span class="keyword">new</span> OperatorMap&lt;T, R&gt;(func));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法主要作用就是得到一个新的 Observable 对象， 将原始的 Observable  发送的对象添加一个功能处理一下再将处理后的对象发送出去；看一下方法传递的参数 Func1 类源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Represents a function with one argument.</div><div class="line"> * <span class="doctag">@param</span> &lt;T&gt; the first argument type</div><div class="line"> * <span class="doctag">@param</span> &lt;R&gt; the result type</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Func1</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span> </span>&#123;</div><div class="line">    <span class="function">R <span class="title">call</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * All Func and Action interfaces extend from this.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 RxJava 中除了有 Func1 还有 Func2 等，其实 FuncX 就是对有参数且有返回值的一类方法的包装而已，将T类型的数据转换为R类型数据。OperatorMap 类源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorMap</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Operator</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; transformer;</div><div class="line"><span class="comment">//这里的 transformer 就是我们 map(new Func1&lt;Integer, Drawable&gt;() 传入对象</span></div><div class="line">  <span class="comment">//实现将泛型 T 转换为 泛型 R </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatorMap</span><span class="params">(Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; transformer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.transformer = transformer;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//重写 call 方法，利用 Subscriber&lt;R&gt;将 转换由泛型 &lt;T&gt; 转换得到的泛型 &lt;R&gt;发送出去</span></div><div class="line">  <span class="comment">//这里的  Subscriber&lt;? super R&gt; o 就是我们订阅时候传入的</span></div><div class="line">  <span class="comment">//subscribe(new Observable &lt;Drawable&gt;() )</span></div><div class="line">  <span class="comment">//这里调用 OperatorMap 的 call 方法得到 MapSubscriber&lt;T, R&gt;  parent 对象</span></div><div class="line">  <span class="comment">//然后调用 parent 的 onNext 方法完成数据转换和发送</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; o) &#123;</div><div class="line">      <span class="comment">//在这个 MapSubscriber 对象中重写 onNext 方法内部完成泛型 T 转换为泛型 R ，并</span></div><div class="line">      <span class="comment">//利用传递进来的  Subscriber&lt;? super R&gt; o 方法将转换结果 R 类型数据发送出去</span></div><div class="line">        MapSubscriber&lt;T, R&gt; parent = <span class="keyword">new</span> MapSubscriber&lt;T, R&gt;(o, transformer);</div><div class="line">        o.add(parent);</div><div class="line">      <span class="comment">// MapSubscriber&lt;T, R&gt;  类继承 Subscriber&lt;? super T&gt; ，这里返回 parent </span></div><div class="line">      <span class="comment">//而函数要求的返回类型是  Subscriber&lt;? super T&gt; ，这里是一个多态</span></div><div class="line">        <span class="keyword">return</span> parent;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>OperatorMap 类实现了 Operator 类，而 Operator 类实现了 Func1 类，OperatorMap  内部主要是重写了 call 方法，注意这里看着像是将 Subscriber<r>  转换成一个 Subscriber<t>，并返回Subscriber&lt;? super T&gt;  对象，我记得之前看其他 RxJava 源码分析有是这么写的，但是我感觉这样写容易误解的，其实这里是通过 OperatorMap 构造函数传递进来的 Func1&lt;? super T, ? extends R&gt;  transformer 将输入类型 T 转换为 R类型，然后利用 OperatorMap 重写的 call 方法传递进来的 Subscriber&lt;? super R&gt;  o 的 onNext(R)   方法将转换结果 R发送出去，然后返回  MapSubscriber<t, r=""> 对象，这个MapSubscriber<t, r="">  实现了Subscriber<t> 类并重写了 <code>onNext(T t)</code> 方法，这些转换都是在这个重写的  <code>onNext(T t)</code>  方法中进行 ，所以当我们调用 <code>OperatorMap. call(final Subscriber&lt;? super R&gt; o)</code>得到 返回的 MapSubscriber<t, r=""> 对象 parent （Subscriber 类型），那么再去调用<code>parent.onNext()</code> 方法 就会完成将输入类型 T 转换为 R类型并发送出去的效果，一起看一下  MapSubscriber 这个类：</t,></t></t,></t,></t></r></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSubscriber</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; actual;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> done;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSubscriber</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; actual, Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.actual = actual;</div><div class="line">        <span class="keyword">this</span>.mapper = mapper;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//在这个方法内部完成 T转换为 R 并发送出去</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">        R result;</div><div class="line">        </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">//通过 Func1 的 call 方法将输入泛型 T 转换为 R </span></div><div class="line">          <span class="comment">//这个方法就是我们在使用 map 函数需要传入一个 Func1 对象，并重写</span></div><div class="line">          <span class="comment">//的 call 方法，就是在这里得到的调用进行转换</span></div><div class="line">            result = mapper.call(t);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">            Exceptions.throwIfFatal(ex);</div><div class="line">            unsubscribe();</div><div class="line">            onError(OnErrorThrowable.addValueAsLastCause(ex, t));</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//通过 Subscriber 的 onNext 方法将转换得到的结果 T 发送出去</span></div><div class="line">        <span class="comment">//这里的  actual 就是我们订阅时候传入的</span></div><div class="line">  <span class="comment">//subscribe(new Observable &lt;Drawable&gt;() )</span></div><div class="line">        actual.onNext(result);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个类内部也很简单，主要是重写了 Subscriber 的 <code>onNext(T t)</code> 方法，  就是通过构造方法传递进来的 Func1&lt;? super T, ? extends R&gt; 对象将输入类型 T 转换为 R类型，然后在通过传递进来的 Subscriber&lt;? super R&gt; 的 <code>onNext(R)</code>  将转换后得到的结果 R 发送出去。</p>
<p>最后看一下 <code>lift(final Operator&lt;? extends R, ? super T&gt; operator)</code> 方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Lifts a function to the current Observable and returns a new Observable that when subscribed</div><div class="line"> * to will pass the values of the current Observable through the Operator function.</div><div class="line"> * In other words, this allows chaining Observers together on an Observable for</div><div class="line"> * acting on the values within  the Observable</div><div class="line"> * <span class="doctag">@param</span> operator the Operator that implements the Observable-operating </div><div class="line"> * function to be applied to the source  Observable       </div><div class="line"> * <span class="doctag">@return</span> an Observable that is the result of applying </div><div class="line"> * the lifted Operator to the source Observable</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(<span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">  <span class="comment">//onSubscribe 为原始数据，即创建原始 Observable 时候传递进来的 onSubscribe 对象</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;R&gt;(<span class="keyword">new</span> OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的主要作用就是对当前的 Observable 对象进行一个功能变化，并返回一个新的 Observable 对象，当这个新的 Observable 对象被订阅之后，就可以通过这个 Operator 对象的功能变换来发送当前 Observable  对象的数据。换句话说。这个方法通过在一个特定的 Observable 内部使得观察者 Observers 和 被观察者 Observable 来接发数据形成关联。lift 方法内部直接调用了 Observable 的构造函数创建一个 Observable 并返回，而这里传入的参数 OnSubscribe 和 Operator 我们前面已经分析过，下面只要看 OnSubscribeLift 这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSubscribeLift</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> RxJavaObservableExecutionHook hook = RxJavaPlugins.getInstance().getObservableExecutionHook();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> OnSubscribe&lt;T&gt; parent;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeLift</span><span class="params">(OnSubscribe&lt;T&gt; parent, Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.parent = parent;</div><div class="line">        <span class="keyword">this</span>.operator = operator;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//重写 call 方法，传入我们订阅 Obdervable 时候创建的 Subscriber&lt;? super R&gt; 对象</span></div><div class="line">  <span class="comment">//这里的 call 方法在我们最后 subcribe 订阅的时候进行调用</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">//调用 Operator 的 call 方法 返回 一个新的 Subscriber(MapSubscriber) 对象</span></div><div class="line">          <span class="comment">//并将我们订阅 Obdervable 时候创建的 Subscriber&lt;? super R&gt; 对象传递给 </span></div><div class="line">          <span class="comment">//(operator).call(o)方法</span></div><div class="line">            Subscriber&lt;? <span class="keyword">super</span> T&gt; st = hook.onLift(operator).call(o);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// new Subscriber created and being subscribed with so 'onStart' it</span></div><div class="line">                st.onStart();</div><div class="line">              <span class="comment">//调用最开始创建 Obsaverble 时候创建的那个的 OnSubscribe 的 call 方法</span></div><div class="line">              <span class="comment">//传入新的 operator 的 MapSubscriber 对象</span></div><div class="line">              <span class="comment">//在这个新的 Subscriber（MapSubscriber) 的 onNext(T t) 方法内部我们完成了</span></div><div class="line">              <span class="comment">//将输入类型 T 转换为 R ，然后</span></div><div class="line">              <span class="comment">//调用了Subscriber&lt;? super R&gt; o.onNext(R) 将转换结果发送出去</span></div><div class="line">                parent.call(st);</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">               </div><div class="line">                Exceptions.throwIfFatal(e);</div><div class="line">                st.onError(e);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) </div><div class="line">            o.onError(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类继承自 OnSubscribe 重写了 call 方法，在 call 方法内部通过调用 operator.call(o) 方法得到一个新的 Subscriber，最后将这个 Subscriber 传递给原始 OnSubscribe 的 call 方法，到这里就完成了整个转换操作，剩下的就是我们在 2.1 章节分析过的 Observable.subscribe 方法部分了，即在执行 map 函数转换之后得到 Observable<r> 对象然后进行 subscribe 订阅的时候 OnSubscribeLift 的 call 方法就会执行调用，然后在这个重写的 call 方法内部会调用 operator.call(o) 得到 Subscriber(MapSubscriber) 对象，接着就会调用第一次创建 Observable<t> 时候创建的 OnSubscribe 的call 方法即  parent.call(st)，其中传递进去的参数 st  即为新的 Subscriber(MapSubscriber) 对象，在其内部完成转换操作 。</t></r></p>
<p><strong>对象变化</strong></p>
<p>这里面最后总结一下，其实 RxJava 这个 lift （包括其他 map 、flatMap) 操作符就是完成各种对象的变换，而变换主要涉及到的就是 Subscriber、Observable、OnSubscribe  这三个对象的各种转换。</p>
<p><strong>Observable的变化</strong></p>
<ol>
<li><p>每个操作符都会新建一个 Observable 和一个新建的 OnSubscribe   (下游Observable和下游 OnSubscribe  )；</p>
</li>
<li><p>下游 OnSubscribe 中持有上游的 OnSubscribe；</p>
</li>
<li><p>下游的 OnSubscribe 先调用 Operator 拿到针对上游的 Subscriber，然后就可以调用上游OnSubscribe.call() 方法了。<br><strong>流程图（代码分解）：</strong></p>
<p><img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase6/map.png?raw=true" alt="map"></p>
<p><strong>当 Subscribe 订阅时代码执行流程：</strong></p>
<p> <img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase6/map2.png?raw=true" alt="map2"></p>
</li>
</ol>
<h2 id="2-5-Observable-flatMap-Func1-lt-super-T-extends-Observable-lt-extends-R-gt-gt-func"><a href="#2-5-Observable-flatMap-Func1-lt-super-T-extends-Observable-lt-extends-R-gt-gt-func" class="headerlink" title="2.5 Observable.flatMap(Func1&lt;? super T, ? extends Observable&lt;? extends R&gt;&gt; func)"></a>2.5 Observable.flatMap(Func1&lt;? super T, ? extends Observable&lt;? extends R&gt;&gt; func)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * flatMap 函数使用，实现一对多转换，其实 flatmap 是返回一个 observable 对象，所以可以继续操作</div><div class="line"> * flatMap 最终返回的是一个 Observable 对象</div><div class="line"> * 传入一组学生List&lt;Student&gt; 对象，然后取出每一个学生，</div><div class="line"> * 打印每一个学生的多个成绩</div><div class="line"> * <span class="doctag">@param</span> students</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMapTest</span><span class="params">(<span class="keyword">final</span> List&lt;Student&gt; students)</span></span>&#123;</div><div class="line">    <span class="comment">//直接订阅最终结果 Course ，即订阅类型为 Course 类型</span></div><div class="line">    Subscriber &lt;Course&gt; subscriber=<span class="keyword">new</span> Subscriber&lt;Course&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">            Log.d(TAG,<span class="string">"onCompleted"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"><span class="comment">//取出 Course 对象进行打印</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Course course)</span> </span>&#123;</div><div class="line">        Log.d(TAG,course.getName());</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"><span class="comment">//传入一组List&lt;Student&gt; 对象</span></div><div class="line">    Observable.from(students)</div><div class="line">            <span class="comment">//将一个 Observable&lt;Student&gt;&gt; 对象</span></div><div class="line">            <span class="comment">//转换为多个 Observable&lt;Course&gt;&gt; 对象</span></div><div class="line">            <span class="comment">// 并激活进行发送 Course 对象，统一发送到subscribe 订阅的</span></div><div class="line">            <span class="comment">// observable 对象内</span></div><div class="line">            <span class="comment">//其实flatMap 函数是创建一个新的 Observable 对象，</span></div><div class="line">            <span class="comment">//这个新的 Observable 对象就像一个代理</span></div><div class="line">            <span class="comment">//接受原始 Observable 对象发送的事件并进行处理然后发送给 subscriber 这个订阅者</span></div><div class="line">            .flatMap(<span class="keyword">new</span> Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Observable&lt;Course&gt; <span class="title">call</span><span class="params">(Student student)</span> </span>&#123;</div><div class="line">                    <span class="comment">//flatMap 最终返回的是 Observable 对象</span></div><div class="line">                    <span class="comment">//1、使用传入的事件对象创建一个 Observable 对象</span></div><div class="line">                    <span class="comment">//2、并不发送这个 Observable, 而是将它激活，于是它开始发送事件</span></div><div class="line">                   <span class="comment">//3、每一个创建出来的 Observable 发送的事件，都被汇入同一个Observable 中</span></div><div class="line">                    <span class="comment">// 而这个 Observable 负责将这些事件统一交给 订阅者 Subscriber </span></div><div class="line">                    <span class="keyword">return</span>  Observable.from(student.getCourses());</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            .subscribe(subscriber);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-6-Compose-操作符"><a href="#2-6-Compose-操作符" class="headerlink" title="2.6 Compose 操作符"></a>2.6 Compose 操作符</h2><p>在说 <strong>compose</strong>之前要先介绍下<a href="http://reactivex.io/RxJava/javadoc/rx/Observable.Transformer.html" target="_blank" rel="external">Transformer</a><br>Transformer 实际上就是一个<code>Func1, Observable&gt;</code>，换言之就是：可以通过它将一种类型的 Observable 转换成另一种类型的 Observable，比如通过 Transformer 将<code>Observable&lt;T&gt;</code>转换成了<code>Observable&lt;R&gt;</code> ，<code>compose()</code>和 <code>lift()</code> 的区别在于，<strong>lift() 是针对事件项和事件序列的，而 compose() 是针对 Observable 自身进行变换。</strong>这个功能其实 flatmap 函数也能实现，但是 compose 操作符实现了代码重用，只需要写一个 transfrmer 就可以利用 compose 操作符实现反复利用，不用每次都写 flatmap 写重复代码，源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transformer</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Func1</span>&lt;<span class="title">Observable</span>&lt;<span class="title">T</span>&gt;, <span class="title">Observable</span>&lt;<span class="title">R</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="comment">// cover for generics insanity</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下代码可以将 Obsaverble<integer> 变换为 Obsaverble<string>：</string></integer></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftAllTransformer</span> <span class="keyword">implements</span> <span class="title">Observable</span>.<span class="title">Transformer</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(Observable&lt;Integer&gt; observable)</span> </span></div><div class="line">  &#123;<span class="keyword">return</span> observable.lift1().lift2().lift3().lift4();&#125;&#125;</div><div class="line">.....................</div><div class="line">Transformer liftAll = <span class="keyword">new</span> LiftAllTransformer();</div><div class="line"><span class="comment">//obsaverble1 为 Obsaverble&lt;Integer&gt; 类型，subscriber1 为 Subscriber&lt;String&gt; 类型</span></div><div class="line"><span class="comment">//通过 compose 操作符完成了转变</span></div><div class="line">observable1.compose(liftAll).subscribe(subscriber1);</div><div class="line">observable2.compose(liftAll).subscribe(subscriber2);</div><div class="line">observable3.compose(liftAll).subscribe(subscriber3);</div><div class="line">observable4.compose(liftAll).subscribe(subscriber4);</div></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * compose 函数实现对整体 Observable 对象进行变化，产生新的 Observable 对象返回</div><div class="line"> * <span class="doctag">@param</span> i</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">composeTest</span><span class="params">(<span class="keyword">final</span> Integer i)</span></span>&#123;</div><div class="line">    LiftAllTransformer liftAllTransformer=<span class="keyword">new</span> LiftAllTransformer();</div><div class="line">    Observable&lt;Integer&gt; observable=Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class="line">            subscriber.onNext(i);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    observable.compose(liftAllTransformer).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">            Log.d(TAG,s);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Transformer 实现对 Observable 对象整体变化，并返回新的 Observable对象</div><div class="line"> * Created by zhangpeng on 2016/8/28.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftAllTransformer</span> <span class="keyword">implements</span> <span class="title">Observable</span>.<span class="title">Transformer</span>&lt;<span class="title">Integer</span>,<span class="title">String</span>&gt;</span>&#123;</div><div class="line">    <span class="comment">//对原始 Observable 对象进行变化并返回新的 Observable对象</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(Observable&lt;Integer&gt; integerObservable)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> integerObservable.lift(<span class="keyword">new</span> Observable.Operator&lt;String, Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> Integer&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                        subscriber.onNext(integer+<span class="string">"第一次变化=="</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;;</div><div class="line">            &#125;</div><div class="line">        &#125;).lift(<span class="keyword">new</span> Observable.Operator&lt;String, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                    subscriber.onNext(s+<span class="string">"第二次变换=="</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">               </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-7-变换的原理：lift"><a href="#2-7-变换的原理：lift" class="headerlink" title="2.7 变换的原理：lift()"></a>2.7 变换的原理：lift()</h2><p>这些变换虽然功能各有不同，但实质上都是<strong>针对事件序列的处理和再发送</strong>。而在 RxJava 的内部，它们是基于同一个基础的变换方法： <code>lift(Operator)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(<span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;R&gt;(<span class="keyword">new</span> OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个变换原理我们在分析 map 函数的时候已经分析过了，总结起来就是通过新建一个 Obsaverble 和 OnSubscribe 来发送数据，而发送的数据是通过 Operator&lt;? extends R, ? super T&gt; operator 来实现变换的。主要分为以下几步：</p>
<p>  1.在执行<code>lift()</code>后会创建一个新的  Observable 我们标记为 Observable2，加上之前的原始  Observable 我们标记为 Observable1，现在有两个  Observable ；<br>  2.在创建新 Observable2 的时候会创建一个新的 OnSubscribe2 标记为 OnSubscribe2 ， 加上之前的原始 Observable1 中的原始  OnSubscribe1，也就有了两个 OnSubscribe；<br>  3.当用户调用 <code>lift()</code> 后 再去调用 <code>subscribe()</code> 的时候，其实是使用的 <code>lift()</code> 所返回的新的 Observable2 ，于是它所触发的 <code>onSubscribe2.call(subscriber1)</code>，即在 <code>lift()</code> 中生成的那个 OnSubscribe2；<br>  4.而这个新  OnSubscribe2 的 <code>call()</code> 方法中会持有原始的  onSubscribe1 ，就是指的原始  Observable1 中的原始  OnSubscribe1 ，在这个 <code>call()</code>方法里，用 <code>operator.call(subscriber1)</code> 生成了一个新的  Subscriber2，Operator  就是在这里，通过自己的 <code>call()</code> 方法将新  Subscriber2  和原始  Subscriber1 进行关联，并插入自己的『变换』代码以实现变换，然后利用这个新  Subscriber2 向原始  Observable1 进行订阅。  这样就实现了 <code>lift()</code> 过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。RxJava 都不建议开发者自定义 Operator 来直接使用 lift()，而是建议尽量使用已有的 <code>lift()</code> 包装方法（如 <code>map()</code> <code>flatMap()</code> 等）进行组合来实现需求，因为直接使用 <code>lift()</code> 非常容易发生一些难以发现的错误。</p>
<p>下面这是一个将事件中的 <code>Integer</code> 对象转换成 <code>String</code> 的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 利用 lift 函数实现对对象变换操作</div><div class="line">* 这里实现对被观察者 Integer 类型转换为 String 类型</div><div class="line">* <span class="doctag">@param</span> i</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">liftTest</span><span class="params">(<span class="keyword">final</span> Integer i)</span></span>&#123;</div><div class="line">   <span class="comment">//被观察者指定泛型为 Integer</span></div><div class="line">   Observable&lt;Integer&gt; observable= Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class="line">           subscriber.onNext(i);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line"></div><div class="line">   <span class="comment">//实现lift变化，将 Integer 类型转换为 String 类型</span></div><div class="line">   observable.lift(<span class="keyword">new</span> Observable.Operator&lt;String, Integer&gt;() &#123;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> Integer&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber) &#123;</div><div class="line">           <span class="comment">//返回一个新的 subscriber 对象</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                   Log.d(TAG,<span class="string">"onCompleted"</span>);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">               &#125;</div><div class="line">       <span class="comment">//实现类型转换</span></div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                       subscriber.onNext(integer+<span class="string">""</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;;</div><div class="line">       &#125;</div><div class="line">   &#125;)</div><div class="line">           <span class="comment">//对被观察者进行订阅，指定订阅对象返回 String 类型</span></div><div class="line">           .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">               <span class="comment">//对订阅结果进行处理</span></div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                   Log.d(TAG,s);</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是本次学习笔记内容，完结！</p>
<p>参考文章：</p>
<p><a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给 Android 开发者的 RxJava 详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/15/rxjava_learning_note/" data-id="civnx6lmq0008v0q7zqjbiimz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-RxJava/">Android RxJava</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-show_image_from_webView" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/24/show_image_from_webView/" class="article-date">
  <time datetime="2016-10-23T16:00:00.000Z" itemprop="datePublished">2016-10-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-WebView/">Android WebView</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/24/show_image_from_webView/">Android  WebView 实现点击界面图片滑动浏览和保存图片功能</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>-文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</p>
<ul>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://github.com/yongyu0102" target="_blank" rel="external">yongyu0102</a></li>
<li>审阅者：<a href="https://github.com/wuchangfeng" target="_blank" rel="external">wuchangfeng</a></li>
</ul>
<h1 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h1><p>最近在公司的项目中遇到<strong>需求如下</strong>：</p>
<ol>
<li><p>点击 WebView 页面的图片实现开启查看图片模式，即可以显示点击的图片，然后滑动显示下一张图片。</p>
<p>  <img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase5/showImage.gif?raw=true" alt="showImage"></p>
</li>
<li><p>长按 WebView 页面图片弹出对话框可以选择保存长按的图片到本地相册。</p>
<p> <img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase5/showpop.gif?raw=true" alt="showpop"></p>
</li>
</ol>
<p>拿到这个需求笔者第一反应是没做过 WebView 相关的交互，甚至分不清这个需求是否需要服务端配合完成 Java 与 JavaScript 的互相调用，一脸茫然。遇到这种情况笔者的解决思路一般<strong>分两个方向</strong>：</p>
<ol>
<li><p>找一个比较出名的客户端有类似功能的，然后 Google 搜索，仿 XXXX，先粗略看一下有没有现成的 Demo 可以参考，比如我这个需要，先去搜索一下 ”Android 仿微信朋友圈浏览图片效果“ （这个搜索关键字很关键啊），可是笔者没找到符合该需要的 Demo。</p>
</li>
<li><p>在第一个方案不好使的情况下，我们没有了参考，那么咱们就得自己思考这个大概实现思路，然后把这个需求进行拆分，逐一击破。所以思考大概如下：</p>
<p>（1）要想展示图片那么就得先拿到图片，要拿到图片只有两种可能，第一种可能是 WebView 本身缓存了图片，我们去缓存中读取图片进行显示，可是想一下，咱们浏览微博看图的时候如果没有网，这时候去点击图片那么图片是加载不出来的，所以这种可能否定了；所以只有第二种可能就是点击图片的时候拿到该图片对应的 URL 网址，然后咱们自己去网络加载图片进行显示，所以这个点我们 Get 到了。</p>
<p>（2）要滑动图片进行显示下一张，那么就需要我们能拿到所有要显示的图片的 URL ，然后放到一个数组里面，每次滑动就进行加载一张图片，那么也就是我们一次性拿到所有 WebView 包含图片的 URL，这个就不是在点击图片的时候去获取，而是在 WebView 加载完成后获取到，这怎么能拿到？再想一下，WebView  进行加载显示的时候其实是加载 HTML（比如 Assets 目录中的文件）文本的字符串，然后进行渲染处理显示出来，所以 HTML文本文件里面包含了我们想要的图片网址，大家看一下下面这张截图就是一个带图片的 WebView 对应加载的 HTML文本文件部分截图，</p>
<p><img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase5/webViewSrc.png?raw=true" alt="webViewSrc"></p>
<p>其中标签 src 对象的内容就是我们想要的图片 URL，所以到这里我们就有了思路，我们先拿到 WebView 加载的 HTML 内容，然后在从 HTML 里面提取我要想要的 URL。</p>
<p>（3）现在我们能拿到所有图片对应的 URL，那么滑动图片显示下一张就简单了，我们直接用一个 ViewPager 来实现滑动加载图片即可。</p>
<p><strong>总结要实现这个需要我们需要做的工作有：</strong></p>
<ol>
<li>拿到 WebView 加载的 HTML 文本。</li>
<li>从 HTML 文本中提取所有图片对应的 URL。</li>
<li>处理 WebView 中图片的点击和长按响应事件。</li>
<li>用 ViewPager 来实现滑动加载下一张图片。</li>
</ol>
<p>下面我们就按照以上几个步骤来实现我们想要的功能。</p>
</li>
</ol>
<h1 id="二、主要内容"><a href="#二、主要内容" class="headerlink" title="二、主要内容"></a>二、主要内容</h1><h2 id="2-1-获取-WebView-页面所有图片对应地址"><a href="#2-1-获取-WebView-页面所有图片对应地址" class="headerlink" title="2.1 获取 WebView 页面所有图片对应地址"></a>2.1 获取 WebView 页面所有图片对应地址</h2><h3 id="2-1-1-解析-WebView-页面加载的-HTML文本文件"><a href="#2-1-1-解析-WebView-页面加载的-HTML文本文件" class="headerlink" title="2.1.1 解析 WebView 页面加载的 HTML文本文件"></a>2.1.1 解析 WebView 页面加载的 HTML文本文件</h3><p>   <strong>定义供 JavaScript 调用的交互接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/**</span></div><div class="line">  *这个接口就是给 JavaScript 调用的,调用结果就是返回 HTML 文本，</div><div class="line">  *然后 getAllImageUrlFromHtml(HTML) </div><div class="line">  *从 HTML文件中提取页面所有图片对应的地址对象</div><div class="line">  **/</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InJavaScriptLocalObj</span> </span>&#123;</div><div class="line">       <span class="comment">/**</span></div><div class="line">        * 获取 WebView 加载对应的 HTML 文本</div><div class="line">        * <span class="doctag">@param</span> HTML WebView 加载对应的 HTML 文本</div><div class="line">        */</div><div class="line">       <span class="meta">@android</span>.webkit.<span class="function">JavascriptInterface</span></div><div class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showSource</span><span class="params">(String html)</span> &#123;</div><div class="line">         <span class="comment">//从 HTML 文件中提取页面所有图片对应的地址对象</span></div><div class="line">           getAllImageUrlFromHtml(html);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>   <strong>WebView 开启 JavaScript 脚本执行，调用 JavaScript 代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">  mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</div><div class="line">  mWebView.addJavascriptInterface(<span class="keyword">new</span> InJavaScriptLocalObj(), <span class="string">"local_obj"</span>);</div><div class="line">  mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient() &#123;</div><div class="line">            <span class="comment">// 网页跳转</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</div><div class="line">                view.loadUrl(url);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 网页加载结束</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageFinished</span><span class="params">(WebView view, String url)</span> </span>&#123;</div><div class="line">                <span class="keyword">super</span>.onPageFinished(view, url);</div><div class="line">                <span class="comment">//解析 HTML</span></div><div class="line">                parseHTML(view);</div><div class="line">            &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  Java 调取 js 代码,</div><div class="line">     * <span class="doctag">@param</span> view WebView</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseHTML</span><span class="params">(WebView view)</span> </span>&#123;</div><div class="line">  <span class="comment">//这段 js 代码是解析获取到了 HTML 文本文件，然后调用本地定义的 Java 代码返回</span></div><div class="line">  <span class="comment">//解析出来的 HTML 文本文件</span></div><div class="line">    view.loadUrl(<span class="string">"javascript:window.local_obj.showSource('&lt;head&gt;'+"</span></div><div class="line">            + <span class="string">"document.getElementsByTagName('html')[0].innerHTML+'&lt;/head&gt;');"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-1-2-从获取到的-HTML文本文件中提取页面所有图片对应的地址对象"><a href="#2-1-2-从获取到的-HTML文本文件中提取页面所有图片对应的地址对象" class="headerlink" title="2.1.2 从获取到的 HTML文本文件中提取页面所有图片对应的地址对象"></a>2.1.2 从获取到的 HTML文本文件中提取页面所有图片对应的地址对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 获取 img 标签正则</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IMAGE_URL_TAG = <span class="string">"&lt;img.*src=(.*?)[^&gt;]*?&gt;"</span>;</div><div class="line">  <span class="comment">// 获取 src 路径的正则</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IMAGE_URL_CONTENT = <span class="string">"http:\"?(.*?)(\"|&gt;|\\s+)"</span>;</div><div class="line"></div><div class="line"><span class="comment">/***</span></div><div class="line"> * 获取页面所有图片对应的地址对象，</div><div class="line"> * 例如 &lt;img src="http://sc1.hao123img.com/data/f44d0aab7bc35b8767de3c48706d429e" /&gt;</div><div class="line"> * <span class="doctag">@param</span> HTML WebView 加载的 HTML 文本</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getAllImageUrlFromHtml</span><span class="params">(String html)</span> </span>&#123;</div><div class="line">    Matcher matcher = Pattern.compile(IMAGE_URL_TAG).matcher(html);</div><div class="line">    List&lt;String&gt; listImgUrl = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    <span class="keyword">while</span> (matcher.find()) &#123;</div><div class="line">        listImgUrl.add(matcher.group());</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//从图片对应的地址对象中解析出 src 标签对应的内容</span></div><div class="line">    getAllImageUrlFormSrcObject(listImgUrl);</div><div class="line">    <span class="keyword">return</span> listImgUrl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">   <span class="comment">/***</span></div><div class="line">     * 从图片对应的地址对象中解析出 src 标签对应的内容，即 url</div><div class="line">     * 例如 "http://sc1.hao123img.com/data/f44d0aab7bc35b8767de3c48706d429e"</div><div class="line">     * <span class="doctag">@param</span> listImageUrl 图片地址对象例如 ：</div><div class="line">     *&lt;img src="http://sc1.hao123img.com/data/f44daab" /&gt;</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getAllImageUrlFormSrcObject</span><span class="params">(List&lt;String&gt; listImageUrl)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (String image : listImageUrl) &#123;</div><div class="line">            Matcher matcher = Pattern.compile(IMAGE_URL_CONTENT).matcher(image);</div><div class="line">            <span class="keyword">while</span> (matcher.find()) &#123;</div><div class="line">                listImgSrc.add(matcher.group().substring(<span class="number">0</span>, matcher.group().length() - <span class="number">1</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> listImgSrc;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>到这里我们获取到了 WebView 页面中所有图片对象对应的 URL 地址，下面就还差一步，就是在点击 WebView 界面的图片时候去响应点击事件，然后把相应的 URL 地址传递给 ViewPager 进行显示就齐活了。</p>
<h2 id="2-2-响应-WebView-界面图片的点击事件"><a href="#2-2-响应-WebView-界面图片的点击事件" class="headerlink" title="2.2 响应 WebView 界面图片的点击事件"></a>2.2 响应 WebView 界面图片的点击事件</h2><h3 id="2-2-1定义供-JavaScript-调用的交互接口"><a href="#2-2-1定义供-JavaScript-调用的交互接口" class="headerlink" title="2.2.1定义供 JavaScript 调用的交互接口"></a>2.2.1定义供 JavaScript 调用的交互接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// js 通信接口，定义供 JavaScript 调用的交互接口</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJavascriptInterface</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Context context;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyJavascriptInterface</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.context = context;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 点击图片启动新的 ShowImageFromWebActivity，并传入点击图片对应的 url</div><div class="line">     * 和页面所有图片对应的 url</div><div class="line">     * <span class="doctag">@param</span> url 点击图片对应的 url</div><div class="line">     */</div><div class="line">    <span class="meta">@android</span>.webkit.<span class="function">JavascriptInterface</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openImage</span><span class="params">(String url)</span> &#123;</div><div class="line">        Intent intent = <span class="keyword">new</span> Intent();</div><div class="line">        intent.putExtra(<span class="string">"image"</span>, url);</div><div class="line">      <span class="comment">//listImgSrc 该参数为页面所有图片对应的 url</span></div><div class="line">        intent.putStringArrayListExtra(URL_ALL, (ArrayList&lt;String&gt;) listImgSrc);</div><div class="line">        intent.setClass(context, ShowImageFromWebActivity.class);</div><div class="line">        context.startActivity(intent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-2-WebView-开启-JavaScript-脚本执行，调用-JavaScript-代码"><a href="#2-2-2-WebView-开启-JavaScript-脚本执行，调用-JavaScript-代码" class="headerlink" title="2.2.2 WebView 开启 JavaScript 脚本执行，调用 JavaScript 代码"></a>2.2.2 WebView 开启 JavaScript 脚本执行，调用 JavaScript 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"> mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</div><div class="line"><span class="comment">//载入 js</span></div><div class="line">mWebView.addJavascriptInterface(<span class="keyword">new</span> MyJavascriptInterface(<span class="keyword">this</span>), <span class="string">"imageListener"</span>);</div><div class="line">mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient() &#123;</div><div class="line">    <span class="comment">// 网页跳转</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</div><div class="line">        view.loadUrl(url);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 网页加载结束</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageFinished</span><span class="params">(WebView view, String url)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPageFinished(view, url);</div><div class="line">        <span class="comment">// web 页面加载完成，添加监听图片的点击 js 函数</span></div><div class="line">        addImageClickListener();</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  <span class="comment">/**</span></div><div class="line">     *  注入 js 函数监听，这段 js 函数的功能就是，遍历所有的图片，并添加 onclick 函数，</div><div class="line">     *  实现点击事件，</div><div class="line">     *  函数的功能是在图片点击的时候调用本地 java 接口并传递点击图片对应的 url 过去</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addImageClickListener</span><span class="params">()</span> </span>&#123;</div><div class="line">        mWebView.loadUrl(<span class="string">"javascript:(function()&#123;"</span> +</div><div class="line">                <span class="string">"var objs = document.getElementsByTagName(\"img\"); "</span> +</div><div class="line">                <span class="string">"for(var i=0;i&lt;objs.length;i++)  "</span> +</div><div class="line">                <span class="string">"&#123;"</span></div><div class="line">                + <span class="string">"    objs[i].onclick=function()  "</span> +</div><div class="line">                <span class="string">"    &#123;  "</span></div><div class="line">                + <span class="string">"        window.imageListener.openImage(this.src);  "</span> +</div><div class="line">                <span class="string">"    &#125;  "</span> +</div><div class="line">                <span class="string">"&#125;"</span> +</div><div class="line">                <span class="string">"&#125;)()"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>到这里我们完成了前两步，拿去到 WebView 界面图片对应的所有 URL 地址和响应 WebView 界面图片的点击事件，下面的事情就简单了，用 ViewPager 滑动显示每一张图片，再我们进行最后一步之前，我们再来实现一个功能就是长按 WebView 界面图片，弹出对话框来，然后可以选择保存图片功能，代码如下：</p>
<p> <strong>WebView  中图片长按点击事件处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//长按点击事件</span></div><div class="line">mWebView.setOnLongClickListener(<span class="keyword">new</span> View.OnLongClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLongClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">      <span class="comment">//响应长按事件</span></div><div class="line">        responseWebLongClick(v);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">     * 响应 WebView 长按图片的点击事件</div><div class="line">     * <span class="doctag">@param</span> v</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">responseWebLongClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (v <span class="keyword">instanceof</span> WebView) &#123;</div><div class="line">            WebView.HitTestResult result = ((WebView) v).getHitTestResult();</div><div class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">int</span> type = result.getType();</div><div class="line">                <span class="comment">//判断点击类型如果是图片</span></div><div class="line">                <span class="keyword">if</span> (type == WebView.HitTestResult.IMAGE_TYPE || type == WebView.HitTestResult.SRC_IMAGE_ANCHOR_TYPE) &#123;</div><div class="line">                    longClickUrl = result.getExtra();</div><div class="line">                    <span class="comment">//弹出对话框</span></div><div class="line">                   showDialog(longClickUrl);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">     * 长按 WebView 中图片弹出对话框，可以选择保存图片</div><div class="line">     * <span class="doctag">@param</span> url 点击图片对应的 url</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showDialog</span><span class="params">(<span class="keyword">final</span> String url)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> ActionSheetDialog(<span class="keyword">this</span>)</div><div class="line">                .builder()</div><div class="line">                .setCancelable(<span class="keyword">true</span>)</div><div class="line">                .setCanceledOnTouchOutside(<span class="keyword">true</span>)</div><div class="line">                .addSheetItem(</div><div class="line">                        <span class="string">"保存到相册"</span>,</div><div class="line">                        ActionSheetDialog.SheetItemColor.Blue,</div><div class="line">                        <span class="keyword">new</span> ActionSheetDialog.OnSheetItemClickListener() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(<span class="keyword">int</span> which)</span> </span>&#123;</div><div class="line">                                <span class="comment">//下载图片</span></div><div class="line">                                downloadImage(url);</div><div class="line">                            &#125;</div><div class="line">                        &#125;).show();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="2-3-ViewPager-滑动显示每一张图片，PhotoView-实现自由缩放功能"><a href="#2-3-ViewPager-滑动显示每一张图片，PhotoView-实现自由缩放功能" class="headerlink" title="2.3 ViewPager 滑动显示每一张图片，PhotoView  实现自由缩放功能"></a>2.3 ViewPager 滑动显示每一张图片，PhotoView  实现自由缩放功能</h2><p>由于这部分代码比较简单，这里就直接贴出部分代码，文章中所用的 Demo 代码最终会上传到 GitHub上，有兴趣可以去瞧一瞧完整的代码，这里简单介绍几个类，ShowImageFromWebActivity.java 这个类内部就包含一个 ViewPager 和两个按钮， ViewPager 用来滑动显示每一张图片，按钮用来显示滑动的页数和实现点击保存图片功能，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowImageFromWebActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ViewPager vpImageBrowser;</div><div class="line">    <span class="keyword">private</span> TextView tvImageIndex;<span class="comment">//显示滑动页数</span></div><div class="line">    <span class="keyword">private</span> Button btnSave;<span class="comment">//保存图片按钮</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> ImageBrowserAdapter adapter;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; imgUrls;<span class="comment">//WebView 页面所有图片 URL</span></div><div class="line">    <span class="keyword">private</span> String url;<span class="comment">//WebView 页面所有图片中被点击图片对应 URL</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentIndex;<span class="comment">//标记被滑动图片在所有图片中的位置</span></div><div class="line">    <span class="keyword">private</span> Handler mHandler;<span class="comment">//异步发送消息</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_show_image_from_web);</div><div class="line">        initView();</div><div class="line">        initListener();</div><div class="line">        initData();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span></span>&#123;</div><div class="line">        vpImageBrowser = (ViewPager) findViewById(R.id.vp_image_browser);</div><div class="line">        tvImageIndex = (TextView) findViewById(R.id.tv_image_index);</div><div class="line">        btnSave = (Button) findViewById(R.id.btn_save);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span></span>&#123;</div><div class="line">        mHandler = <span class="keyword">new</span> Handler();</div><div class="line">        imgUrls=getIntent().getStringArrayListExtra(MainActivity.URL_ALL);</div><div class="line">        url=getIntent().getStringExtra(<span class="string">"image"</span>);</div><div class="line">      <span class="comment">//获取被点击图片在所有图片中的位置</span></div><div class="line">        <span class="keyword">int</span> position=imgUrls.indexOf(url);</div><div class="line">        adapter=<span class="keyword">new</span> ImageBrowserAdapter(<span class="keyword">this</span>,imgUrls);</div><div class="line">        vpImageBrowser.setAdapter(adapter);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size=imgUrls.size();</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(size &gt; <span class="number">1</span>) &#123;</div><div class="line">            tvImageIndex.setVisibility(View.VISIBLE);</div><div class="line">            tvImageIndex.setText((position+<span class="number">1</span>) + <span class="string">"/"</span> + size);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            tvImageIndex.setVisibility(View.GONE);</div><div class="line">        &#125;</div><div class="line">        vpImageBrowser.setOnPageChangeListener(<span class="keyword">new</span> ViewPager.OnPageChangeListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> arg0)</span> </span>&#123;</div><div class="line">                currentIndex=arg0;</div><div class="line">                <span class="keyword">int</span> index = arg0 % size;</div><div class="line">                tvImageIndex.setText((index+<span class="number">1</span>) + <span class="string">"/"</span> + size);</div><div class="line">            &#125;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> arg0, <span class="keyword">float</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            &#125;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> arg0)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        vpImageBrowser.setCurrentItem(position);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initListener</span><span class="params">()</span></span>&#123;</div><div class="line">        btnSave.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (v.getId())&#123;</div><div class="line">            <span class="keyword">case</span> R.id.btn_save :</div><div class="line">                Toast.makeText(getApplicationContext(), <span class="string">"开始下载图片"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">                downloadImage();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 开始下载图片</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downloadImage</span><span class="params">()</span> </span>&#123;</div><div class="line">        downloadAsync(imgUrls.get(currentIndex), Environment.getExternalStorageDirectory().getAbsolutePath() + <span class="string">"/ImagesFromWebView"</span>);</div><div class="line">    &#125;</div><div class="line">      </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>ShowImageFromWebActivity.java 对应 xml 文件</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:background</span>=<span class="string">"@android:color/black"</span></div><div class="line">    <span class="attr">tools:context</span>=<span class="string">"activity.ShowImageFromWebActivity"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">view.PhotoViewViewPager</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/vp_image_browser"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">view.PhotoViewViewPager</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_alignParentBottom</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></div><div class="line">        <span class="attr">android:padding</span>=<span class="string">"16dp"</span> &gt;</div><div class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">            <span class="attr">android:textSize</span>=<span class="string">"18sp"</span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/tv_image_index"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"56dp"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"36dp"</span></div><div class="line">            <span class="attr">android:background</span>=<span class="string">"@drawable/shape_corner_rect_gray"</span></div><div class="line">            <span class="attr">android:gravity</span>=<span class="string">"center"</span></div><div class="line">            <span class="attr">android:paddingTop</span>=<span class="string">"3dp"</span></div><div class="line">            <span class="attr">android:paddingBottom</span>=<span class="string">"3dp"</span></div><div class="line">            <span class="attr">android:paddingRight</span>=<span class="string">"10dp"</span></div><div class="line">            <span class="attr">android:paddingLeft</span>=<span class="string">"10dp"</span></div><div class="line">            <span class="attr">android:text</span>=<span class="string">"1/9"</span></div><div class="line">            <span class="attr">android:textColor</span>=<span class="string">"@android:color/white"</span> /&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">View</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"1dp"</span></div><div class="line">            <span class="attr">android:layout_weight</span>=<span class="string">"1"</span> /&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/btn_save"</span></div><div class="line">            <span class="attr">android:textSize</span>=<span class="string">"@dimen/_16sp"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"56dp"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"36dp"</span></div><div class="line">            <span class="attr">android:background</span>=<span class="string">"@drawable/shape_corner_rect_gray"</span></div><div class="line">            <span class="attr">android:gravity</span>=<span class="string">"center"</span></div><div class="line">            <span class="attr">android:padding</span>=<span class="string">"4dp"</span></div><div class="line">            <span class="attr">android:text</span>=<span class="string">"保存"</span></div><div class="line">            <span class="attr">android:textColor</span>=<span class="string">"@color/white"</span> /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>ImageBrowserAdapter.java 类代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageBrowserAdapter</span> <span class="keyword">extends</span> <span class="title">PagerAdapter</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> Activity context;</div><div class="line">   <span class="keyword">private</span> List&lt;String&gt; picUrls;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ImageBrowserAdapter</span><span class="params">(Activity context, ArrayList&lt;String&gt; picUrls)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.context = context;</div><div class="line">      <span class="keyword">this</span>.picUrls = picUrls;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> picUrls.size();</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isViewFromObject</span><span class="params">(View view, Object object)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> view == object;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> View <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">      View view = View.inflate(context, R.layout.item_image_browser, <span class="keyword">null</span>);</div><div class="line">      ImageView iv_image_browser = (ImageView) view.findViewById(R.id.show_webimage_imageview);</div><div class="line">      String picUrl = picUrls.get(position);</div><div class="line">      <span class="keyword">final</span>  PhotoViewAttacher photoViewAttacher=<span class="keyword">new</span> PhotoViewAttacher(iv_image_browser);</div><div class="line">      photoViewAttacher.setScaleType(ImageView.ScaleType.FIT_CENTER);</div><div class="line">     <span class="comment">//显示图片</span></div><div class="line">      Glide.with(context).</div><div class="line">            load(picUrl)</div><div class="line">            .crossFade()</div><div class="line">            .placeholder(R.drawable.avatar_default)</div><div class="line">            .error(R.drawable.image_default_rect)</div><div class="line">            .into(<span class="keyword">new</span> GlideDrawableImageViewTarget(iv_image_browser)&#123;</div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(GlideDrawable resource, GlideAnimation&lt;? <span class="keyword">super</span> GlideDrawable&gt; animation)</span> </span>&#123;</div><div class="line">                  <span class="keyword">super</span>.onResourceReady(resource, animation);</div><div class="line">                     photoViewAttacher.update();</div><div class="line">               &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">      container.addView(view);</div><div class="line">      <span class="keyword">return</span> view;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position, Object object)</span> </span>&#123;</div><div class="line">      container.removeView((View) object);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>上面代码也很简单，就是根据 URL 来加载显示图片，然后利用 PhotoView 进行缩放。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//ImageBrowserAdapter Item 布局文件</div><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:gravity</span>=<span class="string">"center"</span>&gt;</div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">RelativeLayout</span></span></div><div class="line">            <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:gravity</span>=<span class="string">"center_vertical"</span>&gt;</div><div class="line">             <span class="tag">&lt;<span class="name">uk.co.senab.photoview.PhotoView</span></span></div><div class="line">                <span class="attr">android:id</span>=<span class="string">"@+id/pv_show_image"</span></div><div class="line">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">                <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">                <span class="attr">android:background</span>=<span class="string">"@android:color/white"</span></div><div class="line">                <span class="attr">android:src</span>=<span class="string">"@drawable/image_default_rect"</span> /&gt;</div><div class="line">        <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>以上为本次学习内容，如有错误还望指正，谢谢！</p>
<p>文章中 Demo 已经上传在 GitHub上，地址为<a href="https://github.com/yongyu0102/ShowImageFromWebView" target="_blank" rel="external"><strong>ShowImageFromWebView</strong></a></p>
<p>参考文章：</p>
<p> <a href="http://blog.csdn.net/swingpyzf/article/details/16338903" target="_blank" rel="external">JAVA抓取网页的图片,JAVA利用正则表达式抓取网站图片</a></p>
<p><a href="http://blog.csdn.net/wangtingshuai/article/details/8635787" target="_blank" rel="external">android webview js交互， 响应webview中的图片点击事件</a></p>
<p><a href="http://www.jianshu.com/p/e24ee6d67f01" target="_blank" rel="external">从WebView中点击一张图片，转换成一个可缩放，可旋转的图片</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/24/show_image_from_webView/" data-id="civnx6lm80000v0q7limbymor" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-WebView/">Android WebView</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-view_layout_and_draw" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/05/view_layout_and_draw/" class="article-date">
  <time datetime="2016-10-04T16:00:00.000Z" itemprop="datePublished">2016-10-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-View/">Android View</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/05/view_layout_and_draw/">View 的工作原理下 View 的 layout 和 draw 过程 （Android 开发艺术探索读书笔记）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>-文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</p>
<ul>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://github.com/yongyu0102" target="_blank" rel="external">yongyu0102</a></li>
<li>审阅者：<a href="https://github.com/melodyxxx" target="_blank" rel="external">melodyxxx</a></li>
</ul>
</blockquote>
<h1 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h1><p>本次介绍的主要内容是 View 的工作原理下 View 的 layout 和 draw 过程，同时介绍自定义 View 的注意事项并结合一个小的 Demo 进行说明，其中涉及到的 onMeasre  测量部分知识可以看上一篇文章<a href="http://yongyu.itscoder.com/2016/09/11/view_measure/" target="_blank" rel="external">View 的工作原理上 View 绘制流程梳理及 Measure 过程详解</a> ，以下开始正文：</p>
<h1 id="二、-layout-过程详解"><a href="#二、-layout-过程详解" class="headerlink" title="二、 layout 过程详解"></a>二、 layout 过程详解</h1><p> layout 的作用是 ViewGroup 来确定子元素的位置，当 ViewGroup 的位置被确定后，在  layout 中会调用 onLayout ，在 onLayout 中会遍历所有的子元素并调用子元素的 layout 方法，在子元素的 layout 方法中 onLayout 方法又会被调用，layout 方法是确定 View 本身在屏幕上显示的具体位置，即在代码中设置其成员变量 mLeft，mTop，mRight，mBottom 的值，这几个值是在屏幕上构成矩形区域的四个坐标点，就是该 View 显示的位置，不过这里的具体位置都是相对与父视图的位置而言，而 onLayout 方法则会确定所有子元素位置，ViewGroup 在 onLayout 函数中通过调用其 children 的 layout 函数来设置子视图相对与父视图中的位置，具体位置由函数 layout 的参数决定。下面我们先看 View 的layout 方法如下：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/* </span></div><div class="line"> *@param l view 左边缘相对于父布局左边缘距离</div><div class="line"> *@param t view 上边缘相对于父布局上边缘位置</div><div class="line"> *@param r view 右边缘相对于父布局左边缘距离</div><div class="line"> *@param b view 下边缘相对于父布局上边缘距离</div><div class="line"> */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line"> <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">      onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">      mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//记录 view 原始位置</span></div><div class="line">  <span class="keyword">int</span> oldL = mLeft;</div><div class="line">  <span class="keyword">int</span> oldT = mTop;</div><div class="line">  <span class="keyword">int</span> oldB = mBottom;</div><div class="line">  <span class="keyword">int</span> oldR = mRight;</div><div class="line"><span class="comment">//第1步，调用 setFrame 方法 设置新的 mLeft、mTop、mBottom、mRight 值，</span></div><div class="line"><span class="comment">//设置 View 本身四个顶点位置</span></div><div class="line"><span class="comment">//并返回 changed 用于判断 view 布局是否改变</span></div><div class="line">  <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">          setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line">             <span class="comment">//第二步，如果 view 位置改变那么调用 onLayout 方法设置子 view 位置</span></div><div class="line">             <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">    <span class="comment">//调用 onLayout</span></div><div class="line">      onLayout(changed, l, t, r, b);</div><div class="line">      mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line">      ListenerInfo li = mListenerInfo;</div><div class="line">      <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">          ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                  (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">          <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">              listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p> layout 方法大致流程：先通过上面代码第一步调用  setFrame 设置 view 本身四个顶点位置，其中 setOpticalFrame 内部也是调用 setFrame  方法来完成设置的，即为 View 的4个成员变量（mLeft，mTop，mRight，mBottom）赋值，View 的四个顶点一旦确定，那么 View 在父容器中的位置就确定了，接着进行第二步，调用 onLayout 方法，这个方法用途是父容器确定子 View 位置，和 onMeasure 方法类似， onLayout 方法的具体实现同样和具体布局有关，所以 View 和 ViewGroup 中都没有真正实现 onLayout 方法，都是一个空方法。</p>
<p>   先看一下 View 的 onLayout 方法：</p>
 <figure class="highlight plain"><figcaption><span>void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125;```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   那么对于我们自定义的 View 是继承自 View 的情况下，我们一般不需要重写 onLayout 方法，因为 这个方法用途是父容器确定子 View 位置，对于 View 来说是没有子 View 的，所以一般不需要重写。</div><div class="line"></div><div class="line">   再看一下 ViewGroup 的 onLayout 方法：</div><div class="line"></div><div class="line">```java</div><div class="line">protected abstract void onLayout(boolean changed,</div><div class="line">           int l, int t, int r, int b);</div></pre></td></tr></table></figure>
<p>   相对于 view 来说，ViewGroup 中 onLayout 多了关键字abstract的修饰，也就说对于继承自 ViewGroup 的自定义 View 必须要重写 onLayout 方法，而重载 onLayout 的目的就是安排其子元素在父视图中的具体位置，为了更好的理解，接下来我们看一下 LinearLayout  的 onLayout 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">        layoutVertical(l, t, r, b);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        layoutHorizontal(l, t, r, b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   和 onMeasure 类似，这里也是分为竖直方向和水平方向的布局安排，二者原理一样，我们选择竖直方向的 layoutVertical 来进行分析，这里给出主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = mPaddingLeft;</div><div class="line">  <span class="comment">//记录子 View 上边缘相对于父容器上边缘距离</span></div><div class="line">    <span class="keyword">int</span> childTop;</div><div class="line">    <span class="comment">//记录子 View 左边缘相对于父容器左边缘距离</span></div><div class="line">    <span class="keyword">int</span> childLeft;</div><div class="line">  <span class="comment">//第1步，主要是根据不同的 gravity 属性来确定子元素的 child 的位置</span></div><div class="line">    <span class="keyword">switch</span> (majorGravity) &#123;</div><div class="line">           <span class="keyword">case</span> Gravity.BOTTOM:</div><div class="line">               <span class="comment">// mTotalLength contains the padding already</span></div><div class="line">               childTop = mPaddingTop + bottom - top - mTotalLength;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">               <span class="comment">// mTotalLength contains the padding already</span></div><div class="line">           <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</div><div class="line">               childTop = mPaddingTop + (bottom - top - mTotalLength) / <span class="number">2</span>;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line"></div><div class="line">           <span class="keyword">case</span> Gravity.TOP:</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               childTop = mPaddingTop;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">   ...............................</div><div class="line"><span class="comment">//第2步，循环遍历子 view </span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">      <span class="comment">//获取指定位置 view </span></div><div class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">            childTop += measureNullChild(i);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</div><div class="line">          <span class="comment">//第2.1步，如果 view 可见，获取 view  的测量宽/高</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line">            <span class="comment">//获取 view  的 LayoutParams 参数</span></div><div class="line">            <span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">                    (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">        .............</div><div class="line">            <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">                childTop += mDividerHeight;</div><div class="line">            &#125;</div><div class="line">			</div><div class="line">            childTop += lp.topMargin;</div><div class="line">          <span class="comment">//第3步，设置子 view 位置</span></div><div class="line">            setChildFrame(child, childLeft, childTop + getLocationOffset(child),</div><div class="line">                    childWidth, childHeight);</div><div class="line">          <span class="comment">//第4步，重新计算子 view 的 顶部 top 位置，也就是每增加一个子 view </span></div><div class="line">          <span class="comment">//下一个子 view 的 top 顶部位置就会相应的增加</span></div><div class="line">            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</div><div class="line">            i += getChildrenSkipCount(child, i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  简单梳理下整个流程，此方法会遍历所有子 view ，并调用 setChildFrame 方法来设定子元素位置，然后重新计算 childTop ，childTop  随着子元素的遍历而逐渐增大，这就意味着后面的子元素会被放置在当前子元素的下方，这正是我们平时使用竖直方向 LinearLayout 的特性。这里我们看一下第三步执行的 setChildFrame 方法类设置子元素位置方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChildFrame</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;        </div><div class="line">    child.layout(left, top, left + width, top + height);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，这个方法只是调用子元素的 layout 方法而已，这样父元素在自己的 layout 方法中完成自己的定位之后，通过 onLayout 方法去调用了子元素的 layout 方法，子元素又会通过自己的 layout 方法完成自己的位置设定，这样一层一层的传递下去就完成了整个 view 数的 layout 过程。</p>
<p>这里我们注意到在第三步调用 setChildFrame 方法中的 传入的参数 childWidth 和 childHeight 是上面第2.1步获取的子元素的测量宽/高，而在 layout 过程中会通过 setFrame 方法设置子元素四个顶点位置，这样子元素的位置就确定了，在 setFrame 中有如下赋值语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mLeft = left;</div><div class="line">mTop = top;</div><div class="line">mRight = right;</div><div class="line">mBottom = bottom;</div></pre></td></tr></table></figure>
<p>也就是说在 LinearLayout 中其子视图显示的宽和高由 measure 过程来决定的，因此 measure 过程的意义就是为 layout 过程提供视图显示范围的参考值。为什么说是提供参考值呢？因为 layout 过程中的4个参数  left,  top, iwidth, height 完全可以由视图设计者任意指定，而最终视图的布局位置和大小完全由这4个参数决定，measure 过程得到的mMeasuredWidth 和 mMeasuredHeight 提供了视图大小的测量值，只是提供一个参考一般情况下我们使用这个参考值，但我们完全可以不使用这两个值，而自己在 layout 过程中去设定一个值，可见 measure 过程并不是必须的。</p>
<p>说到这里就不得说一下 getWidth() 、getHeight() 和 getMeasuredWidth()、getMeasuredHeight() 这两对函数之间的区别，即 View 的测量宽/高和最终显示宽/高之间的区别。首先我们看一下 getWith() 和 getHeight() 方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mRight - mLeft;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mBottom - mTop;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过 getWith() 和 getHeight() 源码和上面 setChildFrame(View child, int left, int top, int width, int height) 方法设置子元素四个顶点位置的四个变量 mLeft、mTop、mRight、mBottom 的赋值过程来看，默认情况下 getWidth() 、getHeight() 方法返回的值正好就是 view 的测量宽/高，只不过 view 的测量宽/高形成于 view 的measure 过程，而最终宽/高形成于 view 的 layout 方法中，但是对于特殊情况，两者的值是不相等的，就是我们在 layout 过程中不按默认常规套路出牌，即不使用 measure 过程得到的 mMeasuredWidth 和 mMeasuredHeight ，而是人为的去自己根据需要设定的一个值的情况，例如以下代码，重写 view 的 layout 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">  <span class="comment">//在得到的测量值基础上加100</span></div><div class="line">    <span class="keyword">super</span>.layout(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r+<span class="number">100</span>, <span class="keyword">int</span> b+<span class="number">100</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面代码会导致在任何情况下 view 的最终宽/高总会比测量宽高大100px。</p>
<h1 id="三、-draw-过程详解"><a href="#三、-draw-过程详解" class="headerlink" title="三、 draw 过程详解"></a>三、 draw 过程详解</h1><p>draw 的作用是将 view 绘制到屏幕上，view 的绘制过程准守以下几个步骤：</p>
<ol>
<li>绘制背景：<code>background.draw(canvas)</code>；</li>
<li>绘制自己：<code>onDraw()</code>；</li>
<li>绘制 children：<code>dispatchDraw</code>；</li>
<li><p>绘制装饰：<code>onDrawScrollBars</code>。</p>
<p>通过源码可以看出来，部分源码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Draw traversal performs several drawing steps which must be executed</div><div class="line">     * in the appropriate order:</div><div class="line">     *</div><div class="line">     *      1. Draw the background</div><div class="line">     *      2. If necessary, save the canvas' layers to prepare for fading</div><div class="line">     *      3. Draw view's content</div><div class="line">     *      4. Draw children</div><div class="line">     *      5. If necessary, draw the fading edges and restore layers</div><div class="line">     *      6. Draw decorations (scrollbars for instance)</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="comment">// Step 1, draw the background, if needed</span></div><div class="line">  <span class="comment">//绘制背景</span></div><div class="line">    <span class="keyword">int</span> saveCount;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</div><div class="line">        drawBackground(canvas);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class="line">        <span class="comment">// Step 3, draw the content</span></div><div class="line">      <span class="comment">//调用 onDraw 方法，绘制自己本身内容，这个方法是个空方法，没有具体实现，</span></div><div class="line">      <span class="comment">//因为每个视图的内容部分肯定都是各不相同的，这部分的功能交给子类来去实现，</span></div><div class="line">      <span class="comment">//如果要自定义 view ，需要重载该方法完成绘制工作</span></div><div class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</div><div class="line"></div><div class="line">        <span class="comment">// Step 4, draw the children</span></div><div class="line">      <span class="comment">//绘制子视图</span></div><div class="line">      <span class="comment">//View 中的 dispatchDraw()方法也是一个空方法，因为 view 本身没有子视图，所以不需要，</span></div><div class="line">      <span class="comment">//而 ViewGroup 的 dispatchDraw() 方法中就会有具体的绘制代码，来实现子视图的绘制工作</span></div><div class="line">        dispatchDraw(canvas);</div><div class="line"></div><div class="line">        <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></div><div class="line">        <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></div><div class="line">      <span class="comment">//绘制装饰</span></div><div class="line">      <span class="comment">//对视图的滚动条进行绘制，其实任何一个视图都是有滚动条的，只是一般情况下都没有让它显示出来，</span></div><div class="line">      <span class="comment">//而例如像 ListView 等控件是进行了显示而已。</span></div><div class="line">        onDrawForeground(canvas);</div><div class="line"></div><div class="line">        <span class="comment">// we're done...</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过上面代码可以发现，View 绘制过程的传递是通过 dispatchDraw() 方法完成，这个方法会遍历调用所有子视图的 draw ()方法，这样事件就一层一层的传递下去了。其中 View 中有一个特殊方法 setWillNotDraw ，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * If this view doesn't do any drawing on its own, set this flag to</div><div class="line"> * allow further optimizations. By default, this flag is not set on</div><div class="line"> * View, but could be set on some View subclasses such as ViewGroup.</div><div class="line"> *</div><div class="line"> * Typically, if you override &#123;<span class="doctag">@link</span> #onDraw(android.graphics.Canvas)&#125;</div><div class="line"> * you should clear this flag.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> willNotDraw whether or not this View draw on its own</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;</div><div class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看注释部分大概意思是，如果一个 View 不需要绘制任何内容，那么设置这个标记位为 true 后，系统会进行相应的优化，默认情况下 View 没有启动这个默认标记位，但 viewGroup 默认启用这个标记位，这个标记位对实际开发的意义是：当我们的自定义的控件继承自 viewGroup 并且本身不具备绘制功能的时候，就可以开启这个标记位，从而便于系统进行后续的优化工作，当我们明确知道 viewGrop 需要通过 onDraw 来绘制本身内容时，需要我们去关闭 WILL_NOT_DRAW 这个标记位。</p>
<h1 id="四、自定义-View"><a href="#四、自定义-View" class="headerlink" title="四、自定义 View"></a>四、自定义 View</h1><h2 id="4-1-自定义-View-分类"><a href="#4-1-自定义-View-分类" class="headerlink" title="4.1 自定义 View 分类"></a>4.1 自定义 View 分类</h2><ol>
<li><p><strong>继承自 View 重写 ondraw 方法</strong> </p>
<p>这种方法主要用于实现一些不规则的效果，即想要达到的 View 效果无法使用已有的 View 通过布局组合的方式来实现，所以需要我们自己去绘制去画一个出来，即重写 onDraw 方法，采用这种方式需要注意处理自定义的 View 支持 wrap_content ，并且 padding 也需要自己处理。</p>
</li>
<li><p><strong>继承自 ViewGroup 实现特殊的 Layout 容器</strong></p>
<p>主要实现除了 LinearLayout 、 RelativeLayout  等系统已有的 View 容器之外的特殊 View 容器，需要处理 ViewGroup 的测量 onMeasure 和布局 onLayout 这两个方法，并同时处理子元素的测量和布局。</p>
</li>
<li><p><strong>继承自 Android 系统本身已有的特定 View （如 TextView）</strong></p>
<p>这种方法是要是为拓展某个已有 View 的功能，在已有的 View 的基础上添加一些功能，方便我们重复使用，这种方法不需要我们进行特殊的处理。</p>
</li>
<li><p><strong>继承自 Android 系统本身已有的特定的 ViewGroup （如 LinearLayout)</strong></p>
<p>这种方法主要是为了实现将几个 View 组合在一起形成一个特定的组合模块，来方便我们后续进行使用，例如我们想要一个特定的 TitleBar ，我们可以可以将几个 TextView 和 Button 放在一个 LinearLayout 布局中组合成一个自定义的控件，采用这种方式不需要进行特殊的处理。</p>
</li>
</ol>
<h2 id="4-2-自定义-View-须知"><a href="#4-2-自定义-View-须知" class="headerlink" title="4.2 自定义 View 须知"></a>4.2 自定义 View 须知</h2><p>自定义 View 过程中需要注意一些事项，如果这些问题处理不好，可能会影响 View 的正常使用和性能。</p>
<ol>
<li><p><strong>让 View 支持 wrap_content</strong> </p>
<p>在自定义 View 时，如果是直接继承自 View 或者 View Group ，并且不在 onMeasure 中对 wrap_content 做特殊处理，那么在我们使用这个自定义的 View  的 wrap_content 属性时，就无法达到预期效果，而是和使用 match_parent 属性效果一样。</p>
</li>
<li><p><strong>如果有必要，让自定义的 View 支持 padding 属性</strong></p>
<p>在自定义 View 时，如果是直接继承自 View  ，不在 onDraw 方法中处理 padding ，那么该自定义的 View padding属性将失效；如果是直接继承自 ViewGrop 需要在 onMeasure 和 onLayout 中考虑 padding 和 margin 对其造成的影响，否则将导致自定义的控件 padding 和子元素的 margin 属性失效。</p>
</li>
<li><p><strong>尽量不要在 View 中使用 Handler ，没必要</strong></p>
<p>View 本身内部提供了一些列的 post 方法，完全可以替代 Handler 作用。</p>
</li>
<li><p><strong>View 中如果有线程或者动画需要在特定生命周期进行停止</strong></p>
<p>当包含此 View 的 Activity 退出或者当前 View 被 remove 掉时，View 的 onDetachedFromWindow() 方法会被调用，所以如果有需要停止的线程或者动画可以在这个方法中执行，和此方法相对应的是 onAttachedToWindow() 方法，当包含该 View 的 Activity 启动的时候，该方法就会被调用。同时当 View 变得不可见时，我们需要及时停止线程和动画，否则可能造成内存泄露。</p>
</li>
<li><p><strong>View 带有滑动嵌套情形时，需要处理好滑动冲突</strong></p>
<p>如果有滑动冲突需要合适的进行处理。如果要处理好滑动处理可以看一下<a href="http://yongyu.itscoder.com/2016/08/28/view_touchEvent_dispatch/" target="_blank" rel="external">View 事件的分发机制</a></p>
</li>
</ol>
<h2 id="4-3-自定义-View-示例"><a href="#4-3-自定义-View-示例" class="headerlink" title="4.3 自定义 View 示例"></a>4.3 自定义 View 示例</h2><h3 id="4-3-1-继承自-View-重写-onDraw-方法"><a href="#4-3-1-继承自-View-重写-onDraw-方法" class="headerlink" title="4.3.1 继承自 View 重写 onDraw 方法"></a>4.3.1 继承自 View 重写 onDraw 方法</h3><p>这种方法一般为了实现一些不规则的效果，需要我们自己去绘制去画一个出来 View 出来，即重写 onDraw 方法，采用这种方式需要考虑 View 四周的空白即处理 padding 值，而 margin 值是受父容器控制所以不需要进行处理，并且需要注意处理自定义的 View 支持 wrap_content ，即重写 onMeasure 方法，如果不进行处理那么当在 xml 文件中使用 wrap_content 属性的时候，就相当于 match_parent 属性，这里为了更详细的说明问题，我们一起来实现一个简单的自定义 View ，只简单的画一个圆出来，这里给出关键地方的代码，先看看 onMeasure 部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 这里进行重写 onMeasure 方法，让自定义的 View 支持 Wrap_content 模式</div><div class="line"> * 当使用该自定义的 View 时候，如果使用了 Wrap_content 属性后</div><div class="line"> * 该 View  的宽和高都为 200dp ，这个尺寸在实际应用中需要根据具体需要和情况进行计算</div><div class="line"> * 这里只是为了解释这个原理，任意给定了一个值恰巧是 200dp 而已</div><div class="line"> * <span class="doctag">@param</span> widthMeasureSpec 父容器给定的宽度约束条件</div><div class="line"> * <span class="doctag">@param</span> heightMeasureSpec 父容器给定的高度约束条件</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    <span class="comment">// 在 xml 文件中使用 wrap_content 属性时，该 View 的默认宽/高值为 200dp</span></div><div class="line">    <span class="keyword">int</span> width=<span class="number">200</span>;</div><div class="line">    <span class="keyword">int</span> height=<span class="number">200</span>;</div><div class="line">  <span class="comment">//获取测量值和模式</span></div><div class="line">    <span class="keyword">int</span> widthMode=MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> heightMode=MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">    <span class="keyword">int</span> withSize=MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> heightSize=MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">    <span class="keyword">if</span>(widthMode==MeasureSpec.AT_MOST&amp;&amp;heightMode==MeasureSpec.AT_MOST)&#123;</div><div class="line">        <span class="comment">//宽和高都为 wap_content 模式，进行设定默认值</span></div><div class="line">        setMeasuredDimension(width,height);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(widthMode==MeasureSpec.AT_MOST)&#123;</div><div class="line">        <span class="comment">//如果只有宽为 wrap_content 模式</span></div><div class="line">        setMeasuredDimension(width,heightSize);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(heightMode==MeasureSpec.AT_MOST)&#123;</div><div class="line">        <span class="comment">//如果只有高为 wrap_content 模式</span></div><div class="line">        setMeasuredDimension(withSize,height);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码就解决了让 自定义的 View 支持 wrap_content 的问题。下面在看看在 onDraw 方法中进行绘制的时候处理  padding 值的问题，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 这里进行绘制 View 的内容，这里要注意需要处理 padding 值，</div><div class="line"> * 让自定义的 View 支持 padding 属性，如果不处理，</div><div class="line"> *那么在 xml 文件中使用该自定义的 View 的 padding</div><div class="line"> * 属性时候，将会失效</div><div class="line"> * <span class="doctag">@param</span> canvas 画布</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">    <span class="comment">//获取 view 最终宽和高</span></div><div class="line">    <span class="keyword">int</span> width=getWidth();</div><div class="line">    <span class="keyword">int</span> height=getHeight();</div><div class="line">    <span class="comment">//获取 padding 值</span></div><div class="line">    <span class="keyword">int</span> paddingLeft=getPaddingLeft();</div><div class="line">    <span class="keyword">int</span> paddingRight=getPaddingRight();</div><div class="line">    <span class="keyword">int</span> paddingTop=getPaddingTop();</div><div class="line">    <span class="keyword">int</span> paddingBottom=getPaddingBottom();</div><div class="line">    <span class="comment">//计算去掉 padding 的宽和高</span></div><div class="line">    <span class="keyword">int</span> withFinal=width-paddingLeft-paddingRight;</div><div class="line">    <span class="keyword">int</span> heightFinal=height-paddingTop-paddingBottom;</div><div class="line">    <span class="comment">//计算半径</span></div><div class="line">    <span class="keyword">int</span> radius=Math.min(withFinal/<span class="number">2</span>,heightFinal/<span class="number">2</span>);</div><div class="line">    <span class="comment">//绘制视图内容</span></div><div class="line">    <span class="comment">//确定x轴和y轴圆中心点位置，主要受 paddingLeft 和 withFinal/2 影响</span></div><div class="line">    <span class="comment">//即受左上方侧偏移量和圆半径有关，与 RightPadding 无关</span></div><div class="line">    canvas.drawCircle(paddingLeft+withFinal/<span class="number">2</span>,paddingTop+heightFinal/<span class="number">2</span>,radius,paint);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码解决了让自定义的 View 支持 padding 属性。</p>
<h3 id="4-3-2-继承自-ViewGroup-实现特殊的-Layout-容器"><a href="#4-3-2-继承自-ViewGroup-实现特殊的-Layout-容器" class="headerlink" title="4.3.2 继承自 ViewGroup  实现特殊的 Layout 容器"></a>4.3.2 继承自 ViewGroup  实现特殊的 Layout 容器</h3><p>这种自定义的 ViewGroup 需要处理 onMeasure 测量和 onLayout 布局两个过程，同时需要处理子元素的测量和布局过程。采用这种方法实现一个规范的自定义 View 是相当复杂的，通过前面分析的 LinearLayout 代码就可以发现，因为要考虑如何摆放子视图以及各种细节的处理，Android 开发艺术探索书中给出了一个相对规范（不完全规范）的自定义的 HorizontalScrollViewEx 视图容器，实现了一个类似 ViewPaper 的控件，内部子视图可以水平方向滑动，并且子视图的内部子元素可以实现竖直方向滑动，很显然这个控件解决了水平方向和竖直方向滑动冲突的问题，该部分知识可以看一下<a href="http://yongyu.itscoder.com/2016/08/28/view_touchEvent_dispatch/" target="_blank" rel="external">View 的事件分发机制（Android 开发艺术探索读书笔记）</a> 这篇文章从源码角度分析了事件分发机制，理解了就可以解决滑动冲突的问题。下面一起看一下关键部分代码，先看 onMeasure 部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 重写 onMeasure 方法，处理自定义 View 支持 wrap_content 模式</div><div class="line"> * <span class="doctag">@param</span> widthMeasureSpec 父容器给定宽度约束条件</div><div class="line"> * <span class="doctag">@param</span> heightMeasureSpec 父容器给定高度约束条件</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    <span class="keyword">int</span> measuredWidth = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> measuredHeight = <span class="number">0</span>;</div><div class="line">    <span class="comment">//获取子视图个数</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">    <span class="comment">//测量子视图</span></div><div class="line">    measureChildren(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    <span class="comment">//获取父容器给定测量模式和测量值</span></div><div class="line">    <span class="keyword">int</span> widthSpaceSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> heightSpaceSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">    <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">    <span class="keyword">if</span> (childCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//如果没有子视图直接设定 View 的宽/高为0</span></div><div class="line">        setMeasuredDimension(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        <span class="comment">//如果视图宽/高都采用 wrap_content 模式</span></div><div class="line">        <span class="keyword">final</span> View childView = getChildAt(<span class="number">0</span>);</div><div class="line">        <span class="comment">//宽度为第一个视图宽度乘以所有子视图个数</span></div><div class="line">        measuredWidth = childView.getMeasuredWidth() * childCount;</div><div class="line">       <span class="comment">// 高度为第一个视图宽度</span></div><div class="line">        measuredHeight = childView.getMeasuredHeight();</div><div class="line">        <span class="comment">//设置 自定义视图宽/高值</span></div><div class="line">        setMeasuredDimension(measuredWidth, measuredHeight);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        <span class="comment">//如果只有视图高采用 wrap_content 模式</span></div><div class="line">        <span class="keyword">final</span> View childView = getChildAt(<span class="number">0</span>);</div><div class="line">        <span class="comment">//设置视图高度为第一个视图高度</span></div><div class="line">        measuredHeight = childView.getMeasuredHeight();</div><div class="line">        setMeasuredDimension(widthSpaceSize, childView.getMeasuredHeight());</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        <span class="comment">//如果视图宽度使用 wrap_content 模式，设置宽度为第一个视图宽度乘以所有子视图个数</span></div><div class="line">        <span class="keyword">final</span> View childView = getChildAt(<span class="number">0</span>);</div><div class="line">        measuredWidth = childView.getMeasuredWidth() * childCount;</div><div class="line">        setMeasuredDimension(measuredWidth, heightSpaceSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码实现了让自定义的 View 支持  wrap_content 属性。</p>
<p><strong>说明，这里为了方便处理有几处不规范的地方如下：</strong></p>
<ol>
<li>假设了所有子视图的高度和宽度都相等，而实际应用中这是不可能的，所以计算起来会更复杂。</li>
<li>没有子元素的时候不应该直接设置宽/高为 0，而是应该根据 LayoutParams 的宽/高来做相应的处理，因为当使用 padding 属性的时候，虽然没有子视图，但 padding 值也会占据一定空间，你可以设置 LinearLayout 子视图个数为 0，然后给定一个 padding 值去试试。</li>
<li>在测量 HorizontalScrollViewEx  的高/宽的时候没有考虑它的 padding 值和子视图的 margin 值，因为自己的 padding 值和子视图的 margin 值都是占据空间的。</li>
</ol>
<p>下面再看一下 onLayout 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 重写 onLayout 方法，实现摆放子视图功能</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="comment">//记录子视图左边距位置</span></div><div class="line">    <span class="keyword">int</span> childLeft = <span class="number">0</span>;</div><div class="line">    <span class="comment">//获取子视图个数</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">    <span class="comment">//记录子视图个数</span></div><div class="line">    mChildrenSize = childCount;</div><div class="line">    <span class="comment">//遍历子视图</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">        <span class="comment">//获取子视图</span></div><div class="line">        <span class="keyword">final</span> View childView = getChildAt(i);</div><div class="line">        <span class="keyword">if</span> (childView.getVisibility() != View.GONE) &#123;</div><div class="line">            <span class="comment">//如果子视图可见，获取子视图测量宽度</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidth = childView.getMeasuredWidth();</div><div class="line">            <span class="comment">//记录子视图宽度</span></div><div class="line">            mChildWidth = childWidth;</div><div class="line">            <span class="comment">//设置摆放子视图位置，每次子视图放置在上一个子视图右边依次排放</span></div><div class="line">            childView.layout(childLeft, <span class="number">0</span>, childLeft + childWidth,</div><div class="line">                    childView.getMeasuredHeight());</div><div class="line">            childLeft += childWidth;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码实现了摆放子视图的功能，从代码可以看出放置子视图是从左至右依次摆放。</p>
<p><strong>说明，以上代码不规范之处：</strong></p>
<p>在摆放子视图的过程中，没有考虑自身的 padding 和子视图的 margin 值。</p>
<h3 id="4-3-3-自定义-View-的总结"><a href="#4-3-3-自定义-View-的总结" class="headerlink" title="4.3.3 自定义 View 的总结"></a>4.3.3 自定义 View 的总结</h3><p>到这里，关于 View 的基础知识基本学习完毕，笔者写到这里也完全不能写出了一个牛逼的自定义控件（一个基友曾经这样问我：你学完了这些知识，还不徒手撸出一个牛逼的自定义 View 啊——–<a href="http://extremej.itscoder.com/" target="_blank" rel="external">阿风</a> ，我的回答当然不能。因为自定义 View 是一个综合的知识体系，需要灵活的运用各种知识和经验，这里我们只是学习了一下基础理论知识，知其原理，懂其思路，如果我们想自定义 View，首先要掌握基本功，比如 <a href="http://yongyu.itscoder.com/2016/08/14/view_to_scroll/" target="_blank" rel="external">View 的弹性滑动</a>，<a href="http://yongyu.itscoder.com/2016/08/28/view_touchEvent_dispatch/" target="_blank" rel="external">滑动冲突</a>，绘制原理等，这些都是自定义 View 所必须知识点，再复杂的自定义 View 也是离不开这些知识点，尤其是那些看起来很炫酷的自定义 View，往往对这些技术点要求更高，只有熟悉掌握这些基础知识点以后，在面对新的自定义 View 时，才能够根据需求情况选择合适的实现思路，实现大体方法就是 4.1 节中介绍的四种分类，另外还需要学习一下 Canvas 这个类的用法才能画出想要的 View 。</p>
<p>最后，文章中的 Demo 会上传在 github，<a href="https://github.com/yongyu0102/ViewDrawDemo" target="_blank" rel="external">链接地址</a> ，这里只是一个简单的 Demo ，分析一下原理，（这些 Demo 源码出自 Android 开发艺术探索）如果想撸出更炫酷的 View 还需要掌握 Canvas 这个类的用法，后面需要续学习。</p>
<p>以上就是本次的笔记内容，如有错误，希望指出，谢谢！！！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/05/view_layout_and_draw/" data-id="civnx6lmm0005v0q7i6vkya1i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-View/">Android View</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-view_measure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/11/view_measure/" class="article-date">
  <time datetime="2016-09-10T16:00:00.000Z" itemprop="datePublished">2016-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-View/">Android View</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/11/view_measure/">View 的工作原理上 View 绘制流程梳理及 Measure 过程详解（Android 开发艺术探索笔记）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>-文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</p>
<ul>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://github.com/yongyu0102" target="_blank" rel="external">yongyu0102</a></li>
<li>审阅者：<a href="https://github.com/hymanme" target="_blank" rel="external">hymane</a></li>
</ul>
</blockquote>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>View 是 Android 中所有控件的基类，例如 Button 和 TextView、ViewGroup 等常见控件他们的基类都是 View，View 是一种界面层的控件的一种抽象，代表了一个控件。View 本身可以是单个控件也可以是由多个控件组成的一组控件，通过这种关系就形成了 View 树的结构。Android 系统本身就提供好了很多好用的 View，你也可以自己根据需求去自定义一个 View，拿最简单的一个例子来说，当我们想在界面上显示一行文字的时候，我们会在 xml 文件中写好布局然后在  Activity 中的 onCreate 方法中使用 setContentView 方法来加载布局就可以显示出我们想要的文字，这时候你是否有思考过这个过程是怎么完成的， View 是如何被显示到界面上的；还有一个我们经常遇到的问题是：当我们在一个 ScrollView 控件内部嵌套一个 ListView 的时候 ListView 只会显示一行；当使用自定义的 View 的时候，View 可以显示到界面，但是当使用 WrapContent 属性的时候不起作用，这些问题笔者就曾都遇到过，如果你也曾有过这样的疑问，可以阅读以下这篇文章。</p>
<h2 id="1-1-主要内容简介"><a href="#1-1-主要内容简介" class="headerlink" title="1.1 主要内容简介"></a>1.1 主要内容简介</h2><p>View 的工作原理主要包含 View 的三大流程 onMeasure()、onLayout()和onDraw()  ，而由于一次性全部写完内容会有点长，所以本次主要先介绍关于 View 的工作流程的整体梳理和 Measure 过程相关知识，而下一篇笔记会把剩下的部分写完。</p>
<h1 id="2-初识-ViewRoot-和-DecorView"><a href="#2-初识-ViewRoot-和-DecorView" class="headerlink" title="2 初识 ViewRoot 和 DecorView"></a>2 初识 ViewRoot 和 DecorView</h1><p>在正式介绍 View 的三大流程 onMeasure()、onLayout()和onDraw() 之前，先简单介绍一下当我们在 Activity 方法 onCreate 里执行 setContentView 之后 View 是如何显示到屏幕上的，这里我们就不分析源码过程了，因为这个过程不是我们要分析的重点，只是辅助我们去理解，有助于我们对整个流程有更好的理解和把握。</p>
<p>当调用 Activity 的  setContentView 方法后会调用  PhoneWindow 类 的 setContentView  方法，PhoneWindow 类是抽象类Window的实现类，Window 类用来描述 Activity 视图最顶端的窗口显示和行为操作，PhoneWindow 类 的 setContentView  方法中最终会 生成一个 DecorView 对象，DecorView 是 PhoneWindow类的内部类，继承自FrameLayout ，所以调用 Activity 方法 setContetnView 后最终会生成一个 FrameLayout 类型的 DecorView 组件，该组件将作为整个应用窗口的顶层图，然后在 DecorView 容器中添加根布局，根布局中包含一个 id 为 contnet 的 FrameLayout 内容布局，我们的 Activity 加载的布局 xml 最后通过LayoutInflater 将 xml 内容布局解析成 View 树形结构，最后添加到 id 为 content 的 FrameLayout布局当中，至此，View 最终就会显示到手机屏幕上，如果想详细了解出门右转<a href="http://blog.csdn.net/feiduclear_up/article/details/46772477" target="_blank" rel="external">从ViewRootImpl类分析View绘制的流程——废墟的树</a>。整理流程梳理可以参考下面这张图片：</p>
<p>​                   <img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/decorView_view.png?raw=true" alt="decorView_view"></p>
<p>我们了解了上面得到流程后下面梳理一下如何进入到 view 的绘制流程：</p>
<p>ViewRoot 对应的实现类是 ViewRootImpl 类，他是连接 WindowManager 和DecorView 的纽带，view 的三大 流程均是通过 ViewRoot 来完成的。在 ActivityThread 中，当 activity 对象被创建完毕后，会将 DecorView 添加到Window 中，同时会创建 ViewRootImpl 对象，并将 ViewRootImpl 对象和 DecorView 建立关联。这个流程可以参考下图，图片来自<a href="http://blog.csdn.net/feiduclear_up/article/details/46772477" target="_blank" rel="external">从ViewRootImpl类分析View绘制的流程——废墟的树</a>：</p>
<p><img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/decorView.png?raw=true" alt="decorView"></p>
<p>View 的绘制流程是从 ViewRoot 的 performTraversals 方法开始的，它经过 measure、layout、draw 三个过程才能最终将一个 View 绘制出来，其中 measure 用来测量 View 的宽和高，layout 用来确定 View 在父容器的放置位置，而 draw 则负责将 View 绘制在屏幕上，参考下图（来源艺术探索截图） ：</p>
<p><img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/view.png?raw=true" alt="view"></p>
<p>performTraversals 会依次调用 performMeasure、performLayout、performDraw 三个方法，这三个方法分别完成顶级 View 的 measure、layout 和 draw 这三大流程，其中 performMeasure 会调用 measure 方法，在measure 方法中又会调用 onMeasure 方法，在 onMeasure 方法中对所有的子元素进行 measure 过程，这个时候 measure 流程就会从父容器传递到子元素中了，这样就完成了一次 measure 过程。接着子元素就会重复父容器的 measure 过程，如此反复就完成了整个 View 树的遍历，同理 perFormLayout 和 performDraw 的流程也是类似。</p>
<p>measure 过程决定了 view 的宽高，在几乎所有的情况下这个宽高都等同于 view 最终的宽高，但特殊情况除外。layout 过程决定了 view 的四个顶点的坐标和 view实 际的宽高，通过 <code>getWidth</code> 和 <code>getHeight</code> 方法可以得到最终的宽高。draw过程决定了view的显示。</p>
<p>DecorView 其实是一个 FrameLayout，其中包含了一个竖直方向的 LinearLayout，上面是标题栏，下面是内容栏(id为<code>android.R.id.content</code>)。</p>
<h1 id="3-理解MeasureSpec"><a href="#3-理解MeasureSpec" class="headerlink" title="3 理解MeasureSpec"></a>3 理解MeasureSpec</h1><p>MeasureSpec  是 View 测量过程中的一个关键参数，很大程度上决定了 View 的宽高，父容器会影响 View 的 MeasureSpec 的创建，MeasureSpec 不是唯一由 LayoutParams 决定的，LayoutParams 需要和父容器一起才能决定 View 的MeasureSpec，从而进一步确定 View 的宽高，在 View 测量过程中，系统会将该 View 的 LayoutParams 参数在父容器的约束下转换成对应的 MeasureSpec ，然后再根据这个 measureSpec 来测量 View 的宽高。</p>
<p>MeasureSpec 代表一个32位 int 值，高2位代表 SpecMode（测量模式），低30位代表 SpecSize（在某个测量模式下的规格大小），MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的内存分配，为了方便操作，其提供了打包和解包方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过将 SpecMode 和 SpecSize 打包，获取 MeasureSpec  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">        <span class="keyword">return</span> size + mode;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//将 MeasureSpec 解包获取 SpecMode</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">        &#125;</div><div class="line"><span class="comment">//将 MeasureSpec 解包获取 SpecSize</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p><strong>SpecMode 有三类，每一类都表示特殊的含义：</strong></p>
<ol>
<li>UNSPECIFIED 父容器不对 View 有任何的限制，要多大给多大，这种情况下一般用于系统内部，表示一种测量的状态。</li>
<li>EXACTLY 父容器已经检测出 View 所需要的精确大小，这个时候 View 的最终大小就是 SpecSize 所指定的值，它对应于LayoutParams 中的 match_parent 和具体的数值这两种模式</li>
<li>AT_MOST 父容器指定了一个可用大小即 SpecSize，View 的大小不能大于这个值，具体是什么值要看不同 View 的具体实现。它对应于 LayoutParams 中的 wrap_content。</li>
</ol>
<h1 id="4-MeasureSpec-和-LayoutParams-的对应关系"><a href="#4-MeasureSpec-和-LayoutParams-的对应关系" class="headerlink" title="4 MeasureSpec 和 LayoutParams 的对应关系"></a>4 MeasureSpec 和 LayoutParams 的对应关系</h1><p><strong>对于DecorView，它的 MeasureSpec 由窗口的尺寸和其自身的 LayoutParams 来决定；对于普通 View，它的MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定。</strong></p>
<p>对普通的 View 的 measure 方法的调用，是由其父容器传递而来的，这里先看一下 ViewGroup 的 measureChildWithMargins 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> * <span class="meta">@param</span> child 要被测量的 View</div><div class="line"> * <span class="meta">@param</span> parentWidthMeasureSpec 父容器的 WidthMeasureSpec</div><div class="line"> * <span class="meta">@param</span> widthUsed 父容器水平方向已经被占用的空间，比如被父容器的其他子 view 所占用的空间</div><div class="line"> * <span class="meta">@param</span> parentHeightMeasureSpec 父容器的 HeightMeasureSpec</div><div class="line"> * <span class="meta">@param</span> heightUsed 父容器竖直已经被占用的空间，比如被父容器的其他子 view 所占用的空间</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">   <span class="comment">//第一步，获取子 View 的 LayoutParams</span></div><div class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">   <span class="comment">//第二步，获取子 view 的 WidthMeasureSpec，其中传入的几个参数说明：</span></div><div class="line">   <span class="comment">//parentWidthMeasureSpec 父容器的 WidthMeasureSpec</span></div><div class="line">   <span class="comment">//mPaddingLeft + mPaddingRight view 本身的 Padding 值，即内边距值</span></div><div class="line">   <span class="comment">//lp.leftMargin + lp.rightMargin view 本身的 Margin 值，即外边距值</span></div><div class="line">   <span class="comment">//widthUsed 父容器已经被占用空间值</span></div><div class="line">   <span class="comment">// lp.width view 本身期望的宽度 with 值</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                    + widthUsed, lp.width);</div><div class="line">     <span class="comment">//获取子 view 的 HeightMeasureSpec</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                    + heightUsed, lp.height);</div><div class="line"><span class="comment">// 第三步，根据获取的子 veiw 的 WidthMeasureSpec 和 HeightMeasureSpec </span></div><div class="line">   <span class="comment">//对子 view 进行测量</span></div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上代码第二步可以看出，子 view 的 MeasureSpec 的创建与父容器的 MeasureSpec 、子 view 本身的 LayoutParams 有关，此外还与 view 本身的 margin 和 padding 值有关，具体看一下 getChildMeasureSpec 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param spec 父容器的 MeasureSpec，是对子 View 的约束条件</div><div class="line">     * @param padding 当前 View 的 padding、margins 和父容器已经被占用空间值</div><div class="line">     * @param childDimension View 期望大小值，即layout文件里设置的大小:可以是MATCH_PARENT,</div><div class="line">     *WRAP_CONTENT或者具体大小, 代码中分别对三种做不同的处理</div><div class="line">     * @return 返回 View 的 MeasureSpec 值</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</div><div class="line">  <span class="comment">// 获取父容器的 specMode，父容器的测量模式影响子 View  的测量模式</span></div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</div><div class="line">         <span class="comment">// 获取父容器的 specSize 尺寸，这个尺寸是父容器用来约束子 View 大小的</span></div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</div><div class="line"><span class="comment">// 父容器尺寸减掉已经被用掉的尺寸</span></div><div class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</div><div class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="comment">// 如果父容器是 EXACTLY 精准测量模式</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        <span class="comment">//如果子 View 期望尺寸为大于 0 的固定值，对应着 xml 文件中给定了 View 的具体尺寸大小</span></div><div class="line">        <span class="comment">//如 android:layout_width="100dp"</span></div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">          <span class="comment">//那么子 View 尺寸为期望值固定尺寸，测量模式为精准测量模式 EXACTLY</span></div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">             <span class="comment">//如果子 View 期望尺寸为 MATCH_PARENT 填充父布局</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            <span class="comment">// 那么子 View 尺寸为 size 最大值，即父容器剩余空间尺寸，为精准测量模式 EXACTLY</span></div><div class="line">          <span class="comment">//即子 View 填的是 Match_parent, 那么父 View 就给子 View 自己的size(去掉padding)，</span></div><div class="line">          <span class="comment">//即剩余全部未占用的尺寸, 然后告诉子 View 这是 Exactly 精准的大小，你就按照这个大小来设定自己的尺寸</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">          <span class="comment">//如果子 View 期望尺寸为 WRAP_CONTENT ，包裹内容</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">          <span class="comment">//子 View 尺寸为 size  最大值，即父容器剩余空间尺寸 ，测量模式为 AT_MOST 最大测量模式</span></div><div class="line">          <span class="comment">//即子 View 填的是 wrap_Content,那么父 View 就告诉子 View 自己的size(去掉padding),</span></div><div class="line">          <span class="comment">//即剩余全部未占用的尺寸,然后告诉子 View, 你最大的尺寸就这么多，不能超过这个值, </span></div><div class="line">          <span class="comment">//具体大小，你自己根据自身情况决定最终大小。一般当我们继承 View 基类进行自定义 View  的时候</span></div><div class="line">          <span class="comment">//需要在这种情况下计算给定 View 一个尺寸，否则当使用自定义的 View 的时候，使用 </span></div><div class="line">          <span class="comment">// android:layout_width="wrap_content" 属性就会失效</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 父容器为 AT_MOST 最大测量模式</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">           <span class="comment">// 子 View 期望尺寸为一个大于 0的具体值，对应着 xml 文件中给定了 View 的具体尺寸大小</span></div><div class="line">        <span class="comment">//如 android:layout_width="100dp"</span></div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">           <span class="comment">//那么子 View 尺寸为期望固定值尺寸，为精准测量模式 EXACTLY</span></div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">          <span class="comment">//如果子 View 期望尺寸为 MATCH_PARENT 最大测量模式</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">             <span class="comment">//子 View 尺寸为 size，测量模式为 AT_MOST  最大测量模式</span></div><div class="line">          <span class="comment">//即如果子 View 是 Match_parent,那么父 View 就会告诉子 View, </span></div><div class="line">          <span class="comment">//你的尺寸最大为 size 这么大（父容器尺寸减掉已经被用掉的尺寸，即父容器剩余未占用尺寸），</span></div><div class="line">          <span class="comment">//你最多有父 View的 size 这么大，不能超过这个尺寸，至于具体多大，你自己根据自身情况决定。</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">             <span class="comment">//同上</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 父容器为 UNSPECIFIED 模式</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">           <span class="comment">// 子 View 期望尺寸为一个大于 0的具体值</span></div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">             <span class="comment">//那么子 View 尺寸为期望值固定尺寸，为精准测量模式 EXACTLY</span></div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">           <span class="comment">//如果子 View 期望尺寸为 MATCH_PARENT 最大测量模式</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">//子 View 尺寸为 0，测量模式为 UNSPECIFIED</span></div><div class="line">           <span class="comment">// 父容器不对 View 有任何的限制，要多大给多大</span></div><div class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">            resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">           <span class="comment">//如果子 View 期望尺寸为 WRAP_CONTENT ，包裹内容</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">             <span class="comment">//子 View 尺寸为 0，测量模式为 UNSPECIFIED</span></div><div class="line">             <span class="comment">// 父容器不对 View 有任何的限制，要多大给多大</span></div><div class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">            resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码主要作用就是根据父容器的  MeasureSpec 和 view 本身的 LayoutParams 来确定子元素的 MeasureSpec 的整个过程，这个过程清楚的展示了普通 view 的 MeasureSpec  的创建规则，整理一下可得到如下表格（来源艺术探索截图）：</p>
<p><img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/mesureSpec.png?raw=true" alt="mesureSpec">总结：</p>
<ol>
<li>当 View 采用固定宽高时，不管父容器的 MeasureSpec 是什么，View 的 MeasureSpec 都是精确模式，并且大小是LayoutParams 中的大小。</li>
<li>当 View 的宽高是 match_parent 时，如果父容器的模式是精确模式，那么 View 也是精确模式，并且大小是父容器的剩余空间；如果父容器是最大模式，那么 View 也是最大模式，并且大小是不会超过父容器的剩余空间。</li>
<li>当 View 的宽高是 wrap_content 时，不管父容器的模式是精确模式还是最大模式，View 的模式总是最大模式，并且大小不超过父容器的剩余空间。</li>
</ol>
<h1 id="5-View-的工作流程"><a href="#5-View-的工作流程" class="headerlink" title="5 View 的工作流程"></a>5 View 的工作流程</h1><p>View 的工作流程主要是指 measure、layout、draw 这三大流程，即测量、布局和绘制，其中 measure 确定 View 的测量宽和高，layout 确定 View  的最终宽和高及 View 的四个顶点位置，而 draw 是将 View 绘制到屏幕上。</p>
<h2 id="5-1-measure-过程"><a href="#5-1-measure-过程" class="headerlink" title="5.1 measure 过程"></a>5.1 measure 过程</h2><p>分两种情况：</p>
<ol>
<li>如果只是一个原始的 View，通过<code>measure</code>方法就完成了测量过程。</li>
<li>如果是一个 ViewGroup 除了完成自己的测量过程还会遍历调用所有子 View 的<code>measure</code>方法，而且各个子 View 还会递归执行这个过程。</li>
</ol>
<h3 id="5-1-1-View-的-measure-过程"><a href="#5-1-1-View-的-measure-过程" class="headerlink" title="5.1.1 View 的 measure 过程"></a>5.1.1 View 的 measure 过程</h3><p>View 的 measure 过程由 <code>measure</code> 方法来完成， <code>measure</code> 方法是一个 final 类型，子类不可以重写，而 View 的 measure() 方法中会调用 onMeasure 方法，因此我们只需要分析 onMeasure  方法即可，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> widthMeasureSpec 父容器所施加的水平方向约束条件</div><div class="line">     * <span class="doctag">@param</span> heightMeasureSpec 父容器所施加的竖直方向约束条件</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">  <span class="comment">//设置 view 高宽的测量值</span></div><div class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面方法很简单，就是给 View 设置了测量高宽的测量值，而这个测量值是通过 getDefaultSize 方法获取，那么接着分析 getDefaultSize 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> size view 的默认尺寸，一般表示设置了android:minHeight属性</div><div class="line">     *或者该View背景图片的大小值 </div><div class="line">     * <span class="doctag">@param</span> measureSpec 父容器的约束条件 measureSpec</div><div class="line">     * <span class="doctag">@return</span> 返回 view 的测量尺寸</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = size;</div><div class="line">  <span class="comment">//获取测量模式</span></div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">  <span class="comment">//获取尺寸</span></div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        <span class="comment">//如果 测量模式为 UNSPECIFIED ，表示对父容器对子 view 没有限制，那么 view 的测量尺寸为</span></div><div class="line">        <span class="comment">//默认尺寸 size</span></div><div class="line">        result = size;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        <span class="comment">//如果测量模式为 AT_MOST 最大测量模式或者 EXACTLY 精准测量模式，</span></div><div class="line">        <span class="comment">//那么 View 的测量尺寸为 MeasureSpec 的 specSize</span></div><div class="line">        <span class="comment">//即父容器给定尺寸（父容器当前剩余全部空间大小）。</span></div><div class="line">        result = specSize;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里来分析一下 UNSPECIFIED 条件下 View 的测量高宽默认值 size 是通过 getSuggestedMinimumWidth() 和 getSuggestedMinimumHeight()  函数获取，这两个方法原理一样，这里我们就看一下 getSuggestedMinimumHeight() 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码可以看出，如果 View 没有背景，View 的高度就是 mMinHeight，这个 mMinHeight 是由 android：minHeight 这个属性控制，可以为 0，如果有背景，就返回  mMinHeight 和背景的最小高度两者中的最大值。</p>
<p>从 getDefaultSize 方法可以看出，View 的高/宽由 父容器传递进来的 specSize 决定，因此可以得出结论：</p>
<p><strong>直接继承自 View 的自定义控件需要重写 onMeasure 方法来设置 wrap_content 时候的自身大小</strong>，而设置的具体值需要根据实际情况自己去计算或者直接给定一个默认固定值，否则在布局中使用 wrap_content  时候就相当于使用 match_parent ，因为在布局中使用 wrap_content 的时候，它的 specMode 是 AT_MOST 最大测量模式，在这种模式下 View 的宽/高等于 speceSize 大小，即父容器中可使用的大小，也就是父容器当前剩余全部空间大小，这种情况，很显然，View 的宽/高就是等于父容器剩余空间的大小，填充父布局，这种效果和布局中使用 match_parent  一样，解决这个问题代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">    <span class="keyword">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">  <span class="comment">// 在 MeasureSpec.AT_MOST 模式下，给定一个默认值</span></div><div class="line">  <span class="comment">//其他情况下沿用系统测量规则即可</span></div><div class="line">    <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST</div><div class="line">            &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        setMeasuredDimension(mWith, mHeight);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        setMeasuredDimension(mWith, heightSpecSize);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        setMeasuredDimension(widthSpecSize, mHeight);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中在 widthSpecMode 或 heightSpecMode 为 MeasureSpec.AT_MOST 我们就给定一个对应的 mWith 和 mHeight 默认固定值宽高，而这个默认值没有固定依据，需要我们根据自定义的 view 的具体情况去计算给定。</p>
<h3 id="5-1-2-ViewGroup-的-measure-过程"><a href="#5-1-2-ViewGroup-的-measure-过程" class="headerlink" title="5.1.2 ViewGroup 的 measure 过程"></a>5.1.2 ViewGroup 的 measure 过程</h3><p>ViewGroup 除了完成自己的测量过程还会遍历调用所有子 View 的<code>measure</code>方法，而且各个子 View 还会递归执行这个过程，我们知道 View Group 继承自 View ，是一个抽象类，因此没有重写 View  onMeasure 方法，也就是没有提供具体如何测量自己的方法，但是它提供了一个 measureChildren 方法，定义了如何测量子 View 的规则，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> widthMeasureSpec 该 ViewGroup 水平方向约束条件</div><div class="line"> * <span class="doctag">@param</span> heightMeasureSpec 该 ViewGroup 竖直方向约束条件</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">    <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">      <span class="comment">//逐一遍历获取得到 ViewGroup 中的子 View</span></div><div class="line">        <span class="keyword">final</span> View child = children[i];</div><div class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">          <span class="comment">//对获取到的 子 view 进行测量</span></div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们再看一下对子 View 进行测量的 measureChild 方法 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> child 要进行测量的子 view </div><div class="line"> * <span class="doctag">@param</span> parentWidthMeasureSpec ViewGroup 对要进行测量的子 view 水平方向约束条件</div><div class="line"> * <span class="doctag">@param</span> parentHeightMeasureSpec  ViewGroup 对要进行测量的子 view 竖直方向约束条件</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">        <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">  <span class="comment">//第一步，获取 View 的 LayoutParams</span></div><div class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"><span class="comment">//第二步，获取 view 的 WidthMeasureSpec，其中传入的几个参数说明：</span></div><div class="line"><span class="comment">//parentWidthMeasureSpec 父容器的 WidthMeasureSpec</span></div><div class="line"><span class="comment">//mPaddingLeft + mPaddingRight view 本身的 Padding 值，即内边距值</span></div><div class="line"><span class="comment">// lp.width view 本身期望的宽度 with 值</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">            mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">  <span class="comment">//同上</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">            mPaddingTop + mPaddingBottom, lp.height);</div><div class="line">  <span class="comment">// 第三步，根据获取的子 veiw 的 WidthMeasureSpec 和 HeightMeasureSpec </span></div><div class="line">   <span class="comment">//调用子 view 的 measure 方法，对子 view 进行测量，具体后面的测量逻辑就是和我们前面分析 </span></div><div class="line">  <span class="comment">// view 的测量过程一样了。</span></div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中的第二步调用的方法 getChildMeasureSpec  在标题 4 MeasureSpec和LayoutParams的对应关系 中已经分析过。</p>
<p>ViewGroup 并没有定义具体的测量过程，这是因为 ViewGroup 是一个抽象类，其不同子类具有不同的特性，导致他们的测量过程有所不同，不能有一个统一的 onMeasure 方法，所以其测量过程的 onMeasure 方法需要子类去具体实现，比如 LinearLayout 和 RelativeLayout 等，下面通过 LinearLayout 的 onMeasure 方法来分析一下 ViewGroup 的测量过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">      <span class="comment">//垂直方向的 LinearLayout  测量方式</span></div><div class="line">        measureVertical(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//水平方向的 LinearLayout 测量方式</span></div><div class="line">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码可以看出 ViewGroup 内部测量方式分为垂直方向和水平方向，两者原理基本一样，下面看一下垂直方向的 LinearLayout  测量方式，由于这个方法代码比较长，所以贴出重点部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line"> ......................</div><div class="line">    <span class="comment">//记录总高度</span></div><div class="line">    <span class="keyword">float</span> totalWeight = <span class="number">0</span>;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</div><div class="line">  <span class="comment">//获取测量模式</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> widthMode = View.MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightMode = View.MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"> ...........</div><div class="line">    <span class="comment">//第1步，对 LinearLayout 中的子 view 进行第一次测量</span></div><div class="line">    <span class="comment">// See how tall everyone is. Also remember max width.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">            mTotalLength += measureNullChild(i);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class="line">            i += getChildrenSkipCount(child, i);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">            mTotalLength += mDividerHeight;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取子 view 的 LayoutParams 参数</span></div><div class="line">        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">        totalWeight += lp.weight;</div><div class="line">      <span class="comment">//第1.1步，满足该条件，第一次测量时不需要测量该子 view</span></div><div class="line">        <span class="keyword">if</span> (heightMode == View.MeasureSpec.EXACTLY &amp;&amp; lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 满足该条件的话，不需要现在计算该子视图的高度。</span></div><div class="line">            <span class="comment">//因为 LinearLayout 的高度测量规格为 EXACTLY ，说明高度 LinearLayout 是固定的，</span></div><div class="line">            <span class="comment">//不依赖子视图的高度计算自己的高度</span></div><div class="line">            <span class="comment">//lp.height == 0 &amp;&amp; lp.weight &gt; 0 说明子 view 使用了权重模式，即希望使用 LinearLayout 的剩余空间</span></div><div class="line">            <span class="comment">// 测量工作会在之后进行</span></div><div class="line">            <span class="comment">//相反，如果测量规格为 AT_MOST 或者 UNSPECIFIED ，LinearLayout</span></div><div class="line">            <span class="comment">// 只能根据子视图的高度来确定自己的高度，就必须对所有的子视图进行测量。</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</div><div class="line">            <span class="comment">//标记未进行测量</span></div><div class="line">            skippedMeasure = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">//  else 语句内部是对子 view 进行第一次测量</span></div><div class="line">            <span class="keyword">int</span> oldHeight = Integer.MIN_VALUE;</div><div class="line">            <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 如果 LiniearLayout 不是 EXACTLY 模式，高度没给定，</span></div><div class="line">              <span class="comment">//说明 LiniearLayout 高度需要根据子视图来测量，</span></div><div class="line">                <span class="comment">// 而此时子 view 模式为 lp.height == 0 &amp;&amp; lp.weight &gt; 0 ，是希望使用 LinearLayout 的剩余空间</span></div><div class="line">                <span class="comment">// 这种情况下，无法得出子 view 高度，而为了测量子视图的高度，</span></div><div class="line">              <span class="comment">//设置子视图 LayoutParams.height 为 wrap_content。</span></div><div class="line">                oldHeight = <span class="number">0</span>;</div><div class="line">                lp.height = LayoutParams.WRAP_CONTENT;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//该方法只是调用了 ViewGroup 的 measureChildWithMargins() 对子 view 进行测量</span></div><div class="line">            <span class="comment">// measureChildWithMargins() 方法在上面 4 MeasureSpec和LayoutParams的对应关系已经分析过</span></div><div class="line">            measureChildBeforeLayout(</div><div class="line">                    child, i, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec,</div><div class="line">                    totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (oldHeight != Integer.MIN_VALUE) &#123;</div><div class="line">                lp.height = oldHeight;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 获取测量到的子 view 高度</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">            <span class="comment">//第2步， 重新计算 LinearLayout 的 mTotalLength 总高度</span></div><div class="line">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</div><div class="line">                    lp.bottomMargin + getNextLocationOffset(child));</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (useLargestChild) &#123;</div><div class="line">                largestChildHeight = Math.max(childHeight, largestChildHeight);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    ..........................</div><div class="line">        <span class="comment">//以下方法是对 LinearLayout 宽度相关的测量工作，不是我们关心的</span></div><div class="line">        <span class="keyword">if</span> (widthMode != View.MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            .........................</div><div class="line">    <span class="comment">//以上方法是对 LinearLayout 宽度相关的测量工作</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mTotalLength &gt; <span class="number">0</span> &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</div><div class="line">        mTotalLength += mDividerHeight;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//第3步，如果设置了 android:measureWithLargestChild="true"并且测量模式为 AT_MOST或者 UNSPECIFIED</span></div><div class="line">    <span class="comment">// 重新计算 mTotalLength 总高度</span></div><div class="line">    <span class="keyword">if</span> (useLargestChild &amp;&amp;</div><div class="line">            (heightMode == View.MeasureSpec.AT_MOST || heightMode == View.MeasureSpec.UNSPECIFIED)) &#123;</div><div class="line">        mTotalLength = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">                mTotalLength += measureNullChild(i);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</div><div class="line">                i += getChildrenSkipCount(child, i);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</div><div class="line">                    child.getLayoutParams();</div><div class="line">            <span class="comment">// Account for negative margins</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">            <span class="comment">//每个子视图的高度为：最大子视图高度 ＋ 该子视图的上下外边距</span></div><div class="line">            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</div><div class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Add in our padding</span></div><div class="line">    mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> heightSize = mTotalLength;</div><div class="line"></div><div class="line">    <span class="comment">// Check against our minimum height</span></div><div class="line">    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</div><div class="line"></div><div class="line">    <span class="comment">//第4步，根据 heightMeasureSpec 测量模式 和已经测量得到的总高度 heightSize</span></div><div class="line">    <span class="comment">//来确定得到最终 LinearLayout 高度和状态</span></div><div class="line">    <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</div><div class="line">          </div><div class="line">    <span class="comment">//分割线=================以上代码就完成了对  LinearLayout 高度和状态 的测量</span></div><div class="line"></div><div class="line">    <span class="comment">//第5步，下面代码是根据已经测量得到的 LinearLayout 高度来重新测量确定各个子 view 的大小</span></div><div class="line"></div><div class="line">    <span class="comment">//获取 LinearLayout 高度值</span></div><div class="line">    heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</div><div class="line">    <span class="comment">//获取最终测量高度和经过测量各个子 view 得到的总高度差值</span></div><div class="line">    <span class="keyword">int</span> delta = heightSize - mTotalLength;</div><div class="line">    <span class="comment">//第5.1步（第5步中第1小步），如果在上面第一次测量子 view 的过程中有未进行测量的 view 那么执行下面代码</span></div><div class="line">    <span class="keyword">if</span> (skippedMeasure || delta != <span class="number">0</span> &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>) &#123;</div><div class="line">        <span class="keyword">float</span> weightSum = mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</div><div class="line">        mTotalLength = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">            <span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">            <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 计算 weight 属性分配的大小，可能为负值</span></div><div class="line">                <span class="keyword">int</span> share = (<span class="keyword">int</span>) (childExtra * delta / weightSum);</div><div class="line">                weightSum -= childExtra;</div><div class="line">                delta -= share;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</div><div class="line">                        mPaddingLeft + mPaddingRight +</div><div class="line">                                lp.leftMargin + lp.rightMargin, lp.width);</div><div class="line"></div><div class="line">                <span class="comment">// <span class="doctag">TODO:</span> Use a field like lp.isMeasured to figure out if this</span></div><div class="line">                <span class="comment">// child has been previously measured</span></div><div class="line">                <span class="keyword">if</span> ((lp.height != <span class="number">0</span>) || (heightMode != View.MeasureSpec.EXACTLY)) &#123;</div><div class="line">                    <span class="comment">// 子视图在第一次测量时候已经测量过</span></div><div class="line">                    <span class="comment">// 基于上次测量值再次进行新的测量</span></div><div class="line">                    <span class="keyword">int</span> childHeight = child.getMeasuredHeight() + share;</div><div class="line">                    <span class="keyword">if</span> (childHeight &lt; <span class="number">0</span>) &#123;</div><div class="line">                        childHeight = <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 调用子 view 的 measure 方法进行测量，后面逻辑就是 view 的测量逻辑</span></div><div class="line">                    child.measure(childWidthMeasureSpec,</div><div class="line">                            View.MeasureSpec.makeMeasureSpec(childHeight, View.MeasureSpec.EXACTLY));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 子视图第一次测量，即第一步进行测量的时候未得到测量</span></div><div class="line">                    <span class="comment">//对 view 进行测量</span></div><div class="line">                    child.measure(childWidthMeasureSpec,</div><div class="line">                            View.MeasureSpec.makeMeasureSpec(share &gt; <span class="number">0</span> ? share : <span class="number">0</span>,</div><div class="line">                                    View.MeasureSpec.EXACTLY));</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Child may now not fit in vertical dimension.</span></div><div class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState()</div><div class="line">                        &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 处理子视图宽度</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> margin =  lp.leftMargin + lp.rightMargin;</div><div class="line">           ...........................</div><div class="line">        <span class="comment">// Add in our padding</span></div><div class="line">        mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//第5.2步（第5步中第2小步）执行到这里的代码，表明 view 是已经测量过的</span></div><div class="line">        alternativeMaxWidth = Math.max(alternativeMaxWidth,</div><div class="line">                weightedMaxWidth);</div><div class="line">        <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></div><div class="line">        <span class="comment">// Children will have already been measured once.</span></div><div class="line">        <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != View.MeasureSpec.EXACTLY) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">                <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">                <span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">                <span class="comment">//如果 view 使用了权重即 childExtra &gt; 0，使用最大子视图高度进行重新测量</span></div><div class="line">                <span class="comment">//否则不进行测量，保持第一次测量值，那么由于 LinearLayout 的高度使用了子 view 最大高度 ，</span></div><div class="line">                <span class="comment">// 但是子视图没有进行重新测量，没有进行拉伸，可能造成空间剩余。</span></div><div class="line">                <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">//使用最大子视图高度进行重新测量子 view </span></div><div class="line">                    child.measure(</div><div class="line">                            View.MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</div><div class="line">                                    View.MeasureSpec.EXACTLY),</div><div class="line">                            View.MeasureSpec.makeMeasureSpec(largestChildHeight,</div><div class="line">                                    View.MeasureSpec.EXACTLY));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != View.MeasureSpec.EXACTLY) &#123;</div><div class="line">        maxWidth = alternativeMaxWidth;</div><div class="line">    &#125;</div><div class="line">    maxWidth += mPaddingLeft + mPaddingRight;</div><div class="line">    <span class="comment">// Check against our minimum width</span></div><div class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</div><div class="line">    <span class="comment">//第6步，最终设置 LinearLayout 的测量高宽</span></div><div class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class="line">            heightSizeAndState);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (matchWidth) &#123;</div><div class="line">        forceUniformWidth(count, heightMeasureSpec);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码就是对 LinearLayout onMeasure 分析过程，整个过程原理已经在代码中加以注释说明，这里我们重点分析一下 resolveSizeAndState(heightSize, heightMeasureSpec, 0) 这个方法是如何实现最终确定 LinearLayout 高度值的，方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> size view 想要的大小，也就是根据子 view 高度测量得到的高度值.</div><div class="line"> * <span class="doctag">@param</span> measureSpec 父容器的约束条件</div><div class="line"> * <span class="doctag">@param</span> childMeasuredState 子 view 的测量信息</div><div class="line"> * <span class="doctag">@return</span> Size 返回得到的测量值和状态</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasuredState)</span> </span>&#123;</div><div class="line">  <span class="comment">//获取测量模式</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">  <span class="comment">//获取尺寸值</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> result;</div><div class="line">  <span class="comment">//根据不同测量模式决定最终测量结果</span></div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">        <span class="comment">//如果是 AT_MOST 最大测量模式 ，那么总高度值为测量得到的 size 值，但是最大不能超过 specSize 规定值</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">            <span class="keyword">if</span> (specSize &lt; size) &#123;</div><div class="line">              <span class="comment">//如果测量得到的 size 值超过 specSize 值，LinearLayout 高度就为 specSize 值</span></div><div class="line">                result = specSize | MEASURED_STATE_TOO_SMALL;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="comment">//如果测量得到的 size 值未超过 specSize 值，LinearLayout 高度就为 size 值</span></div><div class="line">                result = size;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">       <span class="comment">//如果是 EXACTLY 精准测量模式，即 LinearLayout 值为固定值，那么 最终 LinearLayout 高度值就为 specSize 值</span></div><div class="line">            result = specSize;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        <span class="comment">// 如果是 UNSPECIFIED 测量模式，即对子 view 没有限制 ， LinearLayout 高度值就为 size</span></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            result = size;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result | (childMeasuredState &amp; MEASURED_STATE_MASK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码总结起来就是 LinearLayout 会根据测量子 View 的情况和 MeasureSpec 约束条件来决定自己最终的大小，具体来说就是如果它的布局中高度才用 具体数值，那么它的测量过程和 View 一致，即高度为 specSize 值，如果它的布局中使用 wrap_content 那么它的高度是所有子 View 高度总和，但是不能超过父容器剩余空间。</p>
<p>最后对整个测量过程总结一下就是分为以下几步：</p>
<ol>
<li>对 LinearLayout 中的子 View 进行第一次遍历测量，主要是通过 measureChildBeforeLayout 这个方法，这个方法内部会调用 measureChildWithMargins 方法，而在 measureChildWithMargins 方法内部会去调用 child.measure(childWidthMeasureSpec, childHeightMeasureSpec) 方法进行测量。在这次的测量过程中，如果满足了第1.1步测量条件的子 view 不需要进行测量，会在后面的第5.1步中进行测量。</li>
<li>根据测量各个子 View 的高度会得到一个初步的 LinearLayout 总高度  mTotalLength 值。</li>
<li>如果 LinearLayout 设置了 android:measureWithLargestChild=”true” 属性并且测量模式为 AT_MOST或者 UNSPECIFIED 重新计算 mTotalLength 总高度。</li>
<li>根据 LinearLayout  的 heightMeasureSpec 测量模式 和已经测量得到的总高度 mTotalLength ，来确定得到最终 LinearLayout 高度和状态 。</li>
<li>根据已经测量得到的 LinearLayout 高度来重新测量确定各个子 View 的大小。</li>
<li>最终执行 setMeasuredDimension 方法设置 LinearLayout 的测量高宽。</li>
</ol>
<h1 id="6-实际问题解决"><a href="#6-实际问题解决" class="headerlink" title="6 实际问题解决"></a>6 实际问题解决</h1><p>View 的 measure 过程和 Activity 的生命周期方法不是同步执行的，因此无法保证 Activity 执行了onCreate、onStart、onResume 时某个 View 已经测量完毕了。如果View还没有测量完毕，那么获得的宽和高都是 0。下面是四种解决该问题的方法：</p>
<p>1、<strong>Activity/View#onWindowsChanged 方法</strong></p>
<p>onWindowFocusChanged 方法表示 View 已经初始化完毕了，宽高已经准备好了，这个时候去获取是没问题的。这个方法会被调用多次，当 Activity 继续执行或者暂停执行的时候，这个方法都会被调用，典型代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasWindowFocus)</span> </span>&#123;</div><div class="line">         <span class="keyword">super</span>.onWindowFocusChanged(hasWindowFocus);</div><div class="line">       <span class="keyword">if</span>(hasWindowFocus)&#123;</div><div class="line">       <span class="keyword">int</span> width=view.getMeasuredWidth();</div><div class="line">       <span class="keyword">int</span> height=view.getMeasuredHeight();</div><div class="line">      &#125;      </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>2、<strong>View.post(runnable)</strong> </p>
<p> 通过 post 将一个 Runnable 投递到消息队列的尾部，然后等待 Looper 调用此 runnable 的时候 View 也已经初始化好了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStart();</div><div class="line">    view.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> width=view.getMeasuredWidth();</div><div class="line">            <span class="keyword">int</span> height=view.getMeasuredHeight();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3、<strong>ViewTreeObsever</strong> </p>
<p> 使用 ViewTreeObserver 的众多回调方法可以完成这个功能，比如使用 onGlobalLayoutListener 接口，当 View 树的状态发生改变或者 View 树内部的 View 的可见性发生改变时，onGlobalLayout 方法将被回调。伴随着View树的变化，这个方法也会被多次调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStart();</div><div class="line">    ViewTreeObserver viewTreeObserver=view.getViewTreeObserver();</div><div class="line">    viewTreeObserver.addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</div><div class="line">            view.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">int</span> width=view.getMeasuredWidth();</div><div class="line">            <span class="keyword">int</span> height=view.getMeasuredHeight();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4、<strong>view.measure(int widthMeasureSpec, int heightMeasureSpec)</strong> </p>
<p> 通过手动对 View 进行 measure 来得到 View 的宽高，这个要根据 View 的 LayoutParams 来处理：</p>
<p>（1）<strong>match_parent</strong>：无法 measure 出具体的宽高，原因是根据上面我们分析 View 的measure 过程原理可知，此种 MeasureSpec 需要知道 parentSize ，即父容器剩余空间，而这个时候无法知道 parentSize  大小，所以无法测量。</p>
<p>（2）<strong>wrap_content:</strong> 可以采用设置最大值方法进  measure ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> widthMeasureSpec = MeasureSpec.makeMeasureSpec((<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>, MeasureSpec.AT_MOST);</div><div class="line"></div><div class="line"><span class="keyword">int</span> heightMeasureSpec = MeasureSpec.makeMeasureSpec((<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>, MeasureSpec.AT_MOST);</div><div class="line"></div><div class="line">view.measure(widthMeasureSpec, heightMeasureSpec);</div></pre></td></tr></table></figure>
<p>  <strong>注意这里作者为什么使用</strong> (1 &lt;&lt; 30) - 1 ) 来构造 MeasureSpec 呢？笔者解释是：”通过分析 MeasureSpec  的实现可以得知 View 的尺寸是使用 30 位的二进制表示，也就是说最大是 30 个 1 即（2^30-1)，也就是  (1 &lt;&lt; 30) - 1 )，在最大化模式下，使用 View 能支持的最大值去构造 MeasureSpec  是合理的“。为什么这样就合理呢？我们前面分析在子 View 使用 wrap_content 模式的时候，其测量规则是根据自身的情况去测量尺寸，但是不能超过父容器的剩余空间的最大值，换句话说就是父容器给子 View 一个最大值，然后告诉子 View 你自己看着办，但是别超过这个尺寸就行，但是现在我们自己去测量的时候不知道父容器给定的 MeasureSpec 情况， 也就是不知道父容器给多大的限定值，需要自己去构造一个MeasureSpec ，那么这个最大值我们给定多少合适呢？所以这里干脆就给一个 View 所能支持的最大值，然子 View 根据自身情况去测量，怎么也不能超过这个值就行了。</p>
<p>（3）具体数值（dp/px)：例如100px，如下 measure :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> widthMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">100</span>, MeasureSpec.EXACTLY);</div><div class="line"></div><div class="line"><span class="keyword">int</span> heightMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">100</span>, MeasureSpec.EXACTLY);</div><div class="line"></div><div class="line">view.measure(widthMeasureSpec, heightMeasureSpec);</div></pre></td></tr></table></figure>
<p> 以上四种解决方法的代码和原理上面已经详细说明，大家可以根据需要进行选择使用。</p>
<p><strong>结语：</strong></p>
<p>本次笔记主要记录 View 三大流程中的 onMeasure() 测量原理部分，笔者感觉这一部分也是比较重要和难懂的部分，在我们实际中很多问题会涉及到，所以静下心来详细记录，如有理解错误，还望指出，谢谢！！！！！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/11/view_measure/" data-id="civnx6lmf0002v0q7o3jsauid" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-View/">Android View</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-view_touchEvent_dispatch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/28/view_touchEvent_dispatch/" class="article-date">
  <time datetime="2016-08-28T10:19:27.856Z" itemprop="datePublished">2016-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-View/">Android View</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/28/view_touchEvent_dispatch/">View 的事件分发机制（Android 开发艺术探索读书笔记）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>-文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</p>
<ul>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://github.com/yongyu0102" target="_blank" rel="external">yongyu0102</a></li>
<li>审阅者：<a href="https://github.com/melodyxxx" target="_blank" rel="external">HanJie</a></li>
</ul>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在写这篇笔记的时候想了好久，也拖了好长时间，关于事件分发的博客看了很多，有的写的思路很清晰，画了事件分发的整体流程图，但是没有源码，看过之后只能知道事件是怎么分发的，但完全是记住的，而不是通过源码分析出来的，试想，如果以后再遇到其他知识点还是这样，那么我们就完全成了不能靠自己去分析问题，只能去食他人知识，没有自我学习分析能力，所以笔者试着结合艺术探索的讲解，尝试在源码的基础上加以理解，本文的写作逻辑是先从文字描述上尽量让大家先大概了解，事件分发的概况，先有个感性认识，再结合源码进行分析，如果错误的地方，还请指出。</p>
<h3 id="1-1-点击事件的传递规则"><a href="#1-1-点击事件的传递规则" class="headerlink" title="1.1 点击事件的传递规则"></a>1.1 点击事件的传递规则</h3><p>在我们进行分析事件分发机制之前，先思考一下我们要研究哪些问题：</p>
<p><strong>1、事件分发的对象是什么？</strong></p>
<p>当用户触摸屏幕时，将创建一个 MotionEvent 对象即点击事件。MotionEvent 包含关于发生触摸的位置、时间、历史记录、手势动作等细节信息， Touch 事件相关细节被封装成了 MotionEvent 对象。理解了这一个知识点后，其实我们就很容易理解所谓点击事件的分发，其实就是对 MotionEvent 事件分发的过程，即当一个 MotionEvent 产生后，系统需要把这个事件传递给一个具体的 View 去处理, 而这个传递的过程就是分发过程。</p>
<p><strong>2、事件是在哪些对象之间传递？</strong></p>
<p>Android 与用户交互的界面就是由一系列 Activity（Fragment)、ViewGroup、View 组成如图：</p>
<p>​                                                 <img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/Activity_ViewGroup_View.png?raw=true" alt="Activity_ViewGroup_View"></p>
<p>当然一个界面可能由多个ViewGroup或者多个View 组成，所以事件就是在这三者之间进行传递，我们要分析的就是要捋清楚事件是由哪个对象发出，经过哪些对象，最终达到哪个对象，在某些条件改变的时候下他们之间的关系又是怎样的，理解了这些之后，当我们在遇到点击或者滑动事件冲突的情况，相信一切问题就迎刃而解了。</p>
<p><strong>3、这个分发过程由哪些对象协作完成？</strong></p>
<p>其实点击事件分发过程主要由三个重要方法共同完成：dispatchTouchEvent(MotionEvent event) 、onInterceptTouchEvent(MotionEvent event)和onTouchEvent(MotionEvent event)，下面先介绍一下这三个方法的主要作用，这样有利于后面我们对源码的分析：</p>
<ol>
<li><p>public boolean dispatchTouchEvent(MotionEvent event) ：用来进行事件的分发。如果事件能够传递给当前view，那么此方法一定会被调用，返回结果受当前 view 的 onTouchEvent 和下级 view 的 dispatchTouchEvent 方法的影响，表示是否消耗当前事件。返回值 true，表示触摸事件被消费，已经分发出去，后续事件会继续分发到该 View；返回值 false，则表示触摸事件没有被消费，即事件没有分发出去，那么后续事件就不会继续向该 View 分发，该方法在 View 和 ViewGroup 中都有。</p>
</li>
<li><p>public boolean onInterceptTouchEvent(MotionEvent event)<br>在 dispatchTouchEvent 方法内部调用，用来判断是否拦截某个事件，如果当前 view 拦截了某个事件，那么在同一个事件序列当中，此方法不会再被调用，返回结果表示是否拦截当前事件。只有 ViewGroup 中才有该方法 ，返回值 true，表示ViewGroup拦截了该触摸事件，该事件就不会分发给它的子 View 或者子 ViewGroup，事件会由自己的 onTouchEvent() 方法处理。返回值 false，表示 ViewGroup 没有拦截该事件，该事件就可以分发给它的子 View 和子 ViewGroup ，事件传递到子 view 的 dispatchTouchEvent() 方法中去处理。</p>
</li>
<li><p>public boolean onTouchEvent(MotionEvent event)<br>在 dispatchTouchEvent 方法内部调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果 ACTION_DOWN不消耗，则在同一个事件序列中，当前 view 无法再次接收到事件。返回值为 True ，事件由自己处理，后续事件序列让其处理；返回值为 False ，自己不消耗事件，向上返回让其他的父容器的onTouchEvent接受处理。</p>
<p>这三个方法都是通过 dispatchTouchEvent() 联系在一起，他们之间的关系可以用如下伪代码表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">  <span class="comment">//表示事件是否被分发出去（消耗），默认为false，即默认不拦截</span></div><div class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;</div><div class="line">      <span class="comment">//如果拦截了，那么事件交给当前view的onTouchEvent(ev)</span></div><div class="line">      <span class="comment">//方法进行处理，返回值即onTouchEvent(ev)的结果</span></div><div class="line">        consume = onTouchEvent(ev);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">     <span class="comment">//如果不拦截，那么事件交给子view的dispatchTouchEvent(ev)</span></div><div class="line">      <span class="comment">//方法进行处理，返回值即是dispatchTouchEvent(ev)事件</span></div><div class="line">      <span class="comment">//处理结果</span></div><div class="line">        consume = child.dispatchTouchEvent(ev);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> consume;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>结论：对于一个根 ViewGroup，点击事件产生后，首先会传递给它，这时 ViewGroup 的 dispatchTouchEvent 会调用，而在 dispatchTouchEvent 方法中会调用 onInterceptTouchEvent() 方法，如果它的 onInterceptTouchEvent 返回 true 表示要拦截当前事件，接下来事件会交给这个 ViewGroup 处理，此时 ViewGroup 的 onTouchEvent 方法就会被调用，如果这个ViewGroup 的 onInterceptTouchEvent 返回 false，则事件会继续传递给子元素，子元素的 dispatchTouchEvent 会调用，如此反复直到事件被处理。</p>
<p>当一个View需要处理事件时，如果设置了 OnTouchListener ，那么 OnTouchListener 的 onTouch方法会回调，如果 onTouch 返回 false，则当前 View 的 onTouchEvent 方法会被调用；如果返回 true，那么 onTouchEvent 方法将不会调用。由此可见，OnTouchListener 优先级高于 onTouchEvent。OnClickListener 优先级处在事件传递的尾端。</p>
<p><strong>4、事件的传递顺序是什么？</strong></p>
<p>这里就直接给出答案:一个点击事件产生后，传递顺序：Activity -&gt; Window -&gt; ViewGroup  -&gt; View；如果一个 View 的 onTouchEvent 返回 false 即 View 没有处理事件，那么它的父容器的onTouchEvent 会被调用，以此类推，所有元素都不处理该事件，最终将传递给 Activity 处理，即 Activity 的 onTouchEvent 会被调用，事件顺序为：View -&gt;  ViewGroup -&gt; Window -&gt;  Activity。</p>
<p>5、关于事件传递的其他一些结论这里先给出，以便我们更好的理解时间传递机制，结论如下：</p>
<ol>
<li>同一个事件序列是指从手指触摸屏幕那一刻开始，中间包含数量不定的 move 事件到手指离开屏幕那一刻（down-&gt;move…move-&gt;up)。</li>
<li>正常情况下一个事件序列只能被一个 View 拦截且消耗，每个 View  一旦决定拦截，同一个事件序列所有事件都会直接交给它处理，并且它的 onInterceptTouchEvent 不会再被调用。</li>
<li>某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN（ onTouchEvent  返回了 false ），那么同一事件序列中其他事件都不会再交给它来处理，事件将重新交给他的父元素处理，即父元素的 onTouchEvent 会被调用。</li>
<li>如果某个 View 不消耗除  ACTION_DOWN 以外的其他事件，那么这个点击事件会消失，此时父元素的 onTouchEvent 并不会被调用，并且当前 View 可以收到后续事件，最终这些消失的点击事件会传递给 Activity 处理。</li>
<li>ViewGroup 默认不拦截任何事件，ViewGroup 的 onInterceptTouchEvent 方法默认返回 false。</li>
<li>View 没有 onInterceptTouchEvent 方法，一旦有事件传递给它，那么它的 onTouchEvent 方法就会被调用。</li>
<li>View 的 onTouchEvent 方法默认消耗事件（返回 true ），除非他是不可点击的（ clickable 和 longClickable 同时为 false ）。View 的 longClickable 属性默认都为 false ，clickable 属性分情况，Button 默认为 true，TextView 默认为 false。</li>
<li>onClick 发生的前提是View可点击，并且它收到了down 和 up 事件。</li>
<li>事件传递过程是由外而内，事件总是先传递给父元素，然后在由父元素分发给子 View，通过requestDisallowInterceptTouchEvent 方法可以在子元素干预父元素的事件分发过程，但 ACTION_DOWN 事件除外。                </li>
</ol>
<h3 id="1-2-事件分发的源码解析"><a href="#1-2-事件分发的源码解析" class="headerlink" title="1.2 事件分发的源码解析"></a>1.2 事件分发的源码解析</h3><p>这里要分别分析 Activity  、ViewGroup 和 View 对事件的分发。</p>
<h4 id="1-Activity-对点击事件的分发过程"><a href="#1-Activity-对点击事件的分发过程" class="headerlink" title="1. Activity 对点击事件的分发过程"></a>1. Activity 对点击事件的分发过程</h4><p>   由于平时我们对 Activity 事件分发接触不是很多（笔者是这样），使用应该不是很多，所以这里只做简单介绍。</p>
<p>   (1) Activity 中与触摸事件相关API主要是 dispatchTouchEvent() 和 onTouchEvent()。dispatchTouchEvent() 是传递触摸事件的API，而 onTouchEvent() 则是 Activity 处理触摸事件的API。</p>
<p>   (2) Activity 中的 dispatchTouchEven 会将触摸事件传递给Activity 所包含的视图。具体的实现方式在通过调用到 Activity 所属 Window 的  superDispatchTouchEvent，进而调用到 Window 的 DecorView 的 superDispatchTouchEvent，进一步又调用到 ViewGroup 的 dispatchTouchEvent() ，这样事件就从 Activity 传递到了 ViewGroup 。<br>   如果 Activity 所包含的视图拦截或者消费了该触摸事件的话，就不会再执行 Activity 的 onTouchEvent() ；<br>   如果 Activity 所包含的视图没有拦截或者消费该触摸事件的话，则会执行 Activity 的 onTouchEvent() 。<br>   (3) Activity 中的 onTouchEvent 是 Activity 自身对触摸事件的处理。如果该 Activity 的 android:windowCloseOnTouchOutside 属性为 true，并且当前触摸事件是 ACTION_DOWN ，而且该触摸事件的坐标在 Activity 之外，同时 Activity 还包含了视图的话就会导致 Activity 被结束。</p>
<h4 id="2-View-对点击事件的处理过程"><a href="#2-View-对点击事件的处理过程" class="headerlink" title="2. View 对点击事件的处理过程"></a>2. View 对点击事件的处理过程</h4><p>   这里的 View 不包含 ViewGroup ，这里说下为什么先分析 View 而不是像书上那样先分析 ViewGroup ，因为在 ViewGroup 的事件分发过程中会调用到 View 对事件的处理，而且 View 的事件处理相比 ViewGroup 而言简单些，所以这里先分析 View 。</p>
<p>   我们来看一下 View 中 dispatchTouchEvent 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span> <span class="params">(MotionEvent event)</span></span>&#123;</div><div class="line">        .........</div><div class="line">        <span class="comment">//标记处理结果是否成功</span></div><div class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">        ...........</div><div class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            <span class="comment">// 如果 mListenerInfo 不为 null，且点击的控件是否是 enable 的</span></div><div class="line">            <span class="comment">//那么就会调用 mOnTouchListener.onTouch(this, event) 方法</span></div><div class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></div><div class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">                <span class="comment">//如果 mOnTouchListener.onTouch(this, event)</span></div><div class="line">                <span class="comment">//方法返回值为 Ture</span></div><div class="line">                <span class="comment">//那么 设置 result = true;即 dispatchTouchEvent </span></div><div class="line">                <span class="comment">//方法返回值为 true</span></div><div class="line">                result = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果 result 为 false ，则调用 onTouchEvent(event)方法</span></div><div class="line">        <span class="comment">//也就是如果 mOnTouchListener.onTouch(this, event)方法返回 true</span></div><div class="line">        <span class="comment">//那么 onTouchEvent(event)方法就不会调用</span></div><div class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">            <span class="comment">//如果 onTouchEvent(event) 返回值为 true ，</span></div><div class="line">            <span class="comment">//那么 dispatchTouchEvent 方法返回 true</span></div><div class="line">            result = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">.............</div><div class="line">    <span class="comment">//返回处理结果</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   从上面源码的10行代码可以看出，首先会判断 mOnTouchListener 是否为空，而mOnTouchListener 是在 setOnTouchListener 方法里赋值的，也就是说只要我们给控件注册了touch 事件，mOnTouchListener 就一定不为空，而(mViewFlags &amp; ENABLED_MASK) == ENABLED 是判断当前点击的控件是否是 enable 的，按钮默认都是 enable 的，因此这个条件恒定为 true。mOnTouchListener.onTouch(this, event)，其实也就是去回调控件注册 touch 事件时的 onTouch 方法。也就是说如果我们在 onTouch 方法里返回 true，就会让这三个条件全部成立，从而整个方法返回 true。在结合22行代码 if (!result &amp;&amp; onTouchEvent(event))，可以得出结论，如果我们在 onTouch 方法里返回 false，就会再去执行 onTouchEvent(event)方法，如果 onTouch 方法里返回 true ，onTouchEvent(event) 方法将不会执行, 可见 OnTouchListener 优先级高于 onTouchEvent(event) 方法。<br>   接下来我们分析一下 onTouchEvent(event) 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;   </div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</div><div class="line">      <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</div><div class="line">  <span class="comment">// 如果是不可用状态下</span></div><div class="line">      <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">          <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">              setPressed(<span class="keyword">false</span>);</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// A disabled view that is clickable</span></div><div class="line">          <span class="comment">//still consumes the touch</span></div><div class="line">          <span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">          <span class="comment">//只要 view 是 clickable 那么仍然会消费事件，</span></div><div class="line">          <span class="comment">//返回值为 true，</span></div><div class="line">          <span class="comment">//只不过不响应事件</span></div><div class="line">          <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</div><div class="line">                  || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class="line">                  || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 如果 view 是 CLICKABLE 或者 LONG_CLICKABLE，</span></div><div class="line">      <span class="comment">//即 view 是 clickable 状态</span></div><div class="line">      <span class="comment">// 就会进入以下方法的 switch 语句 ACTION_MOVE、ACTION_UP、</span></div><div class="line">      <span class="comment">// ACTION_DOWN、ACTION_CANCEL、ACTION_CANCEL</span></div><div class="line">      <span class="comment">//各种状态的处理</span></div><div class="line">      <span class="comment">//无论处于那种状态，最终返回结果都是 true</span></div><div class="line">      <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">              (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||(viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</div><div class="line">          <span class="keyword">switch</span> (action) &#123;</div><div class="line">              <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                  <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</div><div class="line">                  <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepresse</div><div class="line">                      <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</div><div class="line">                      <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class="line">                          focusTaken = requestFocus();</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                          setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class="line">                          removeLongPressCallback();</div><div class="line">                          <span class="keyword">if</span> (!focusTaken) &#123;</div><div class="line">                              <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</div><div class="line">                                  mPerformClick = <span class="keyword">new</span> PerformClick();</div><div class="line">                              &#125;</div><div class="line">                              <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                                  performClick();</div><div class="line">                              &#125;</div><div class="line">                          &#125;</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</div><div class="line">                          mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                          postDelayed(mUnsetPressedState,</div><div class="line">                                  ViewConfiguration.getPressedStateDuration());</div><div class="line">                      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</div><div class="line">                          mUnsetPressedState.run();</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      removeTapCallback();</div><div class="line">                  &#125;</div><div class="line">                  mIgnoreNextUpEvent = <span class="keyword">false</span>;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line"></div><div class="line">              <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                  mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                  <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  &#125;</div><div class="line">                  <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</div><div class="line"></div><div class="line">                  <span class="keyword">if</span> (isInScrollingContainer) &#123;</div><div class="line">                      mPrivateFlags |= PFLAG_PREPRESSED;</div><div class="line">                      <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</div><div class="line">                          mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</div><div class="line">                      &#125;</div><div class="line">                      mPendingCheckForTap.x = event.getX();</div><div class="line">                      mPendingCheckForTap.y = event.getY();</div><div class="line">                      postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class="line">                  &#125; <span class="keyword">else</span> &#123;</div><div class="line">                      setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                      checkForLongClick(<span class="number">0</span>);</div><div class="line">                  &#125;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line"></div><div class="line">              <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">                  setPressed(<span class="keyword">false</span>);</div><div class="line">                  removeTapCallback();</div><div class="line">                  removeLongPressCallback();</div><div class="line">                  mInContextButtonPress = <span class="keyword">false</span>;</div><div class="line">                  mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line">                  mIgnoreNextUpEvent = <span class="keyword">false</span>;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line"></div><div class="line">              <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                  drawableHotspotChanged(x, y);</div><div class="line">                  <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                      <span class="comment">// Outside button</span></div><div class="line">                      removeTapCallback();</div><div class="line">                      <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">                          removeLongPressCallback();</div><div class="line"></div><div class="line">                          setPressed(<span class="keyword">false</span>);</div><div class="line">                      &#125;</div><div class="line">                  &#125; </div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">      <span class="comment">//如果该控件是可以点击的就会进入 switch 判断中去，</span></div><div class="line">      <span class="comment">//最终返回值为 true ，即 onTouchEvent</span></div><div class="line">          <span class="comment">//返回值为 true 。</span></div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">  <span class="comment">//如果该控件是不可点击的返回 false ，如 TextView</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>   先看第7行代码 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) 这个条件是判断 view 是不可用状态，而在该条件下我们看第17行代码 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class="line"> || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div></pre></td></tr></table></figure>
<p>   这个返回结果是判断只要 view 是可点击状态 那么返回值就问 true ，即如果  view 是不可用状态，但只要 view 是可点击状态，就会消耗点击事件，只不过不响应结果。<br>   再看第33行会判断只要 view 是可点击的，那么就会进入到下面的 switch 语句，最终在第123行返回 true，即只要 view 是可点击的，那么 ontouchEvent（Event v) 方法就会返回 true 消费点击事件。<br>   然后在 ACTION_UP 事件触发的时候，在55行代码会执行 performClick() 方法，我们看一下这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> result;</div><div class="line">          <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</div><div class="line">          <span class="comment">//如果 mOnClickListener 不为null，就会调用</span></div><div class="line">          <span class="comment">// mOnClickListener.onClick(this) 方法</span></div><div class="line">          <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</div><div class="line">              playSoundEffect(SoundEffectConstants.CLICK);</div><div class="line">              <span class="comment">//这个方法就是 回调</span></div><div class="line">              <span class="comment">//我们给 view 设置的 view.setOnClickListener()方法</span></div><div class="line">              li.mOnClickListener.onClick(<span class="keyword">this</span>);</div><div class="line">              result = <span class="keyword">true</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              result = <span class="keyword">false</span>;</div><div class="line">          &#125;</div><div class="line">   sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</div><div class="line">     <span class="keyword">return</span> result;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>   上面第6行代码 if (li != null &amp;&amp; li.mOnClickListener != null) 判断如果给当前 view 设置了点击事件，那么就会执行回调设置的 onClick() 方法即 mOnClickListener.onClick(this)，这样 view 的 dispatchTouchEvent(MotionEvent event) 这里就分析结束了！</p>
<h4 id="3-ViewGroup-对点击事件的处理过程"><a href="#3-ViewGroup-对点击事件的处理过程" class="headerlink" title="3 ViewGroup 对点击事件的处理过程"></a>3 ViewGroup 对点击事件的处理过程</h4><p>   同样我们来看一下 ViewGroup 中 dispatchTouchEvent 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">  ............</div><div class="line"><span class="comment">//标记是否分发成功</span></div><div class="line"><span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</div><div class="line"><span class="comment">// 第1步：检测是否要分发该触摸事件</span></div><div class="line"><span class="comment">// 如果该 View 不是位于顶部，并且有设置属性使该 View 不在顶部时不响应触摸事件</span></div><div class="line"><span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        <span class="comment">// 如果是 ACTION_DOWN(即按下事件)，则清空之前的触摸事件处理目标和状态。</span></div><div class="line">        cancelAndClearTouchTargets(ev);</div><div class="line">        resetTouchState();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 标记 ViewGroup 是否要拦截事件</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</div><div class="line">  <span class="comment">//第2步，判断是否拦截事件</span></div><div class="line">    <span class="comment">// 如果是 ACTION_DOWN  或者 mFirstTouchTarget不为null , </span></div><div class="line">  <span class="comment">//记住 mFirstTouchTarget 在事件分发到</span></div><div class="line">    <span class="comment">// 子 view 的时候会被负值， 即一旦 事件传递到子 view 后 mFirstTouchTarget 不为 null ,而</span></div><div class="line">    <span class="comment">// 一旦在 ACTION_DOWN 时候拦截了事件，那么 mFirstTouchTarget=null ;此时 intercepted=true</span></div><div class="line">    <span class="comment">//进行拦截，这就是前面说的，一旦在 ACTION_DOWN 时候拦截了事件，那么后续事件将由 ViewGroup</span></div><div class="line">    <span class="comment">//处理，不分发到子 view 。</span></div><div class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">            || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 检查禁止拦截标记：FLAG_DISALLOW_INTERCEPT</span></div><div class="line">        <span class="comment">// 如果调用了子 view 调用了 requestDisallowInterceptTouchEvent()标记的话，</span></div><div class="line">      <span class="comment">//则FLAG_DISALLOW_INTERCEPT会为true。</span></div><div class="line">        <span class="comment">//意思是禁止父类进行拦截事件</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">            <span class="comment">// 如果禁止拦截标示为 false ,那么调用 ViewGroup 的onInterceptTouchEvent(ev) 方法</span></div><div class="line">            <span class="comment">//获取是否拦截标记 ，onInterceptTouchEvent(ev) 返回值默认为 false</span></div><div class="line">            intercepted = onInterceptTouchEvent(ev);</div><div class="line">            ev.setAction(action); <span class="comment">// restore action in case it was changed</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//如果子 view 调用了requestDisallowInterceptTouchEvent() ，</span></div><div class="line">          <span class="comment">//那么 !disallowIntercept 为false ，此时 intercepted=false，</span></div><div class="line">          <span class="comment">//ViewGroup 的 onInterceptTouchEvent(ev) 将失效</span></div><div class="line">            intercepted = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//这就是上面提到的 一旦在 ACTION_DOWN 时候拦截了事件，那么 mFirstTouchTarget=null</span></div><div class="line">        <span class="comment">//此时  intercepted = true; 继续拦截</span></div><div class="line">        intercepted = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ..............</div><div class="line"></div><div class="line">    TouchTarget newTouchTarget = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//  标记已经将事件是否发生到目标 view</span></div><div class="line">    <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</div><div class="line">        View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</div><div class="line">                ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</div><div class="line">         <span class="comment">//第3步，如果不拦截，不取消，进行事件分发</span></div><div class="line">        <span class="comment">// 在 ACTION_DOWN、ACTION_POINTER_DOWN 或者 ACTION_HOVER_MOVE 动作的时候执行</span></div><div class="line">        <span class="comment">// 在MotionEvent.ACTION_MOVE 、MotionEvent.ACTION_UP 动作的时候不会执行以下代码</span></div><div class="line">        <span class="comment">//会从下面 第7步开始执行</span></div><div class="line">      <span class="comment">//if (mFirstTouchTarget == null) 行代码执行，而如果从ACTION_DOWN开始没有事件传</span></div><div class="line">      <span class="comment">//递到子 view ，那么if (mFirstTouchTarget == null) 条件就会成立，</span></div><div class="line">      <span class="comment">// 否则会执行 while (target != null) ， </span></div><div class="line">      <span class="comment">//直接遍历mFirstTouchTarget链表，查找之前接受ACTION_DOWN的子view，</span></div><div class="line">        <span class="comment">// 并将触摸事件分配给这些子 view 。也就是前面说的说，</span></div><div class="line">      <span class="comment">//如果ViewGroup的某个孩子没有接受ACTION_DOWN事件；</span></div><div class="line">        <span class="comment">// 那么，ACTION_MOVE和ACTION_UP等事件也一定不会分发给这个孩子！</span></div><div class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</div><div class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</div><div class="line">                    : TouchTarget.ALL_POINTER_IDS;</div><div class="line"></div><div class="line">            <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></div><div class="line">            <span class="comment">// have become out of sync.</span></div><div class="line">            removePointersFromTouchTargets(idBitsToAssign);</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</div><div class="line">            <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</div><div class="line">                <span class="comment">// Find a child that can receive the event.</span></div><div class="line">                <span class="comment">// Scan children from front to back.</span></div><div class="line">                <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></div><div class="line">                        &amp;&amp; isChildrenDrawingOrderEnabled();</div><div class="line">                   <span class="comment">// 获取该 ViewGroup 包含的子 View 和 ViewGroup </span></div><div class="line">                <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">                <span class="comment">// 第4步，遍历 ViewGroup的 孩子，对触摸事件进行分发。</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder</div><div class="line">                            ? getChildDrawingOrder(childrenCount, i) : i;</div><div class="line">                    <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</div><div class="line">                            ? children[childIndex] : preorderedList.get(childIndex);</div><div class="line">                    <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line">                        childWithAccessibilityFocus = <span class="keyword">null</span>;</div><div class="line">                        i = childrenCount - <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//判断子 View 是否可以接受事件</span></div><div class="line">                    <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</div><div class="line">                            || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</div><div class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// getTouchTarget() 的作用是查找 child 是否存在于</span></div><div class="line">                  <span class="comment">//mFirstTouchTarget 的单链表中。</span></div><div class="line">                    <span class="comment">// 是的话，返回对应的 TouchTarge t对象；跳出循环</span></div><div class="line">                    newTouchTarget = getTouchTarget(child);</div><div class="line">                    <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// Child is already receiving touch within its bounds.</span></div><div class="line">                        <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></div><div class="line">                        newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    resetCancelNextUpFlag(child);</div><div class="line">                    <span class="comment">// 第5步，真正开始执行事件分发</span></div><div class="line">                  <span class="comment">//调用 dispatchTransformedTouchEvent() 执行触摸事件分发给 child。</span></div><div class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">                        <span class="comment">// Child wants to receive touch within its bounds.</span></div><div class="line">                        mLastTouchDownTime = ev.getDownTime();</div><div class="line">                        <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</div><div class="line">                            <span class="comment">// childIndex points into presorted list, find original index</span></div><div class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</div><div class="line">                                <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                                    mLastTouchDownIndex = j;</div><div class="line">                                    <span class="keyword">break</span>;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            mLastTouchDownIndex = childIndex;</div><div class="line">                        &#125;</div><div class="line">                        mLastTouchDownX = ev.getX();</div><div class="line">                        mLastTouchDownY = ev.getY();</div><div class="line">                           </div><div class="line">                        <span class="comment">//第6步，如果事件分发成功  调用 addTouchTarget()</span></div><div class="line">                      <span class="comment">//将 child 添加到 mFirstTouchTarget 链表中，</span></div><div class="line">                        <span class="comment">// 并返回表头对应的 TouchTarge ,mFirstTouchTarget 将被负值</span></div><div class="line">                        newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                        <span class="comment">// 分发成功 设置 alreadyDispatchedToNewTouchTarget </span></div><div class="line">                      <span class="comment">//标记为 true 跳出循环</span></div><div class="line">                        alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">// The accessibility focus didn't handle the event, so clear</span></div><div class="line">                    <span class="comment">// the flag and do a normal dispatch to all children.</span></div><div class="line">                    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Did not find a child to receive the event.</span></div><div class="line">                <span class="comment">// Assign the pointer to the least recently added target.</span></div><div class="line">                newTouchTarget = mFirstTouchTarget;</div><div class="line">                <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</div><div class="line">                    newTouchTarget = newTouchTarget.next;</div><div class="line">                &#125;</div><div class="line">                newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 第7步，进一步的对触摸事件进行分发，如果mFirstTouchTarget为null，</span></div><div class="line">    <span class="comment">// 意味着还没有任何View来接受该触摸事件；</span></div><div class="line">    <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 调用 ViewGroup 的父类，即 view 的dispatchTouchEvent(MotionEvent ev)方法处理</span></div><div class="line">      <span class="comment">//处理方法就是我们上面分析的 view 对点击事件的分发流程</span></div><div class="line">        <span class="comment">// 并将分发结果的返回值赋值给 handler 进行返回</span></div><div class="line">        handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</div><div class="line">                TouchTarget.ALL_POINTER_IDS);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></div><div class="line">        <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></div><div class="line">        TouchTarget predecessor = <span class="keyword">null</span>;</div><div class="line">        TouchTarget target = mFirstTouchTarget;</div><div class="line">        <span class="comment">// 如果mFirstTouchTarget ！= null，则循环从链表 mFirstTouchTarget 中取出 target</span></div><div class="line">        <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> TouchTarget next = target.next;</div><div class="line">            <span class="comment">// 如果 alreadyDispatchedToNewTouchTarget 为 true</span></div><div class="line">            <span class="comment">// 并且target == newTouchTarget 即事件(ACTION_DOWN)已经分发成功设置 handled=true</span></div><div class="line">            <span class="comment">// 返回事件分发成功</span></div><div class="line">            <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</div><div class="line">                handled = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</div><div class="line">                        || intercepted;</div><div class="line">                <span class="comment">// 如果 alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget 条件</span></div><div class="line">                <span class="comment">//不成立，说明该事件还没有进行分发(ACTION_MOVE、ACTION_UP）</span></div><div class="line">              <span class="comment">//那么将此事件分发给之前已经成功接收事件的子</span></div><div class="line">                <span class="comment">// view ，即 target.child ，并将执行 handled = true 表示事件分发结果成功</span></div><div class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class="line">                        target.child, target.pointerIdBits)) &#123;</div><div class="line">                    handled = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                ..........</div><div class="line">                <span class="comment">//返回事件处理结果</span></div><div class="line">                <span class="keyword">return</span> handled;</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>事件分发主要分为以上几个步骤，代码中已经标出，下面加以总结：</p>
<p>在上面执行第2步的时候，ViewGroup 在两种情况下会判断是否拦截事件即 事件类型为 ACTION_DOWN 和 mFirstTouchTarget ！= null 条件下， ACTION_DOWN  好理解，那么 mFirstTouchTarget ！= null  是什么意思呢，我们看一下在执行第5步，事件由 ViewGroup 子 View 处理成功的时候有一行代码是：newTouchTarget = addTouchTarget(child, idBitsToAssign);这行代码实现方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</div><div class="line">    TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</div><div class="line">    target.next = mFirstTouchTarget;</div><div class="line">    mFirstTouchTarget = target;</div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面代码可以看出，事件由 ViewGroup 子 View 处理成功的时候 mFirstTouchTarget 将会被赋值，即事件分发到子 view 的时候mFirstTouchTarget ！= null，反过来如果事件由 ViewGroup 进行拦截，那么mFirstTouchTarget ！= null 就不成立，那么当 ACTION_MOVE 和 ACIONT_UP 事件到来的时候  if (actionMasked == MotionEvent.ACTION_DOWN    || mFirstTouchTarget != null) 条件为 false，将导致 ViewGroup 的 onInterceptTouchEvent(ev) 方法不再调用，同一系列事件中的其他事件将由 ViewGroup 进行处理。当然有一种特殊情况，就是 FLAG_DISALLOW_INTERCEPT 这个标记位，这个标记位是子 view 调用了 requestDisallowInterceptTouchEvent() 来进行设置，ViewGroup 将无法进行拦截除了 ACTION_DOWN 以外的其他事件，这是因为在进行 ACTION_DOWN 的时候，会重置 FLAG_DISALLOW_INTERCEPT  这个标记位，这样导致子 view 设置的 requestDisallowInterceptTouchEvent() 失效。</p>
<p>在看一下第5步，是如何调用 dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)  方法进行事件分发的，这行代码实现方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></div><div class="line">        View child, <span class="keyword">int</span> desiredPointerIdBits) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</div><div class="line"></div><div class="line">    <span class="comment">// Canceling motions is a special case.  We don't need to perform any transformations</span></div><div class="line">    <span class="comment">// or filtering.  The important part is the action, not the contents.</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</div><div class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</div><div class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</div><div class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            handled = child.dispatchTouchEvent(event);</div><div class="line">        &#125;</div><div class="line">        event.setAction(oldAction);</div><div class="line">        <span class="keyword">return</span> handled;</div><div class="line">    &#125;</div><div class="line">    .......</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们只看与我们要分析目标相关的代码，上面代码中我们看到，如果 child!=null ，那么执行 handled = child.dispatchTouchEvent(event) 之后的逻辑就是前面分析的 view 的事件分发，这样就完成了事件分发到子 view 的流程，我们看 child.dispatchTouchEvent(event) 是由返回值的，即如果返回 true ，事件由子 view 消费，事件分发成功，跳出第4步 for 循环，停止遍历子 view。</p>
<p>我们再看一下第7步，如果 mFirstTouchTarget == null ，说明没有任何子 view 接受触摸事件，那么调用 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS) 注意这里第三个参数传入 null，就是我们上面分析的另一种情况 ，如果 child == null ，执行 handled = super.dispatchTouchEvent(event) ，而 ViewGroup 的父类是 view ，所以之后的处理逻辑又和前面说的 view 一样了，即 ViewGroup 的 onTouch 方法会得到执行 ，而如果 mFirstTouchTarget ！= null ，表明已经有事件分发成功了，那么会执行  while (target != null) 循环从从链表 mFirstTouchTarget 中取出 target，条件 if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget)  如果成立，那么说明这个事件是是已经分发过成功的事件，那么直接执行 handled = true ，即让 dispatchTouchEvent 方法返回 true， 表明事件分发成功，而如果 if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget)  不成立，表明该事件是新到来的事件还没进行分发，那么执行 dispatchTransformedTouchEvent(ev, cancelChild,  target.child, target.pointerIdBits)) ，进一步对事件进行分发，并将 分发处理结果进行返回，这这情况下就是前面 第3步所说，不执行第三步，直接执行第7步对事件进一步就行分发。</p>
<p>最后说了这么多，大家可以结合下面这张流程图来对整理分发流程进行梳理，图片引自：</p>
<p><a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="external">图解 Android 事件分发机制</a>  </p>
<p><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/TouchEvent_disaptch.png?raw=true" alt="TouchEvent_disaptch"></p>
<p>其中 super 表示调用关系，true 表示消费事件， false 表示没有消费事件。</p>
<p>到这里关于 View 的事件分发分析就结束了！</p>
<p>如果感觉笔者写的不好，可以参考以下博客：</p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/9153747" target="_blank" rel="external">郭神的 Android事件分发机制完全解析，带你从源码的角度彻底理解(下)</a></p>
<p><a href="http://wangkuiwu.github.io/2015/01/04/TouchEvent-ViewGroup/" target="_blank" rel="external">skywangkw 的Android 触摸事件机制(四) ViewGroup中触摸事件详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/28/view_touchEvent_dispatch/" data-id="civnx6lmw000dv0q7u4trv5f7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-View/">Android View</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-view_to_scroll" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/14/view_to_scroll/" class="article-date">
  <time datetime="2016-08-14T13:53:40.806Z" itemprop="datePublished">2016-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-View-学习/">Android View 学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/14/view_to_scroll/">Android 开发艺术探索第3章 3.2-3.3 View 滑动和弹性滑动读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="3-2-View-的滑动"><a href="#3-2-View-的滑动" class="headerlink" title="3.2 View 的滑动"></a>3.2 View 的滑动</h2><p>3.1节中介绍了View的基础知识，有了这些基础知识和概念，我们就可以根据需要对 View 做一些操作，在Android设备上，最常见的一个操作就是滑动，如此可见滑动是很重要的知识，只有具备了滑动的基础知识才能做出更复杂炫酷的滑动效果，复杂的效果是由不同的滑动基础组成，通常View 的滑动可以由三种方式：使用scrollTo或scrollBy、通过动画给View 添加平移效果实现滑动、通过改变 View 的布局参数 LayoutParams 实现滑动，下面进行逐一分析。</p>
<h3 id="3-2-1-使用scrollTo或scrollBy进行滑动"><a href="#3-2-1-使用scrollTo或scrollBy进行滑动" class="headerlink" title="3.2.1 使用scrollTo或scrollBy进行滑动"></a>3.2.1 使用scrollTo或scrollBy进行滑动</h3><p>Android 中 View 为我们提供了两个专门的方法 scrollTo或scrollBy 来实现  View 的滑动，scrollTo 是滑动到某一坐标，是绝对滑动，View 调用的时候只能进行一次滑动，比如将 View 从 A 点滑动到 B 点；而scrollBy是滑动一段距离，是相对滑动，可以进行连续滑动，View 每次进行调用的时候都会将 View 滑动指定的距离。下面看一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * 绝对滑动</div><div class="line">  * <span class="doctag">@param</span> x 指定水平方向滑动像素</div><div class="line">  * <span class="doctag">@param</span> y 指定竖直方向滑动像素</div><div class="line">  */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">      <span class="comment">//位置发生了改变</span></div><div class="line">        <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</div><div class="line">            <span class="keyword">int</span> oldX = mScrollX;</div><div class="line">            <span class="keyword">int</span> oldY = mScrollY;</div><div class="line">            mScrollX = x;</div><div class="line">            mScrollY = y;d</div><div class="line">          <span class="comment">//使父视图清出子view，作用是重新创建显示的内容</span></div><div class="line">          <span class="comment">//主要应用场景是view 的渐变度改变，滑动，旋转等</span></div><div class="line">            invalidateParentCaches();</div><div class="line">          <span class="comment">//使View内容进行滑动</span></div><div class="line">            onScrollChanged(mScrollX, mScrollY, oldX, oldY);	</div><div class="line">          <span class="comment">//触发scrollbars进行绘制		              	      </span></div><div class="line">          <span class="comment">//如果正在动画播放完毕返回</span></div><div class="line">          <span class="comment">//ture 否则返回false</span></div><div class="line">            <span class="keyword">if</span> (!awakenScrollBars()) &#123;</div><div class="line">              <span class="comment">//在动画期间（下一个动画开始)，使view重新绘制</span></div><div class="line">                postInvalidateOnAnimation();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">  * 进行相对滑动</div><div class="line">  * <span class="doctag">@param</span> x  指定水平方向滑动像素</div><div class="line">  * <span class="doctag">@param</span> y 指定竖直方向滑动像素</div><div class="line">  */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        scrollTo(mScrollX + x, mScrollY + y);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过源码可以看出实际上scrollBy调用了scrollTo方法，实现了基于当前位置的相对滑动。其中 mScrollX 、mScrollY 这两个参数表示View内容的偏移量，单位为px，可以通过getScrollX 和 getScrollY 得到，mScrollX  是等于View的左边缘和View内容左边缘在水平方向的距离，并且当View内容左边缘在View左边缘的右侧的时候，mScrollX为负，反之为正,View边缘是指 View 的位置，由四个顶点组成，而 View内容边缘是指 View 的内容边缘；同理，mScrollY是等于View的上边缘和View内容上边缘在数值方向的距离，并且 View 内容上边缘在View上边缘下侧的时候，mScrollY为负，反之为正；scrollTo或scrollBy只能改变 View内容的位置不能改变View 在布局中的位置（即View的布局参数比如Top、Left、X、Y等不会改变），即不能改变 View 本身的位置，对于一个View来说，其本身是一个容器，而View内容是容器里面的东西，对于一个ViewGroup来说，那么它的内容是它的所有子View。</p>
<p>为了方便理解，下面用几幅图描述mScrollX、mScrollY和View内容的关系：</p>
<p><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/view_scroll.png?raw=true" alt="view_scroll"></p>
<h3 id="3-2-2-使用动画"><a href="#3-2-2-使用动画" class="headerlink" title="3.2.2 使用动画"></a>3.2.2 使用动画</h3><p>使用动画来移动view主要是操作view的translationX和translationY属性，既可以使用传统的view动画，也可以使用属性动画，使用后者需要考虑兼容性问题，如果要兼容Android 3.0以下版本系统的话推荐使用开元动画库<a href="http://nineoldandroids.com/" target="_blank" rel="external">nineoldandroids</a>。采用 View 动画 示例代码如下，此动画可以使 View在100ms内从原始位置向右下角移动100个像素。在项目的res目录中，创建一个名为anim的目录，创建动画资源文件 translation.xml 代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;set xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    android:fillAfter="true"&gt;</div><div class="line">    &lt;translate</div><div class="line">        android:duration="100"</div><div class="line">        android:fromXDelta="0"</div><div class="line">        android:fromYDelta="0"</div><div class="line">        android:toXDelta="100"</div><div class="line">        android:toYDelta="100" /&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure>
<p>java 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Animation animation = AnimationUtils.loadAnimation(<span class="keyword">this</span>,R.anim.translation);</div><div class="line"><span class="comment">//开始动画平移</span></div><div class="line">targetView.startAnimation(animation);</div></pre></td></tr></table></figure>
<p>注意，使用这种方式进行平移，View动画只是对View的影像做操作，它并不能真正改变View的位置参数，如果这个View设置了点击事件，点击动画后的新位置无法触发点击事件的，点击原来的位置可以出发事件，这这是因为View本身位置其实没有变化造成，解决方案是通过在目标位置创建一个一模一样的隐藏的view，设置同样的点击事件，当view移动到目标位置后，隐藏被移动的view，显示目标位置view，这样就可以达到点击效果。使用属性动画没有此问题，但3.0之前系统无属性动画，这个时候可以使用动画兼容库<a href="http://nineoldandroids.com/" target="_blank" rel="external">nineoldandroids</a>来实现属性动画，尽管如此，使用动画兼容库在3.0以后手机上实现属性动画本质上还是View动画。在100ms内将view向右平移100个像素代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, <span class="string">"translationX"</span>, <span class="number">0.0f</span>, <span class="number">100.0f</span>);</div><div class="line">animator.setDuration(<span class="number">100</span>).start();</div></pre></td></tr></table></figure>
<p>fFloat()方法的第一个参数表示动画操作的对象（可以是任意对象），第二个参数表示操作对象的属性名字（只要是对象有的属性都可以）,第三个参数之后就是动画过渡值。过度值可以有一个到N个，如果是一个值的话默认这个值是动画过渡值的结束值。如果有N个值，动画就在这N个值之间过渡。</p>
<h3 id="3-2-3-改变布局参数"><a href="#3-2-3-改变布局参数" class="headerlink" title="3.2.3 改变布局参数"></a>3.2.3 改变布局参数</h3><p>改变布局参数实现滑动，即改变LayoutParams,如想将一个View右平移100px，只需要将该View的LayoutParams里的marginLeft增加100px即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) view.getLayoutParams();  <span class="comment">//获取view的布局参数</span></div><div class="line">params.leftMargin += <span class="number">100</span>;     <span class="comment">//修改leftMargin的值，相当于xml布局文件中的margin_left的值</span></div><div class="line">view.setLayoutParams(params);  <span class="comment">//将新的params值设置进view</span></div><div class="line"><span class="comment">//或者调用   view.requestLayout();</span></div></pre></td></tr></table></figure>
<p>作者还提供了另一种思路是：可以在目标View 旁边放置一个宽度为0的view，当需要移动目标view 的时候，只需要给旁边的view设定需要移动的宽度即可，这样目标view自然就会被挤到目标位置。</p>
<p>针对以上三种view滑动总结如下：</p>
<ol>
<li>scrollTo/scrollBy:只适合对view的内容的滑动</li>
<li>属性动画：操作简单，功能强大，能实现复杂的动画效果，不建议用于有交互的View。</li>
<li>改变布局参数:适用于交互性强的View。</li>
</ol>
<p>根据以上三种滑动原理我们选择一种来实现一个可以在全屏进行滑动的view，实现原理是通过重写view 的TouchEvent方法，处理ACTION_MOVE方法，那么我们选择哪一种方式合适呢？第一种scrollBy方式，由于scrollBy是能实现view的内容滑动，而view本身没有滑动，所以所以不能满足需求，而属性动画和改变view布局方式，都可以满足，下面是选择较为简单方式，通过动画动画兼容库<a href="http://nineoldandroids.com/" target="_blank" rel="external">nineoldandroids</a>方式实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestButton</span> <span class="keyword">extends</span> <span class="title">TextView</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"TestButton"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mScaledTouchSlop;</div><div class="line"><span class="comment">// 分别记录上次滑动的坐标</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mLastX = <span class="number">0</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mLastY = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestButton</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestButton</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(context, attrs);</div><div class="line">    init();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestButton</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">    init();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">    mScaledTouchSlop = ViewConfiguration.get(getContext())</div><div class="line">            .getScaledTouchSlop();</div><div class="line">    Log.d(TAG, <span class="string">"sts:"</span> + mScaledTouchSlop);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressLint</span>(<span class="string">"ClickableViewAccessibility"</span>)</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">  <span class="comment">//获取当前点击事件在屏幕中的坐标，注意：不是相对view本身坐标，不能用getX 和getY</span></div><div class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getRawX();</div><div class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getRawY();</div><div class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">        <span class="comment">//按下手势，无需处理</span></div><div class="line">    <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">        <span class="comment">//在此处理滑动事件</span></div><div class="line">    <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</div><div class="line">      <span class="comment">//计算滑动距离</span></div><div class="line">        <span class="keyword">int</span> deltaX = x - mLastX;</div><div class="line">        <span class="keyword">int</span> deltaY = y - mLastY;</div><div class="line">        Log.d(TAG, <span class="string">"move, deltaX:"</span> + deltaX + <span class="string">" deltaY:"</span> + deltaY);</div><div class="line">      <span class="comment">//就算偏移距离</span></div><div class="line">        <span class="keyword">int</span> translationX = (<span class="keyword">int</span>)ViewHelper.getTranslationX(<span class="keyword">this</span>) + deltaX;</div><div class="line">        <span class="keyword">int</span> translationY = (<span class="keyword">int</span>)ViewHelper.getTranslationY(<span class="keyword">this</span>) + deltaY;</div><div class="line">      <span class="comment">//进行滑动</span></div><div class="line">        ViewHelper.setTranslationX(<span class="keyword">this</span>, translationX);</div><div class="line">        ViewHelper.setTranslationY(<span class="keyword">this</span>, translationY);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">        <span class="comment">//抬起手势无需处理</span></div><div class="line">    <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//记录滑动后坐标</span></div><div class="line">    mLastX = x;</div><div class="line">    mLastY = y;</div><div class="line">  <span class="comment">//事件消费，返回false，无法滑动，后面会讲到view的事件分发机制有关。</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-3-弹性滑动"><a href="#3-3-弹性滑动" class="headerlink" title="3.3 弹性滑动"></a>3.3 弹性滑动</h2><p>实现弹性滑动的原理是：将一次大的滑动分成若干次小的滑动，并在一个时间段内完成。可以通过scroller、Handler#postDelayed 以及Thread#Sleep来完成，下面逐一介绍。</p>
<h3 id="3-3-1-使用Scroller"><a href="#3-3-1-使用Scroller" class="headerlink" title="3.3.1 使用Scroller"></a>3.3.1 使用Scroller</h3><p>在3.1.4章节介绍过通过Scroller实现滑动的典型代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Scroller mScroller = <span class="keyword">new</span> Scroller(mContext);</div><div class="line"><span class="comment">// 缓慢滚动到指定的位置  </span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX, <span class="keyword">int</span> destY)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> scrollX = getScrollX();</div><div class="line">    <span class="keyword">int</span> deltaX = destX - scrollX;</div><div class="line">    <span class="comment">// 以 1000ms 内滑向 destX， 效果是慢慢滑动  </span></div><div class="line">    mScroller.startScroll(scrollX, destY, deltaX , <span class="number">0</span>, <span class="number">1000</span>);</div><div class="line">    <span class="comment">// View 的重绘  </span></div><div class="line">    invalidate();</div><div class="line">&#125;</div><div class="line">  <span class="comment">// 重写 computeScroll 方法，并在内部完成平滑滚动的逻辑  </span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">//判断view是在指定时间内是否完成滑动</span></div><div class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset())&#123;</div><div class="line">      <span class="comment">//通过mScroller获取当前位置，实现滑动</span></div><div class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</div><div class="line">        <span class="comment">// 再次进行重绘  </span></div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面分析一下Scroller是如何实现弹性滑动的，上面代码我们调用了mScroller.startScroll(scrollX, destY, deltaX , 0, 1000);方法，下面一起来看一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> startX 水平方向开始滑动像素. 正值代表内容向左滑动.</div><div class="line"> * <span class="doctag">@param</span> startY 竖直方向开始滑动像素. 正值代表内容向上滑动</div><div class="line"> * <span class="doctag">@param</span> dx 水平方向滑动距离. 正值代表内容向左滑动</div><div class="line"> * <span class="doctag">@param</span> dy 竖直方向滑动距离，正值代表向上滑动</div><div class="line"> * <span class="doctag">@param</span> duration 滑动时间.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span> </span>&#123;</div><div class="line">    mMode = SCROLL_MODE;</div><div class="line">  <span class="comment">//滑动是否完成标志</span></div><div class="line">    mFinished = <span class="keyword">false</span>;</div><div class="line">  <span class="comment">//滑动时间</span></div><div class="line">    mDuration = duration;</div><div class="line">  <span class="comment">//获取当前时间</span></div><div class="line">    mStartTime = AnimationUtils.currentAnimationTimeMillis();</div><div class="line">  <span class="comment">//水平方向滑动起点</span></div><div class="line">    mStartX = startX;</div><div class="line">  <span class="comment">//竖直方向滑动起点</span></div><div class="line">    mStartY = startY;</div><div class="line">  <span class="comment">//滑动终点</span></div><div class="line">    mFinalX = startX + dx;</div><div class="line">    mFinalY = startY + dy;</div><div class="line">  <span class="comment">//水平方向要滑动距离</span></div><div class="line">    mDeltaX = dx;</div><div class="line">  <span class="comment">//竖直方向要滑动距离</span></div><div class="line">    mDeltaY = dy;</div><div class="line">  <span class="comment">//滑动时间的倒数</span></div><div class="line">    mDurationReciprocal = <span class="number">1.0f</span> / (<span class="keyword">float</span>) mDuration;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意以上滑动是实现view的内容滑动，而且可以看到startScroll方法竟然没有做任何滑动的事情，只是将要进行滑动的参数传递进来并进行了保存，因此仅仅调用startScroll方法是无法实现滑动的，而正在使view 进行滑动的关键代码是invalidate()，为什么呢？因为调用invalidate()方法后会使 view进行重新绘制，这样就会调用view的 draw 方法，view 的draw方法又会去调用computeScroll() 方法，computeScroll方法在view 内部是一个空方法，需要我们自己去实现，上面典型代码中我们调用scrollTo方法，因此实现了view 的滑动，接着又调用postInvalidate（）方法，使view进行第二次重新绘制，这样绘制过程又和第一次一样重新走一遍，这样反复调用就完成了view 的滑动；那么什么时候完成停止绘制呢?判断条件就是mScroller.computeScrollOffset()，这个方法会根据时间的流逝计算当前Scrollx和ScrollYD 值，返回ture表示滑动未结束。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">computeScrollOffset</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mFinished) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> timePassed = (<span class="keyword">int</span>)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);</div><div class="line">    <span class="keyword">if</span> (timePassed &lt; mDuration) &#123;</div><div class="line">        <span class="keyword">switch</span> (mMode) &#123;</div><div class="line">        <span class="keyword">case</span> SCROLL_MODE:</div><div class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</div><div class="line">            mCurrX = mStartX + Math.round(x * mDeltaX);</div><div class="line">            mCurrY = mStartY + Math.round(x * mDeltaY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">           ......</div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        mCurrX = mFinalX;</div><div class="line">        mCurrY = mFinalY;</div><div class="line">        mFinished = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结： Scroller 本身不能实现 View 的滑动，它需要配合 View 的 computeScroll 方法才能完成弹性滑动的效果。通过不断地让 View 重绘，而每一次重绘距离滑动其实起始时间会有一个时间间隔，通过这个时间间隔 Scroller 得出 View 当前的滑动位置，知道了滑动位置就可以通过 scrollTo 方法完成 View 的滑动。 View 的每一次重绘都会导致 View 的小幅度滑动，而多次的小幅度滑动组成了弹性滑动，这就是 Scroller 滑动的工作机制。</p>
<h3 id="3-3-2-通过动画"><a href="#3-3-2-通过动画" class="headerlink" title="3.3.2 通过动画"></a>3.3.2 通过动画</h3><p>动画本身就是一个循序渐进的过程，因此使用动画进行滑动自然就具有弹性效果，比如以下代码就可以让一个View 在100ms内向右移动100像素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, <span class="string">"translationX"</span>, <span class="number">0.0f</span>, <span class="number">100.0f</span>);</div><div class="line">animator.setDuration(<span class="number">100</span>).start();</div></pre></td></tr></table></figure>
<p>这里我们是直接使用属性动画作用于 view 使其进行滑动，很简单，下面要作者提供了一个有意思的思路实现同样的效果，就是利用属性动画的特性结合ScrollTo 方法实现 Scroller 弹性滑动效果，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scroller</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="comment">//动画起始位置</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> startX = <span class="number">0</span>;</div><div class="line">  <span class="comment">//动画要滑动的距离</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> deltax = <span class="number">1000</span>;</div><div class="line">    <span class="keyword">final</span> ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">1</span>).setDuration(<span class="number">2000</span>);</div><div class="line">  <span class="comment">//动画添加监听器</span></div><div class="line">    animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">          <span class="comment">//获取动画完成比例值</span></div><div class="line">            <span class="keyword">float</span> fraction = animator.getAnimatedFraction();</div><div class="line">          <span class="comment">//根据比例值对目标view进行滑动</span></div><div class="line">            targetView.scrollTo(startX +(<span class="keyword">int</span>)(deltax * fraction), <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">  <span class="comment">//开始执行</span></div><div class="line">    animator.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码属性动画animator 对象没有作用于任何 view 对象上，它的作用只是在2000ms内完成整个动画的过程，利用这个特性就可以在动画每一帧到来时获取动画完成比例，然后再根据这个比例计算出当前 view 所要滑动的距离，注意由于这里是使用的scrollTo() 方法，所以实质滑动的是 view 的内容。这个方法实现的思路其实和 Scroller 比较类似，都是通过计算 改变一个百分比配合 Scroller 实现 view 滑动，但是这个方法中我们还可以在onAnimationUpdate方法中添加一些我们想要实现的操作，使用更加灵活。</p>
<h3 id="3-3-3-使用延时策略"><a href="#3-3-3-使用延时策略" class="headerlink" title="3.3.3 使用延时策略"></a>3.3.3 使用延时策略</h3><p>延时策略的思想是通过发送一系列的消息从而达到一种渐进式的效果，具体来说就是使用 Handler 或 View 的 postDelayed 方法，也可以使用线程的 sleep 方法。对于postDelayed 来说可以发送一个延时消息，然后在消息中对 view 进行滑动，连续不断的发送消息，就可以对 view 实现弹性滑动。对于sleep 来说，可以通过在while 循环中不断的对 view 进行滑动和 sleep，这样把整个滑动过程切成无数个小的滑动操作达到弹性滑动的效果。</p>
<p>采用Handler大约在1000ms内将 view 向左滑动100像素，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_SCROLL_TO = <span class="number">1</span>;</div><div class="line"><span class="comment">//发送消息次数，即要滑动次数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRAME_COUNT = <span class="number">30</span>;</div><div class="line"><span class="comment">//延时时间</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAYED_TIME = <span class="number">33</span>;</div><div class="line"><span class="comment">//从0次开始</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span>  mCount = <span class="number">0</span>;</div><div class="line"><span class="meta">@SuppressLint</span>(<span class="string">"HandlerLeak"</span>)</div><div class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_SCROLL_TO:</div><div class="line">            mCount++;</div><div class="line">            <span class="keyword">if</span>(mCount &lt;= FRAME_COUNT) &#123;</div><div class="line">              <span class="comment">//计算滑动百分比</span></div><div class="line">                <span class="keyword">float</span> fraction = mCount / (<span class="keyword">float</span>) FRAME_COUNT;</div><div class="line">              <span class="comment">//计算每次要滑动距离</span></div><div class="line">                <span class="keyword">int</span> scrollX = (<span class="keyword">int</span>) (fraction * <span class="number">100</span>);</div><div class="line">              <span class="comment">//开始滑动</span></div><div class="line">                view.scrollTo(scrollX, <span class="number">0</span>);</div><div class="line">              <span class="comment">//循环发送消息实现滑动</span></div><div class="line">                mHandler.sendEmptyMessageDelayed(MESSAGE_SCROLL_TO,DELAYED_TIME);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以上是关于 view 滑动的基础知识基本讲解完毕！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/14/view_to_scroll/" data-id="civnx6lmp0006v0q7zoo3gk6l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android、View/">Android、View</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-yongyu_20160810_View3.1 basic_knowledge" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/10/yongyu_20160810_View3.1 basic_knowledge/" class="article-date">
  <time datetime="2016-08-10T15:53:03.492Z" itemprop="datePublished">2016-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-View/">Android View</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/10/yongyu_20160810_View3.1 basic_knowledge/">Android 开发艺术探索第3章 3.1View 基础知识读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载请附原文链接：<a href="http://yongyu.itscoder.com/2016/08/10/yongyu_20160810_View3.1%20basic_knowledge/" target="_blank" rel="external">Android 开发艺术探索第3章 3.1View 基础知识读书笔记</a> </p>
<h1 id="3-1-View-基础知识"><a href="#3-1-View-基础知识" class="headerlink" title="3.1 View 基础知识"></a>3.1 View 基础知识</h1><p>主要介绍内容：View 的位置参数、MotionEvent 和 TouchSlop对象、VelocityTracker, GestureDetector 和 Scroller对象。</p>
<h2 id="3-11-什么是-View"><a href="#3-11-什么是-View" class="headerlink" title="3.11 什么是 View"></a>3.11 什么是 View</h2><p>View 是Android中所有控件的基类，例如Button和TextView、ViewGroup 等常见控件他们的基类都是View，View是一种界面层的控件的一种抽象，代表了一个控件。View 本身可以是单个控件也可以是由多个控件组成的一组控件，通过这种关系就形成了View 树的结构，与Web前端中的DOM树概念相似。</p>
<h2 id="3-1-2-View的位置参数"><a href="#3-1-2-View的位置参数" class="headerlink" title="3.1.2 View的位置参数"></a>3.1.2 View的位置参数</h2><p>View 的位置主要有四个顶点决定的， top（左上角纵坐标）、left（左上角横坐标）、right（右下角横坐标）、bottom（右下角纵坐标），这些顶点的坐标是相对于 View 的父容器来说，是一种相对坐标。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/View_%20XYZ.png?raw=true" alt="View_ XYZ"></h2><p>根据上图View的坐标位置关系可以得出以下view的宽度（width)和高度（height)：</p>
<p>View的宽高和坐标关系：width = right - left，height = top - bottom。</p>
<p>view 源码中他们对应于mLeft、mRight、mTop、mBottom这四个成员变量，获取方式如下：</p>
<p>Left=getLeft() 、Right=getRight() 、Top=getTop() 、Bottom=getBottom() </p>
<p>从Android 3.0开始，view增加了：x、y、translationX、translationY 四个参数，这几个参数也是相对于父容器的坐标。x和y是左上角的坐标（偏移前或者偏移后左上角坐标，即当前坐标），而translationX和translationY是view左上角相对于父容器的偏移量(偏移坐标），默认值都是0。View 也提供了相应的方法，通过这几个坐标可以得到如下换算关系：</p>
<p>x = left + translationX  其中：x为左上角偏移后当前横坐标，left为view原始位置横坐标即可以通过getLeft（）获取，translationX  为view相对于父容器偏移横坐标。</p>
<p>y = top + translationY  其中y为左上角偏移后当前纵坐标，left为view原始位置纵坐标可以通过getTop（）获取，translationY 为view相对于父容器偏移纵坐标。</p>
<p>注意：在 View 平移的过程中， top 和 left 表示的是原始左上角的位置信息， 其值并不会发生变化， 改变的是 x, y, traslationX 和 translation Y 。</p>
<h2 id="3-1-3-MotionEvent-和-TouchSlop"><a href="#3-1-3-MotionEvent-和-TouchSlop" class="headerlink" title="3.1.3 MotionEvent 和 TouchSlop"></a>3.1.3 MotionEvent 和 TouchSlop</h2><ol>
<li>MotionEvent 是指用户手指触摸屏幕产生的一系列事件 分为  ACTION_DOWN（手指刚接触屏幕）, ACTION_MOVE（手指在屏幕上滑动）, ACTION_UP（手指从屏幕上松开瞬间）。</li>
<li>点击屏幕后松开，事件序列 DOWN-&gt;UP点击屏幕滑动一会再松开，事件序列为 DOWN-&gt;MOVE-&gt;…-&gt;MOVE-&gt;UP。</li>
<li>getX/getY获取相对当前View左上角的x和y坐标；getRawX/getRawY获取相对手机屏幕左上角的x和y坐标。</li>
<li>TouchSlop 是系统能识别滑动的最小距离，是系统常量，与设备有关，不同设备，值可能不同，当手指在屏幕上滑动，小于这个距离，系统不认为你在进行滑动操作；可通过ViewConfiguration.get（getContext()).getScaledTouchSlop()方法来获取;可以利用此参数进行一些滑动过滤，当未达到此值的时候可以认为未达到滑距离的临界值。 </li>
</ol>
<h2 id="3-1-4-VelocityTracker-、GestureDetector-和Scroller"><a href="#3-1-4-VelocityTracker-、GestureDetector-和Scroller" class="headerlink" title="3.1.4 VelocityTracker  、GestureDetector 和Scroller"></a>3.1.4 VelocityTracker  、GestureDetector 和Scroller</h2><ol>
<li><p>VelocityTracker 用于追踪手指在滑动过程中的速度。如在View的onTouchEvent方法中追踪当前单击事件的速度方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取VelocityTracker对象</span></div><div class="line">VelocityTracker velocityTracker = VelocityTracker.obtain(); </div><div class="line"><span class="comment">//将事件event添加进去</span></div><div class="line">velocityTracker.addMovement(event); </div><div class="line"><span class="comment">//获取当前滑动速度计算方法</span></div><div class="line"><span class="comment">//这里的速度是指一段时间内手指滑动过的像素数</span></div><div class="line"><span class="comment">//获取速度前需输入计算速度参数时间间隔单位ms，即计算在1000ms内手指滑动过的像素数</span></div><div class="line">velocityTracker.computeCurrentVelocity(<span class="number">1000</span>);  </div><div class="line"><span class="comment">//获取x轴速度</span></div><div class="line"><span class="keyword">int</span> xVelocity = (<span class="keyword">int</span>)velocityTracker.getXVelocity(); </div><div class="line"><span class="comment">//获取y轴速度</span></div><div class="line"><span class="keyword">int</span> yVelocity = (<span class="keyword">int</span>)velocityTracker.getYVelocity();</div></pre></td></tr></table></figure>
<p>注意：这里的速度可以为负数，手指从右向左滑动，水平方向速度即为负数，计算公式为：</p>
<p>速度 = （终点位置 - 起点位置）/ 时间段</p>
<p>计算得到的速度即为在给定时间间隔内水平方向或者竖直方向所滑动的像素数。</p>
<p>最后如果不在使用，需要调用clear进行清除和回收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重置和回收</span></div><div class="line">mVelocityTracker.clear(); <span class="comment">//一般在MotionEvent.ACTION_UP的时候调用</span></div><div class="line">mVelocityTracker.recycle(); <span class="comment">//一般在onDetachedFromWindow中调用</span></div></pre></td></tr></table></figure>
</li>
<li><p>GestureDetector</p>
<p>用于辅助检测用户的单击、滑动、长按、双击等行为；下面笔者写一个小的demo如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GestureActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span>  <span class="keyword">implements</span> <span class="title">GestureDetector</span>.<span class="title">OnGestureListener</span>,<span class="title">GestureDetector</span>.<span class="title">OnDoubleTapListener</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG =<span class="string">"GestureActivity"</span> ;</div><div class="line">    <span class="keyword">private</span> GestureDetector gestureDetector;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="comment">//创建GestureDetector对象,并设置OnGestureListener监听</span></div><div class="line">        <span class="comment">//第一个this参数为context，第二个参数为OnGestureListener</span></div><div class="line">        gestureDetector =<span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>,<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//设置双击监听</span></div><div class="line">        gestureDetector.setOnDoubleTapListener(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//解决长按屏幕无法拖拽的现象</span></div><div class="line">        gestureDetector.setIsLongpressEnabled(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//重写Activity 的onTouchEvent将MotionEvent事件设置给gestureDetector</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="comment">//接管目标 View 的 onTouchEvent 方法</span></div><div class="line">        gestureDetector.onTouchEvent(event);</div><div class="line">        <span class="comment">//返回事件处理结果</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDown</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指轻轻触摸屏幕的瞬间，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onDown"</span>+e.toString());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShowPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指轻触屏幕，尚未松开或者拖动，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onShowPress"</span>+e.toString());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指松开，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onSingleTapUp"</span>+e.toString());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指按下屏幕并拖动，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onScroll"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指长按，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onLongPress"</span>+e.toString());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</div><div class="line">        <span class="comment">// 用户按下触摸屏，快速移动后松开，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onFling"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapConfirmed</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//单击行为；根据需要处理事件</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDoubleTap</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//表示双击行为，在双击的期间,根据需要处理事件</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDoubleTapEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">       <span class="comment">// 双击，由两次连续的单击组成，根据需要处理事件</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本例子中是将手势监听设置给了整个Activity，你也可以根据实际需求设置给某个view，同样是在onTouchEvent方法中设置。</p>
<p><strong>OnGestureListener 接口的方法</strong></p>
<p>onDown : 手指轻轻触摸屏幕的瞬间，由一个 ACTION_DOWN 触发；</p>
<p>onShowPress : 手指轻触屏幕，尚未松开或者拖动， 由一个 ACTION_DOWN 触发；</p>
<p>onSingTapUp : 手指松开，由 ACTION_DOWN 触发， 这是单击行为；</p>
<p>onScroll: 手指按下屏幕并拖动，由一个 ACTION_DOWN , 多个 ACTION_MOVE 触发， 这是拖动行为；</p>
<p>onLongPress: 用户长久地按着屏幕不放，即长按；</p>
<p>onFling: 用户按下触摸屏，快速移动后松开，由一个 ACTION_DWON、多个 ACTION_MOVE 和一个 ACTION_UP 触发，快速滑动行为；</p>
<p><strong>OnDoubleTapListener 接口中的方法</strong></p>
<p>onDoubleTap: 双击，由两次连续的单击组成，不能和 onSingleTapConfirmed 共存；</p>
<p>onSingleTapConfirmed: 单击行为；</p>
<p>onDoubleEvent: 表示双击行为，在双击的期间， ACTION_DOWN、ACTION_MOVE、ACTION_UP 都不会触发此回调。</p>
<p>在实际开发中可以不使用 GestureDetector ，完全可以在View的 onTouchEvent 方法中根据MotionEvent类型以及滑动速度等条件实现所需的监听，作者建议：如果只是监听滑动相关的推荐在onTouchEvent中实现，如果需要监听双击，使用GeststureDetector。</p>
</li>
<li><p>Scroller</p>
<p>用来实现View的弹性滑动，View的scrollTo/scrollBy是瞬间完成的，Scroller本身并不能实现view的滑动，使用Scroller配合View的computeScroll方法配合使用达到弹性滑动的效果，它不断地让view重绘，而每一次重绘距滑动起始时间会有一个时间间隔，通过这个时间间隔Scroller就可以得出view的当前的滑动位置，知道了滑动位置就可以通过scrollTo方法来完成view的滑动。就这样，view的每一次重绘都会导致view进行小幅度的滑动，而多次的小幅度滑动就组成了弹性滑动，这就是Scroller的工作原理，下面3.2节会详细介绍，典型固定代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Scroller mScroller = <span class="keyword">new</span> Scroller(mContext);</div><div class="line"><span class="comment">// 缓慢滚动到指定的位置  </span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX, <span class="keyword">int</span> destY)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> scrollX = getScrollX();</div><div class="line">    <span class="keyword">int</span> deltaX = destX - scrollX;</div><div class="line">    <span class="comment">// 以 1000ms 内滑向 destX， 效果是慢慢滑动  </span></div><div class="line">    mScroller.startScroll(scrollX, destY, deltaX , <span class="number">0</span>, <span class="number">1000</span>);</div><div class="line">    <span class="comment">// View 的重绘  </span></div><div class="line">    invalidate();</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 重写 computeScroll 方法，并在内部完成平滑滚动的逻辑  </span></div><div class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset())&#123;</div><div class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</div><div class="line">        <span class="comment">// 再次进行重绘  </span></div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此关于View的基础知识基本结束，如有笔误，或者理解错误的地方，望多多指导！！</p>
<p>​</p>
<p>​</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/10/yongyu_20160810_View3.1 basic_knowledge/" data-id="civnx6lms000bv0q766s98aqg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android、View基础/">Android、View基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-yongyu_20160803_volley_use_and_source_code_study" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/07/yongyu_20160803_volley_use_and_source_code_study/" class="article-date">
  <time datetime="2016-08-07T14:49:40.965Z" itemprop="datePublished">2016-08-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android源码学习/">Android源码学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/07/yongyu_20160803_volley_use_and_source_code_study/">Volley学习笔记之简单使用及部分源码详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载请附原文链接：<a href="http://yongyu.itscoder.com/2016/08/07/yongyu_20160803_volley_use_and_source_code_study/" target="_blank" rel="external">Volley学习笔记之简单使用及部分源码详解</a> </p>
<h2 id="一、使用背景简介"><a href="#一、使用背景简介" class="headerlink" title="一、使用背景简介"></a>一、使用背景简介</h2><p>现在大多数手机 App 几乎都离不开网络技术，需要手机端与网络服务端进行数据交互，Android 系统中主要提供了两种方式来进行HTTP通信，HttpURLConnection 和 HttpClient，在初学 Android 的时候，这两个类是我们最开始学着使用的，但是在使用过程中需要调取各种API，进行封，然后请求到的结果需要自己去解析，最后再将解析到的数据进行封装存到数据库，整个过程，相当复杂，而且重复性很高，于是针对这种情况，网络上就有大神封装了各种第三方框架供我们使用，将这些复杂冗余操作进行组合优化，使得整个编写过程得以简化，只需简单配置几行代码就可以完成整个流程操作。今天我们介绍的 Volley  就是其中一个优秀第三方框架。笔者所在公司目前项目使用的就是Volley ，所以在使用的同时决定写一系列笔记分析，从学会简单使用，到最后的 Volley 源码分析一系列循序渐进的流程来理解Volley的实现原理。</p>
<h2 id="二、Volley简介"><a href="#二、Volley简介" class="headerlink" title="二、Volley简介"></a>二、Volley简介</h2><p>Volley 是 Google在 Google I/O 2013 大会上 推出的 Android 异步网络请求和图片加载框架。</p>
<ul>
<li><p>主要作用 ：实现异步网络请求、图片加载。</p>
</li>
<li><p>主要特点：</p>
<p>(1).  Volley基于接口设计，扩展性强，我们可以根据我们的需求定制自己想要的请求方式方法。<br>(2).  一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。<br>(3).  默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现。</p>
<p>(4). 支持指定请求的优先级。</p>
<p>(5). 高并发网络连接。</p>
</li>
<li><p>使用下载地址：<a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="external">https://android.googlesource.com/platform/frameworks/volley</a></p>
<p>可以使用git 下载命令 git clone  <a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="external">https://android.googlesource.com/platform/frameworks/volley</a></p>
<ul>
<li>编译jar：<br><code>android update project -p . ant jar</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>添加volley.jar到你的项目中</p>
<p>  <strong>不过已经有人将volley的代码放到github上了：</strong><br>  <a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="external">https://github.com/mcxiaoke/android-volley</a>，你可以使用更加简单的方式来使用volley</p>
</li>
</ul>
<h2 id="三、简单使用"><a href="#三、简单使用" class="headerlink" title="三、简单使用"></a>三、简单使用</h2><p>使用Volley框架实现网络数据请求主要有以下三个步骤：</p>
<ol>
<li>创建RequestQueue对象，定义网络请求队列，RequestQueue内部的设计就是非常合适高并发的，因此我们不必为每一次HTTP请求都创建一个RequestQueue对象，避免非常浪费资源的，一般全局使用一个就可以。</li>
<li>创建XXXRequest对象(XXXRequest对象可以自己继承Request类进行封装定义，也可以使用Volley已经为我们提供的的StringReqeust、JsonArrayRequest、JsonObjectRequest)，这个类主要是功能是传入请求网址、解析返回数据、回调监听返回数据等功能的实现，也是我们经常继承包装的类，在这里可以实现我们想要的返回数据类型。</li>
<li>把XXXRequest对象添加到RequestQueue中，开始执行网络请求。</li>
</ol>
<p>怎么样，这样看来整个网络请求是否是变得便捷，不需要你去考虑，如何调取Http请求各种API，不需要考虑异步等问题，Volley已经帮助我们完成，下面简单以StringReqeust为例子发起一个Get请求，编写一个小的Demo用例，结合代码，加深理解：</p>
<p>网络请求队列一般都是整个APP内使用的全局性对象，因此最好写入Application类中，全局只使用一个，避免浪费资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"><span class="comment">// 建立请求队列</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue queue;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    queue = Volley.newRequestQueue(getApplicationContext());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">getVolleyRequestQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> queue;</div><div class="line"> &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们还需要修改AndroidManifest.xml文件，使APP的Application对象为我们刚定义的MyApplication，并添加INTERNET权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</div><div class="line"></div><div class="line">&lt;application</div><div class="line"></div><div class="line">    android:name=&quot;.MyApplication&quot;</div><div class="line"></div><div class="line">    android:allowBackup=&quot;true&quot;</div><div class="line"></div><div class="line">    android:icon=&quot;@mipmap/ic_launcher&quot;</div><div class="line"></div><div class="line">    android:label=&quot;@string/app_name&quot;</div><div class="line"></div><div class="line">    android:supportsRtl=&quot;true&quot;</div><div class="line"></div><div class="line">    android:theme=&quot;@style/AppTheme&quot; &gt;</div><div class="line"></div><div class="line">&lt;/application&gt;</div></pre></td></tr></table></figure>
<p>创建StringReqeust对象，并将其添加到RequestQueue中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Request.Method.GET 指定请求方法，如果不输入，默认为Get方法</div><div class="line">  *  new Response.Listener &lt;String&gt; 请求成功回调接口</div><div class="line">  *   new Response.ErrorListener() 请求失败回到接口</div><div class="line">  * <span class="doctag">@param</span> url 要请求的网址</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">     StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Request.Method.GET,url, <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</div><div class="line">             <span class="comment">//这里得到我们请求成功的结果</span></div><div class="line">             Log.d(<span class="string">"TAG"</span>, response);</div><div class="line">         &#125;</div><div class="line">     &#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</div><div class="line">             <span class="comment">//这里得到我们请求请求失败的信息</span></div><div class="line">             Log.e(<span class="string">"TAG"</span>, error.getMessage());</div><div class="line">         &#125;</div><div class="line">     &#125;);</div><div class="line">     <span class="comment">//将stringRequest添加到RequestQueue中</span></div><div class="line">     MyApplication.getVolleyRequestQueue().add(stringRequest);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>好了，这样我们就完成完成了StringRequest请求操作，在onResponse方法内得到我们想要的请求结果String 类型数据。</p>
<h2 id="四、使用思考"><a href="#四、使用思考" class="headerlink" title="四、使用思考"></a>四、使用思考</h2><p>在上面使用StringRequest请求过程中，我们只需要简单三步就完成了整个请求，那么有没有想过，Volley内部是如何实现的呢，思考以下几个问题：</p>
<ol>
<li>如何实现高并发请求</li>
<li>如何实现异步请求</li>
<li>如何实现数据缓存</li>
<li>内部是如何各种继承，组合封装最后几行代码就可以实现请求功能，但是使用拓展性又那么强。</li>
</ol>
<p>相信不想只做代码搬运工的你在使用过程中也会有这些甚至更多疑问，笔者在使用过程中一直好奇这些，否则在项目中只是简单调用人家已经封装好的几行代码，总感觉自己是一个搬运工，不知其所以然，所以现在决定，静下心来，去尝试分析一下Volley源码，以此记录分享。</p>
<h2 id="五、源码分析"><a href="#五、源码分析" class="headerlink" title="五、源码分析"></a>五、源码分析</h2><p>首先我们来看看Volley官方给出的一张Volley工作流程图 </p>
<p><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/operating_principle.png?raw=true" alt="“Volley工作原理如”"></p>
<p>下面将这张图翻译如下：</p>
<p><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/operating%20principle-cn.png?raw=true" alt="“Volley工作原理如”"></p>
<p>通过上面这张图我们可以对Volley工作流程有一个大概的印象，下面我们根据这张流程图以及Volley使用过程来结源码进行分析：</p>
<p>首先从我们使用的入口Volley.newRequestQueue(context)方法来来作为我们分析的切入点，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用volley的入口，一般默认调用这个方法即可创建一个默认的网络请求列队，启动一个请求队列RequestQueue，</div><div class="line"> * 只需要往这个RequestQueue不断 add Request 即可发起请求</div><div class="line"> * <span class="doctag">@param</span> context用于创建缓存文件夹</div><div class="line"> * <span class="doctag">@return</span> 返回 instance.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法仅仅只有一行代码，只是调用了newRequestQueue()的方法重载，并给第二个参数传入null。那我们接着分析带有两个参数的newRequestQueue()方法中的代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> context A 用于创建缓存文件夹</div><div class="line"> * <span class="doctag">@param</span> stack HttpStack处理http网络请求包装，可以自己定义，如果传入null，</div><div class="line"> *那么就使用系统默认的HttpStack</div><div class="line"> * <span class="doctag">@return</span> A 返回 instance.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">return</span> newRequestQueue(context, stack, -<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法也很简单，直接调用了含三个参数的构造方法，那么我们接着看看含三个参数的构造方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> context A 用于创建缓存文件夹</div><div class="line">     * <span class="doctag">@param</span> stack HttpStack处理http网络请求包装，内部就是我		</div><div class="line">     *们使用过的HttpURLConnection或者HttpClient，进行包装处</div><div class="line">     *理，可以自己定义，也可以传入null，那么就使用系统默认的HttpStack</div><div class="line">     * <span class="doctag">@param</span> maxDiskCacheBytes 设置最大sd卡缓存,如果传入-1</div><div class="line">     *就使用默认缓存</div><div class="line">     * <span class="doctag">@return</span> A 返回 instance.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack, <span class="keyword">int</span> maxDiskCacheBytes)</span> </span>&#123;</div><div class="line">        <span class="comment">//创建指定缓存文件</span></div><div class="line">        File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * UA一般都用于统计与识别</div><div class="line">         * User-Agent是Http协议中的一部分，属于头域的组成部</div><div class="line">         *分，User Agent也简称UA。用较为普通的一点来说</div><div class="line">         * ，是一种向访问网站提供你所使用的浏览器类型、操作系统</div><div class="line">         *及版本、CPU 类型、浏览器渲染引擎、浏览器语言、浏览器插</div><div class="line">         *件等信息的标识。</div><div class="line">         * UA字符串在每次浏览器 HTTP 请求时发送到服务器</div><div class="line">         */</div><div class="line">        String userAgent = <span class="string">"volley/0"</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//获取包名</span></div><div class="line">            String packageName = context.getPackageName();</div><div class="line">            <span class="comment">//获取包信息</span></div><div class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</div><div class="line">            <span class="comment">//获取userAgent</span></div><div class="line">            userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</div><div class="line">        &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//如果传入stack参数为null，那么创建默认的stack</span></div><div class="line">        <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//如果 API 大于9采用基于 HttpURLConnection 的 //HurlStack</span></div><div class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</div><div class="line">                stack = <span class="keyword">new</span> HurlStack();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// API小于9采用基于 HttpClient 的 //HttpClientStack</span></div><div class="line">            stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="comment">//new一个网络请求包装对象，并传入stack</span></div><div class="line">        Network network = <span class="keyword">new</span> BasicNetwork(stack);</div><div class="line">        RequestQueue queue;</div><div class="line">        <span class="keyword">if</span> (maxDiskCacheBytes &lt;= -<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//没有设置最大缓存maxDiskCacheBytes，创建默认大小缓存</span></div><div class="line">           queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">//设置最大缓存大小为maxDiskCacheBytes</span></div><div class="line">           queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir, maxDiskCacheBytes), network);</div><div class="line">        &#125;</div><div class="line"><span class="comment">//启动列队</span></div><div class="line">        queue.start();</div><div class="line"><span class="comment">//返回列队instance</span></div><div class="line">        <span class="keyword">return</span> queue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法代码稍微多一点，代码已经注释，这个构造方法主要是new 了一个 负责处理网络请求部分的stack对象，然后 用BasicNetwork将stack进行包装处理，又new了一个负责缓存部分的DiskBasedCache对象，并将这两个参数传入了列队queue中，并启动了列队；这里说明一下，在创建HttpStack对象的时候是比较了一下版本号，如果Build.VERSION.SDK_INT &gt;= 9（ API大于9）， stack = new HurlStack();这里是因为在Android 2.2版本之前，HttpURLConnection一直存在着一些令人厌烦的bug，在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量。到这里我们就完成使用volley的第一步分析，即获取RequestQueue对象，那么接下来我们分析下RequestQueue构造方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 创建请求列队，传入sd卡缓存包装类，和网络请求包装类</div><div class="line"> * 会调用含三个参数的构造方法，并传入参数默认参数DEFAULT_NETWORK_THREAD_POOL_SIZE为4，即默认</div><div class="line"> *线程数为4</div><div class="line"> * <span class="doctag">@param</span> cache sd卡缓存类</div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面分析含三个参数的构造方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 调用含四个参数的构造方法并传递默认 new ExecutorDelivery(new Handler(Looper.getMainLooper()))参数</div><div class="line"> * <span class="doctag">@param</span> cache sd卡缓存类</div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> * <span class="doctag">@param</span> threadPoolSize 网络请求线程的数量，这里threadPoolSize为DEFAULT_NETWORK_THREAD_POOL_SIZE</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(cache, network, threadPoolSize,</div><div class="line">            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>含四个参数的构造方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> cache sd卡缓存类 </div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> * <span class="doctag">@param</span> threadPoolSize 网络请求线程的数量</div><div class="line"> * <span class="doctag">@param</span> delivery用来回调网络请求结果的事件分发类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,</span></span></div><div class="line">        ResponseDelivery delivery) &#123;</div><div class="line">    mCache = cache;</div><div class="line">    mNetwork = network;</div><div class="line">    <span class="comment">//创建数量为DEFAULT_NETWORK_THREAD_POOL_SIZE 即数量为4的NetworkDispatcher数组</span></div><div class="line">    mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</div><div class="line">    <span class="comment">//mDelivery为含有三个参数构造函数调用传入的new ExecutorDelivery(new </span></div><div class="line">    <span class="comment">//Handler(Looper.getMainLooper()))对象</span></div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里我们来我们发现从调用含有两个参数的RequestQueue构造方法是逐渐调用三个、四个参数构造方法，那么最终实现了：mCachesd卡缓存类的实例化，network网络请求包装类 的实例化，创建了一个数量为4的NetworkDispatcher数组，mDelivery=new ExecutorDelivery(new Handler(Looper.getMainLooper())网络请求结果回调类的实例化。那么这里我们看一下回调网络请求结果类ExecutorDelivery构造方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> 创建一个回调网络请求结果的对象</div><div class="line"> * <span class="doctag">@param</span> handler 利用handler将runnable发送出去</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">//创建一个excuter包含了一个handler，然后利用传递进来的handler来将runnable发送出去</span></div><div class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">            handler.post(command);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的handler为new Handler(Looper.getMainLooper())，即handler是创建在主线程中，所以当调用 handler.post(command)的时候，是将网络请求结果发送到主线程主去处理，这样就完成了异步任务，将子线程中网络请求的结果发送到主线程中去处理。以上就完成了构造RequestQueue对象过程中的代码分析。</p>
<p>下面还有一个疑问要分析就是我们在调用volley的时候执行的RequestQueue.add()方法，分析一下是如何将请求添加到缓存列队和网络请求列队，以及如何进行管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 该方法用于向列队中添加请求request</div><div class="line"> * 其中包含了几种列队，起到不同的作用</div><div class="line"> * mCurrentRequests列队，用于存储目前正在进行但是尚未完成的请求</div><div class="line"> * mNetworkQueue网络请求列队，用于存储走网络的请求</div><div class="line"> * mWaitingRequests 如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将当前请求和处理请求的queue进行关联，这样当该请求结束的时候就会通知负责处理该请求的queue</span></div><div class="line">    request.setRequestQueue(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">      <span class="comment">//将请求添加到当前请求列队中</span></div><div class="line">        mCurrentRequests.add(request);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//添加序列号</span></div><div class="line">    request.setSequence(getSequenceNumber());</div><div class="line">    <span class="comment">//添加标记</span></div><div class="line">    request.addMarker(<span class="string">"add-to-queue"</span>);</div><div class="line">    <span class="comment">//如果请求不能缓存，直接添加到网络请求列队，结束方法</span></div><div class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;</div><div class="line">        mNetworkQueue.add(request);</div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//如果方法走到这一步说明，我们使用了缓存功能</span></div><div class="line">    <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">      <span class="comment">//取出请求的缓存键</span></div><div class="line">        String cacheKey = request.getCacheKey();</div><div class="line">      </div><div class="line">        <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class="line">            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class="line">            <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</div><div class="line">                stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果mWaitingRequests已经包含该请求，那么将该请求添加到mWaitingRequests中</span></div><div class="line">            stagedRequests.add(request);</div><div class="line">            mWaitingRequests.put(cacheKey, stagedRequests);</div><div class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//如果该请求不在正在执行等待的类列队mWaitingRequests中，直接添加到mCacheQueue中</span></div><div class="line">            mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</div><div class="line">            mCacheQueue.add(request);</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//返回当前请求</span></div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们来捋一捋request是如何被添加到请求列队中的步骤如下：</p>
<p>1、当add一个请求request时候，首先该请求会被添加当当前请求列队mCurrentRequests中。</p>
<p>2、如果该请求不使用缓存那么直接被添加到网络请求列队mNetworkQueue结束方法。</p>
<p>3、如果该请求使用了缓存，那么先判断mWaitingRequests列队中是否有该请求，如果有那么添加到mWaitingRequests中，如果没有直接添加到缓存请求列队mCacheQueue中。</p>
<p>到这里我们理解了一个请求是如何被添加到列队中，但是同时会产生一个疑问就是mCurrentRequests和mWaitingRequests这两个列队的作用是什么，以及如何调用的，我们初略猜想一下，这两个列队中维护的请求应该在一个请求结束的时候，将该请求移除，那么应该是RequestQueue的finish方法中进行调用，那么下面我们来看一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 该方法会在Request的方法中进行调用finish(String)，表明当前请求已经结束</div><div class="line"> * 需要从mCurrentRequests和mWaitingRequests中移除保存的请求Request</div><div class="line"> */</div><div class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">      <span class="comment">//从当前请求列队mCurrentRequests中移除请求request</span></div><div class="line">        mCurrentRequests.remove(request);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (mFinishedListeners) &#123;</div><div class="line">      <span class="keyword">for</span> (RequestFinishedListener&lt;T&gt; listener : mFinishedListeners) &#123;</div><div class="line">        listener.onRequestFinished(request);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (request.shouldCache()) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">            String cacheKey = request.getCacheKey();</div><div class="line">            <span class="comment">//如果请求可以使用缓存，将mWaitingRequests中存储的waitingRequests移除</span></div><div class="line">            Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class="line">         </div><div class="line">            <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                    VolleyLog.v(<span class="string">"Releasing %d waiting requests for cacheKey=%s."</span>,</div><div class="line">                            waitingRequests.size(), cacheKey);</div><div class="line">                &#125;</div><div class="line">                 <span class="comment">//如果移除当前结束的请求后，如果移除的waitingRequests！=null，</span></div><div class="line">            <span class="comment">// 那么将其添加到缓存列队mCacheQueue</span></div><div class="line">                mCacheQueue.addAll(waitingRequests);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码只需要看注释部分即可，并不复杂，那么RequestQueue的finish应该是什么时候调用呢，我们猜想应该是在一个request方法请求结束的时候，我们来看一下在Request类的finish方法中代码是否如此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">final</span> String tag)</span> </span>&#123;</div><div class="line">  <span class="comment">//调用处</span></div><div class="line">    <span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) &#123;</div><div class="line">        mRequestQueue.finish(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (MarkerLog.ENABLED) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> threadId = Thread.currentThread().getId();</div><div class="line">        <span class="keyword">if</span> (Looper.myLooper() != Looper.getMainLooper()) &#123;</div><div class="line">            Handler mainThread = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">            mainThread.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    mEventLog.add(tag, threadId);</div><div class="line">                    mEventLog.finish(<span class="keyword">this</span>.toString());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mEventLog.add(tag, threadId);</div><div class="line">        mEventLog.finish(<span class="keyword">this</span>.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码我们在第三行看到了mRequestQueue.finish(this);那么request方法结束请求有三种可能分别是：手动调用request.cancel方法取消请求、request请求成功回调成功结果、request请求失败回调失败结果，这三种请求都是表面当前request请求结束，那么我们分别看一下这三处的代码是否进行了调用，我们以网络请求线程NetworkDispatcher为例（缓存线程调度原理相同）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行网络请求线程，耗时任务的执行</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      ........</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                    <span class="comment">//如果请求取消，结束请求</span></div><div class="line">                    request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                  <span class="comment">//继续从列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">          ........</div><div class="line">               </div><div class="line">                <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                   <span class="comment">//如果networkResponse状态为304，并且已经返回了响应结果，那么结束请求不进行第二次返回</span></div><div class="line">                    request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                  <span class="comment">//继续请求列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">               ..........</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后看一下请求结果回调类ExecutorDelivery的run，执行了该方法表明将request请求结果进行了回调，所以request.finish()方法在此处也有调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//调用处</span></div><div class="line">        <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</div><div class="line">            mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">       ........</div><div class="line">        <span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">          <span class="comment">//如果这个请求需要刷新那么这个请求又被添加到了列队中，所以还在列队中，不要finish</span></div><div class="line">            mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">//否则调用finish</span></div><div class="line">            mRequest.finish(<span class="string">"done"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">.......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样mCurrentRequests和mWaitingRequests这两个列队的管理基本就捋清楚了。</p>
<p>下面我们就要思考获取到requestQueue对象，调用requestQueue.add（request）方法后，是如何启动网络请求的，那么我们看到在RequestQueue构造方法中有一行代码    queue.start()方法，那么接下来我们来分析一下这个方法具体内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 开始执行在列队中的各个线程分发调度</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//停止所有当前正在执行分发调度事件</span></div><div class="line">    stop();  </div><div class="line">    <span class="comment">//创建一个执行缓存分发调度线程，并将mCacheQueue缓存列队, mNetworkQueue网络请求列队, mCache缓存对象, mDelivery事件分发对象传递进去</span></div><div class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class="line">    <span class="comment">//启动缓存事件分发</span></div><div class="line">    mCacheDispatcher.start();</div><div class="line">    <span class="comment">//当i &lt; mDispatchers.length时循环创建networkDispatcher对象</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">       <span class="comment">//创建一个网络请求线程调度networkDispatcher线程，并将 mCacheQueue缓存列队, mNetworkQueue网络</span></div><div class="line">       <span class="comment">//请求列队, mCache负责处理缓存对象, mDelivery事件分发对象传递进去</span></div><div class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class="line">                mCache, mDelivery);</div><div class="line">        mDispatchers[i] = networkDispatcher;</div><div class="line">        <span class="comment">//启动网络缓存线程</span></div><div class="line">        networkDispatcher.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码主要实现功能是创建一个缓存事件调度线程并启动，然后循环创建了n个网络请求线程调度networkDispatcher对象，这里n= mDispatchers.length。mDispatchers数组的长度即是构造RequestQueue过程中传入的参数DEFAULT_NETWORK_THREAD_POOL_SIZE 即数量为4，也就是说创建了4个负责网络请求调度的线程。下面我们一起分析一下CacheDispatcher缓存调度线程代码，CacheDispatcher 继承自Thread，是一个线程，先看一下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> cacheQueue 缓存列队</div><div class="line"> * <span class="doctag">@param</span> networkQueue 网络请求列队</div><div class="line"> * <span class="doctag">@param</span> cache 缓存类</div><div class="line"> * <span class="doctag">@param</span> delivery 请求结果回调分发类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheDispatcher</span><span class="params">(</span></span></div><div class="line">        BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue, BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,</div><div class="line">        Cache cache, ResponseDelivery delivery) &#123;</div><div class="line">    mCacheQueue = cacheQueue;</div><div class="line">    mNetworkQueue = networkQueue;</div><div class="line">    mCache = cache;</div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后主要看一下run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//复写Run方法，这里执行耗时操作，在子线程中执行</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</div><div class="line">    <span class="comment">//设置线程优先级</span></div><div class="line"> Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">    <span class="comment">//初始化缓存类</span></div><div class="line">    mCache.initialize();</div><div class="line">  <span class="comment">//循环从列队中读取请求并执行</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//从列队的首部取出一个request</span></div><div class="line">            <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</div><div class="line">            <span class="comment">//添加一个标记</span></div><div class="line">            request.addMarker(<span class="string">"cache-queue-take"</span>);</div><div class="line">            <span class="comment">//如果取出的请求取消，那么结束请求</span></div><div class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                request.finish(<span class="string">"cache-discard-canceled"</span>);</div><div class="line">              <span class="comment">//继续循环从缓存列队中拿请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//从缓存中读取缓存数据</span></div><div class="line">            Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//如果请求结果为null，那么添加标记</span></div><div class="line">                request.addMarker(<span class="string">"cache-miss"</span>);</div><div class="line">                 <span class="comment">//然后将请求发送到网络请求列队</span></div><div class="line">                mNetworkQueue.put(request);</div><div class="line">               <span class="comment">//然后继续循环去缓存列队中拿取请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (entry.isExpired()) &#123;</div><div class="line">                <span class="comment">//如果缓存过期，添加标记</span></div><div class="line">                request.addMarker(<span class="string">"cache-hit-expired"</span>);</div><div class="line">                request.setCacheEntry(entry);</div><div class="line">              <span class="comment">//将请求发送到网络请求列队</span></div><div class="line">                mNetworkQueue.put(request);</div><div class="line">              <span class="comment">//然后继续去缓存列队中拿取请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//走到这一步，说明已经拿到缓存，添加标记命中</span></div><div class="line">            request.addMarker(<span class="string">"cache-hit"</span>);</div><div class="line">            <span class="comment">//解析网络缓存数据NetworkResponse得到Response&lt;T&gt; 结果</span></div><div class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">                    <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line">            <span class="comment">//标记解析完成</span></div><div class="line">            request.addMarker(<span class="string">"cache-hit-parsed"</span>);</div><div class="line">            <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</div><div class="line">                <span class="comment">//如果不需要刷新，那么直接将解析结果回调</span></div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//如果需要刷新，那么添加标记</span></div><div class="line">                request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</div><div class="line">                request.setCacheEntry(entry);</div><div class="line">                response.intermediate = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">//返回数据，并将将请求添加到网络请求列队，但是是发送出去到主线程中执行</span></div><div class="line">                mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            mNetworkQueue.put(request);</div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="comment">//调用mQuit方法结束循环</span></div><div class="line">            <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">          <span class="comment">//否则继续缓存列队中取出request</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个run方法主要作用是：启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code> 去执行，将请求结果发送到主线程中。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入<code>NetworkDispatcher</code>去调度处理。这里有一行代码mDelivery.postResponse(request, response);是将请求结果发送到主线程中，前面我们提到是利用handler.post()方法执行，那么我们看看ExecutorDelivery 类的postResponse的具体细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</div><div class="line">    <span class="comment">//直接调用三个参数的post方法</span></div><div class="line">    postResponse(request, response, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就一行代码，调用含三个参数的构造方法，那么我们继续追溯：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</div><div class="line">    request.markDelivered();</div><div class="line">    request.addMarker(<span class="string">"post-response"</span>);</div><div class="line">    <span class="comment">//通过ResponseDeliveryRunnable将request, response, runnable包装后发送出去到主线程handle中</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的mResponsePoster就是在构造ExecutorDelivery 时候生成的Executor对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">// Make an Executor that just wraps the handler.</span></div><div class="line">    <span class="comment">//创建一个excuter包含了一个handler，handler来将runnable发送出去</span></div><div class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">          <span class="comment">//将Runnable对象发送到主线程</span></div><div class="line">            handler.post(command);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而ResponseDeliveryRunnable继承Runnable，所以当调用mResponsePoster.execut（new ResponseDeliveryRunnable(request, response, runnable)）方法时候就会将ResponseDeliveryRunnable对象发送到主线程中，那么我们看一下ResponseDeliveryRunnable类的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在主线程中运行</span></div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</div><div class="line">              <span class="comment">//如果请求取消，那么结束方法</span></div><div class="line">                mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</div><div class="line">              <span class="comment">//如果请求成功调用mRequest.deliverResponse，这个方法在我们自定义request时候需要重写的，每一条网络请求的响应都是回调到这个方法中，主线程中运行</span></div><div class="line">            mRequest.deliverResponse(mResponse.result);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="comment">//请求失败回调</span></div><div class="line">                mRequest.deliverError(mResponse.error);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">                mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mRequest.finish(<span class="string">"done"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="comment">//如果传入Runnable不为空，那么执行Runnable</span></div><div class="line">                mRunnable.run();</div><div class="line">            &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码我们看自定义Request时候需要复写的方法   mRequest.deliverResponse(mResponse.result);和mRequest.deliverError(mResponse.error)。到这里请求回调的疑问我们已经解决。</p>
<p>下面我们先分析一下NetworkDispatcher网络缓存线程，NetworkDispatcher 继承自Thread，也就是说NetworkDispatcher 是一个线程先看一下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> queue 网络请求列队</div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> * <span class="doctag">@param</span> cache 缓存类</div><div class="line"> * <span class="doctag">@param</span> delivery 请求结果回调分发类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkDispatcher</span><span class="params">(BlockingQueue&lt;Request&lt;?&gt;&gt; queue,</span></span></div><div class="line">        Network network, Cache cache,</div><div class="line">        ResponseDelivery delivery) &#123;</div><div class="line">    mQueue = queue;</div><div class="line">    mNetwork = network;</div><div class="line">    mCache = cache;</div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后看一下复写的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行网络请求线程，耗时任务的执行,在子线程中执行</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">//设置线程优先级</span></div><div class="line"> Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        Request&lt;?&gt; request;</div><div class="line">      <span class="comment">//从网络请求列队中循环读取request并执行请求</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">long</span> startTimeMs = SystemClock.elapsedRealtime();</div><div class="line">            request = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//从网络请求列队中拿到一个请求</span></div><div class="line">                request = mQueue.take();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                <span class="comment">//如果调用了mQuit就直接结束该方法</span></div><div class="line">                <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">              <span class="comment">//否则继续从列队中拿请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//添加拿到标记</span></div><div class="line">                request.addMarker(<span class="string">"network-queue-take"</span>);</div><div class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                    <span class="comment">//如果请求取消，结束请求</span></div><div class="line">                    request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                  <span class="comment">//继续从列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//设置线程状态</span></div><div class="line">                addTrafficStatsTag(request);</div><div class="line">                <span class="comment">//执行网络请求，得到请求结果NetworkResponse</span></div><div class="line">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">                <span class="comment">//添加执行请求完成状态</span></div><div class="line">                request.addMarker(<span class="string">"network-http-complete"</span>);</div><div class="line">               </div><div class="line">                <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                   <span class="comment">//如果networkResponse状态为304，并且已经传递了响应结果，那么结束请求不进行第二次返回</span></div><div class="line">                    request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                  <span class="comment">//继续请求列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//将networkResponse解析成  Response&lt;?&gt; response，这个解析方法我们可以自己在</span></div><div class="line">              <span class="comment">//Request类进行复写，自己定义解析方法</span></div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">              <span class="comment">//添加解析完成标记</span></div><div class="line">                request.addMarker(<span class="string">"network-parse-complete"</span>);</div><div class="line">                <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//如果请求使用了缓存，并且响应结果不为空，那么将请求结果存入缓存</span></div><div class="line">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">                  <span class="comment">//添加完成缓存标记</span></div><div class="line">                    request.addMarker(<span class="string">"network-cache-written"</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//添加请求结果回调标记</span></div><div class="line">                request.markDelivered();</div><div class="line">              <span class="comment">//回调响应结果，即将请求响应结果，发送到主线程</span></div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</div><div class="line">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">              <span class="comment">//请求网络失败回调</span></div><div class="line">                parseAndDeliverNetworkError(request, volleyError);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</div><div class="line">                VolleyError volleyError = <span class="keyword">new</span> VolleyError(e);</div><div class="line">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">              <span class="comment">//请求失败回调</span></div><div class="line">                mDelivery.postError(request, volleyError);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>run方法启动后会不断从网络请求队列中取请求处理，队列为空则等待，拿到请求后，则执行网络请求，请求处理结束则将结果传递给 ResponseDelivery 去执行后续处理，并判断结果是否要进行缓存。</p>
<p>下面我们来捋一捋volley如如何进行网络请求、缓存请求和请求结果的回调，步骤如下：</p>
<p>1、创建了一个缓存事件调度线程CacheDispatcher，负责从缓存列队中读取请求，然后从缓存中读取数据，进行解析返回，从缓存中读取数据为null，或者数据过期、需要刷新，那么将请求添加到网络请求列队。</p>
<p>2、创建了四个网络请求事件调度线程NetworkDispatcher，负责处理网络请求，并解析请求结果进行返回，并将结果缓存到本地。</p>
<p>3、创建了一个请求结果回调类ResponseDelivery，负责将请求结果返回到主线程，原理是利用handler将结果post到主线程。</p>
<p>到这里volley框架的主要流程我们基本梳理通顺了，下面我们在看一下细节方面，网络请求是如何执行的，上面代码中执行网络请求代码mNetwork.performRequest(request)，其中mNetwork就是我们在构造RequestQueue时候传入的BasicNetwork对象，那么看一下具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 通过HttpStack，即执行http网络请求请求</div><div class="line"> * 并将HttpStack请求结果包装成NetworkResponse返回NetworkRespons</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</div><div class="line">    <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="comment">//http请求头文件包装信息</span></div><div class="line">        HttpResponse httpResponse = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//请求返回内容body</span></div><div class="line">        <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//生成一个map对象</span></div><div class="line">        Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">            <span class="comment">//添加请求头文件信息，entry即是定义request类时候复写setCacheEntry传入</span></div><div class="line">            addCacheHeaders(headers, request.getCacheEntry());</div><div class="line">            <span class="comment">//执行mHttpStack操作返回请求结果httpResponse</span></div><div class="line">            httpResponse = mHttpStack.performRequest(request, headers);</div><div class="line">            <span class="comment">//获取到请求状态</span></div><div class="line">            StatusLine statusLine = httpResponse.getStatusLine();</div><div class="line">            <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</div><div class="line">            <span class="comment">//取出httpResponse中header添加到responseHeaders</span></div><div class="line">            responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class="line">            <span class="comment">//如果是304状态没有更新状态</span></div><div class="line">            <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class="line">                <span class="comment">//缓存中取出entry对象</span></div><div class="line">                Entry entry = request.getCacheEntry();</div><div class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//如果entry为null，返回一个entry为null的NetworkResponse</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, <span class="keyword">null</span>,</div><div class="line">                            responseHeaders, <span class="keyword">true</span>,</div><div class="line">                            SystemClock.elapsedRealtime() - requestStart);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                entry.responseHeaders.putAll(responseHeaders);</div><div class="line">                <span class="comment">//如果entry不为null，返回一个entry的NetworkResponse</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class="line">                        entry.responseHeaders, <span class="keyword">true</span>,</div><div class="line">                        SystemClock.elapsedRealtime() - requestStart);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//301/302 Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</span></div><div class="line">            <span class="keyword">if</span> (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class="line">               String newUrl = responseHeaders.get(<span class="string">"Location"</span>);</div><div class="line">               request.setRedirectUrl(newUrl);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//获取entry不为null,将entry转换为byte类型</span></div><div class="line">              responseContents = entityToBytes(httpResponse.getEntity());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//否则new 一个responseContents对象</span></div><div class="line">              responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class="line">            <span class="comment">//打印请求生命周期，请求，响应内容，和状态</span></div><div class="line">            logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class="line">            <span class="comment">//根据状态码抛出异常</span></div><div class="line">            <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//返回包含响应entry和header的NetworkResponse</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>,</div><div class="line">                    SystemClock.elapsedRealtime() - requestStart);</div><div class="line">            <span class="comment">//抛出各种异常</span></div><div class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</div><div class="line">            attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</div><div class="line">        ...........</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段方法中大多都是一些网络请求细节方面的东西，部分已经添加注释，我们抓重点看即可，其中httpResponse = mHttpStack.performRequest(request, headers);这一行代码中的mHttpStack就是我们在构造RequestQueue的时候传入的HttpStack对象，负责处理http网络请求的，然后就是有几处代码是return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,        responseHeaders, true,        SystemClock.elapsedRealtime() - requestStart))，其中区别就是参数不同，所以这个方法其实只要实现功能就是调用<code>HttpStack</code>处理网络请求，并将结果进行包装转换为可被<code>ResponseDelivery</code>处理的<code>NetworkResponse</code>对象返回。</p>
<p>下面我们看一下mHttpStack.performRequest(request, headers)这个方法是如何处理网络请求的（以HurlStack类为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 封装执行HttpURLConnection网络请求，返回HttpResponse对象</div><div class="line"> * <span class="doctag">@param</span> request the request to perform</div><div class="line"> * <span class="doctag">@param</span> additionalHeaders 附加的请求头文件信息</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException, AuthFailureError &#123;</div><div class="line">    <span class="comment">//获取网络请求url</span></div><div class="line">    String url = request.getUrl();</div><div class="line">    <span class="comment">//new 一个map对象</span></div><div class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">    <span class="comment">//将请求header信息添加进去</span></div><div class="line">    map.putAll(request.getHeaders());</div><div class="line">    map.putAll(additionalHeaders);</div><div class="line">    <span class="keyword">if</span> (mUrlRewriter != <span class="keyword">null</span>) &#123;</div><div class="line">        String rewritten = mUrlRewriter.rewriteUrl(url);</div><div class="line">        <span class="keyword">if</span> (rewritten == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"URL blocked by rewriter: "</span> + url);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取到url</span></div><div class="line">        url = rewritten;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//解析url</span></div><div class="line">    URL parsedUrl = <span class="keyword">new</span> URL(url);</div><div class="line">    <span class="comment">//创建HttpURLConnection网络请求连接</span></div><div class="line">    HttpURLConnection connection = openConnection(parsedUrl, request);</div><div class="line">    <span class="keyword">for</span> (String headerName : map.keySet()) &#123;</div><div class="line">        <span class="comment">//添加请求头信息</span></div><div class="line">        connection.addRequestProperty(headerName, map.get(headerName));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置连接参数，主要设置各种请求类型</span></div><div class="line">    setConnectionParametersForRequest(connection, request);</div><div class="line">  ........</div><div class="line">    <span class="comment">//解析请求body请求体</span></div><div class="line">    response.setEntity(entityFromConnection(connection));</div><div class="line">    <span class="keyword">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</div><div class="line">        <span class="keyword">if</span> (header.getKey() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//解析请求header添加请求头</span></div><div class="line">            Header h = <span class="keyword">new</span> BasicHeader(header.getKey(), header.getValue().get(<span class="number">0</span>));</div><div class="line">            response.addHeader(h);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//请求结果返回</span></div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码中我们终于看见了我们熟悉的HttpURLConnection对象，并进行了一系列的参数设置，解析返回数据返回HttpResponse对象。到这里负责执行网络请求部分的内容我们也梳理结束。</p>
<p>至此，关于volley的学习笔记到此结束，如有理解错误地方，还请指教！！</p>
<p>最后其实网络上关 Volley源码分析有很多文章，东西都差不多，但是每个人的侧重点和分析角度以及能否把事情讲的通俗易懂差别就大了，关键是要找到适合自己的，如果感觉本人分析你读着比较懵逼，那可能是我写的不清真，那么可以出门左拐<a href="http://yongyu.itscoder.com/2016/08/01/Volley%20Study/" target="_blank" rel="external"><a href="http://extremej.itscoder.com/volley_source/" target="_blank" rel="external">黑丫山上的小帅比 对Volley的深入分析</a></a> 和郭霖大神的博客去看一下，如果还是看不懂，那就有肯能是你理解的不清真了（just a joke) !!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/07/yongyu_20160803_volley_use_and_source_code_study/" data-id="civnx6lmz000hv0q72hkl9an0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android、Volley、源码/">Android、Volley、源码</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-RxJava/">Android RxJava</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android-View/">Android View</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android-View-学习/">Android View 学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android-WebView/">Android WebView</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android源码学习/">Android源码学习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-RxJava/">Android RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-View/">Android View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-WebView/">Android WebView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android、View/">Android、View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android、View基础/">Android、View基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android、Volley、源码/">Android、Volley、源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android-RxJava/" style="font-size: 10px;">Android RxJava</a> <a href="/tags/Android-View/" style="font-size: 20px;">Android View</a> <a href="/tags/Android-WebView/" style="font-size: 10px;">Android WebView</a> <a href="/tags/Android、View/" style="font-size: 10px;">Android、View</a> <a href="/tags/Android、View基础/" style="font-size: 10px;">Android、View基础</a> <a href="/tags/Android、Volley、源码/" style="font-size: 10px;">Android、Volley、源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/15/rxjava_learning_note/">RxJava 学习笔记（部分示例代码及源码）</a>
          </li>
        
          <li>
            <a href="/2016/10/24/show_image_from_webView/">Android  WebView 实现点击界面图片滑动浏览和保存图片功能</a>
          </li>
        
          <li>
            <a href="/2016/10/05/view_layout_and_draw/">View 的工作原理下 View 的 layout 和 draw 过程 （Android 开发艺术探索读书笔记）</a>
          </li>
        
          <li>
            <a href="/2016/09/11/view_measure/">View 的工作原理上 View 绘制流程梳理及 Measure 过程详解（Android 开发艺术探索笔记）</a>
          </li>
        
          <li>
            <a href="/2016/08/28/view_touchEvent_dispatch/">View 的事件分发机制（Android 开发艺术探索读书笔记）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Yongyu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
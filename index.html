<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="这里记录你的故事！">
<meta property="og:type" content="website">
<meta property="og:title" content="一个写代码的地方">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="一个写代码的地方">
<meta property="og:description" content="这里记录你的故事！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一个写代码的地方">
<meta name="twitter:description" content="这里记录你的故事！">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> 一个写代码的地方 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一个写代码的地方</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">记录你的学习</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/11/view_measure/" itemprop="url">
                  View 的工作原理上 View 绘制流程梳理及 Measure 过程详解（Android 开发艺术探索笔记）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-11T00:00:00+08:00" content="2016-09-11">
              2016-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-View/" itemprop="url" rel="index">
                    <span itemprop="name">Android View</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/11/view_measure/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/11/view_measure/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>-文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</p>
<ul>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://github.com/yongyu0102" target="_blank" rel="external">yongyu0102</a></li>
<li>审阅者：<a href="https://github.com/hymanme" target="_blank" rel="external">hymane</a></li>
</ul>
</blockquote>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>View 是 Android 中所有控件的基类，例如 Button 和 TextView、ViewGroup 等常见控件他们的基类都是 View，View 是一种界面层的控件的一种抽象，代表了一个控件。View 本身可以是单个控件也可以是由多个控件组成的一组控件，通过这种关系就形成了 View 树的结构。Android 系统本身就提供好了很多好用的 View，你也可以自己根据需求去自定义一个 View，拿最简单的一个例子来说，当我们想在界面上显示一行文字的时候，我们会在 xml 文件中写好布局然后在  Activity 中的 onCreate 方法中使用 setContentView 方法来加载布局就可以显示出我们想要的文字，这时候你是否有思考过这个过程是怎么完成的， View 是如何被显示到界面上的；还有一个我们经常遇到的问题是：当我们在一个 ScrollView 控件内部嵌套一个 ListView 的时候 ListView 只会显示一行；当使用自定义的 View 的时候，View 可以显示到界面，但是当使用 WrapContent 属性的时候不起作用，这些问题笔者就曾都遇到过，如果你也曾有过这样的疑问，可以阅读以下这篇文章。</p>
<h2 id="1-1-主要内容简介"><a href="#1-1-主要内容简介" class="headerlink" title="1.1 主要内容简介"></a>1.1 主要内容简介</h2><p>View 的工作原理主要包含 View 的三大流程 onMeasure()、onLayout()和onDraw()  ，而由于一次性全部写完内容会有点长，所以本次主要先介绍关于 View 的工作流程的整体梳理和 Measure 过程相关知识，而下一篇笔记会把剩下的部分写完。</p>
<h1 id="2-初识-ViewRoot-和-DecorView"><a href="#2-初识-ViewRoot-和-DecorView" class="headerlink" title="2 初识 ViewRoot 和 DecorView"></a>2 初识 ViewRoot 和 DecorView</h1><p>在正式介绍 View 的三大流程 onMeasure()、onLayout()和onDraw() 之前，先简单介绍一下当我们在 Activity 方法 onCreate 里执行 setContentView 之后 View 是如何显示到屏幕上的，这里我们就不分析源码过程了，因为这个过程不是我们要分析的重点，只是辅助我们去理解，有助于我们对整个流程有更好的理解和把握。</p>
<p>当调用 Activity 的  setContentView 方法后会调用  PhoneWindow 类 的 setContentView  方法，PhoneWindow 类是抽象类Window的实现类，Window 类用来描述 Activity 视图最顶端的窗口显示和行为操作，PhoneWindow 类 的 setContentView  方法中最终会 生成一个 DecorView 对象，DecorView 是 PhoneWindow类的内部类，继承自FrameLayout ，所以调用 Activity 方法 setContetnView 后最终会生成一个 FrameLayout 类型的 DecorView 组件，该组件将作为整个应用窗口的顶层图，然后在 DecorView 容器中添加根布局，根布局中包含一个 id 为 contnet 的 FrameLayout 内容布局，我们的 Activity 加载的布局 xml 最后通过LayoutInflater 将 xml 内容布局解析成 View 树形结构，最后添加到 id 为 content 的 FrameLayout布局当中，至此，View 最终就会显示到手机屏幕上，如果想详细了解出门右转<a href="http://blog.csdn.net/feiduclear_up/article/details/46772477" target="_blank" rel="external">从ViewRootImpl类分析View绘制的流程——废墟的树</a>。整理流程梳理可以参考下面这张图片：</p>
<p>​                   <img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/decorView_view.png?raw=true" alt="decorView_view"></p>
<p>我们了解了上面得到流程后下面梳理一下如何进入到 view 的绘制流程：</p>
<p>ViewRoot 对应的实现类是 ViewRootImpl 类，他是连接 WindowManager 和DecorView 的纽带，view 的三大 流程均是通过 ViewRoot 来完成的。在 ActivityThread 中，当 activity 对象被创建完毕后，会将 DecorView 添加到Window 中，同时会创建 ViewRootImpl 对象，并将 ViewRootImpl 对象和 DecorView 建立关联。这个流程可以参考下图，图片来自<a href="http://blog.csdn.net/feiduclear_up/article/details/46772477" target="_blank" rel="external">从ViewRootImpl类分析View绘制的流程——废墟的树</a>：</p>
<p><img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/decorView.png?raw=true" alt="decorView"></p>
<p>View 的绘制流程是从 ViewRoot 的 performTraversals 方法开始的，它经过 measure、layout、draw 三个过程才能最终将一个 View 绘制出来，其中 measure 用来测量 View 的宽和高，layout 用来确定 View 在父容器的放置位置，而 draw 则负责将 View 绘制在屏幕上，参考下图（来源艺术探索截图） ：</p>
<p><img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/view.png?raw=true" alt="view"></p>
<p>performTraversals 会依次调用 performMeasure、performLayout、performDraw 三个方法，这三个方法分别完成顶级 View 的 measure、layout 和 draw 这三大流程，其中 performMeasure 会调用 measure 方法，在measure 方法中又会调用 onMeasure 方法，在 onMeasure 方法中对所有的子元素进行 measure 过程，这个时候 measure 流程就会从父容器传递到子元素中了，这样就完成了一次 measure 过程。接着子元素就会重复父容器的 measure 过程，如此反复就完成了整个 View 树的遍历，同理 perFormLayout 和 performDraw 的流程也是类似。</p>
<p>measure 过程决定了 view 的宽高，在几乎所有的情况下这个宽高都等同于 view 最终的宽高，但特殊情况除外。layout 过程决定了 view 的四个顶点的坐标和 view实 际的宽高，通过 <code>getWidth</code> 和 <code>getHeight</code> 方法可以得到最终的宽高。draw过程决定了view的显示。</p>
<p>DecorView 其实是一个 FrameLayout，其中包含了一个竖直方向的 LinearLayout，上面是标题栏，下面是内容栏(id为<code>android.R.id.content</code>)。</p>
<h1 id="3-理解MeasureSpec"><a href="#3-理解MeasureSpec" class="headerlink" title="3 理解MeasureSpec"></a>3 理解MeasureSpec</h1><p>MeasureSpec  是 View 测量过程中的一个关键参数，很大程度上决定了 View 的宽高，父容器会影响 View 的 MeasureSpec 的创建，MeasureSpec 不是唯一由 LayoutParams 决定的，LayoutParams 需要和父容器一起才能决定 View 的MeasureSpec，从而进一步确定 View 的宽高，在 View 测量过程中，系统会将该 View 的 LayoutParams 参数在父容器的约束下转换成对应的 MeasureSpec ，然后再根据这个 measureSpec 来测量 View 的宽高。</p>
<p>MeasureSpec 代表一个32位 int 值，高2位代表 SpecMode（测量模式），低30位代表 SpecSize（在某个测量模式下的规格大小），MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的内存分配，为了方便操作，其提供了打包和解包方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过将 SpecMode 和 SpecSize 打包，获取 MeasureSpec  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">        <span class="keyword">return</span> size + mode;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//将 MeasureSpec 解包获取 SpecMode</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">        &#125;</div><div class="line"><span class="comment">//将 MeasureSpec 解包获取 SpecSize</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p><strong>SpecMode 有三类，每一类都表示特殊的含义：</strong></p>
<ol>
<li>UNSPECIFIED 父容器不对 View 有任何的限制，要多大给多大，这种情况下一般用于系统内部，表示一种测量的状态。</li>
<li>EXACTLY 父容器已经检测出 View 所需要的精确大小，这个时候 View 的最终大小就是 SpecSize 所指定的值，它对应于LayoutParams 中的 match_parent 和具体的数值这两种模式</li>
<li>AT_MOST 父容器指定了一个可用大小即 SpecSize，View 的大小不能大于这个值，具体是什么值要看不同 View 的具体实现。它对应于 LayoutParams 中的 wrap_content。</li>
</ol>
<h1 id="4-MeasureSpec-和-LayoutParams-的对应关系"><a href="#4-MeasureSpec-和-LayoutParams-的对应关系" class="headerlink" title="4 MeasureSpec 和 LayoutParams 的对应关系"></a>4 MeasureSpec 和 LayoutParams 的对应关系</h1><p><strong>对于DecorView，它的 MeasureSpec 由窗口的尺寸和其自身的 LayoutParams 来决定；对于普通 View，它的MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定。</strong></p>
<p>对普通的 View 的 measure 方法的调用，是由其父容器传递而来的，这里先看一下 ViewGroup 的 measureChildWithMargins 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> * <span class="meta">@param</span> child 要被测量的 View</div><div class="line"> * <span class="meta">@param</span> parentWidthMeasureSpec 父容器的 WidthMeasureSpec</div><div class="line"> * <span class="meta">@param</span> widthUsed 父容器水平方向已经被占用的空间，比如被父容器的其他子 view 所占用的空间</div><div class="line"> * <span class="meta">@param</span> parentHeightMeasureSpec 父容器的 HeightMeasureSpec</div><div class="line"> * <span class="meta">@param</span> heightUsed 父容器竖直已经被占用的空间，比如被父容器的其他子 view 所占用的空间</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">   <span class="comment">//第一步，获取子 View 的 LayoutParams</span></div><div class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">   <span class="comment">//第二步，获取子 view 的 WidthMeasureSpec，其中传入的几个参数说明：</span></div><div class="line">   <span class="comment">//parentWidthMeasureSpec 父容器的 WidthMeasureSpec</span></div><div class="line">   <span class="comment">//mPaddingLeft + mPaddingRight view 本身的 Padding 值，即内边距值</span></div><div class="line">   <span class="comment">//lp.leftMargin + lp.rightMargin view 本身的 Margin 值，即外边距值</span></div><div class="line">   <span class="comment">//widthUsed 父容器已经被占用空间值</span></div><div class="line">   <span class="comment">// lp.width view 本身期望的宽度 with 值</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                    + widthUsed, lp.width);</div><div class="line">     <span class="comment">//获取子 view 的 HeightMeasureSpec</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                    + heightUsed, lp.height);</div><div class="line"><span class="comment">// 第三步，根据获取的子 veiw 的 WidthMeasureSpec 和 HeightMeasureSpec </span></div><div class="line">   <span class="comment">//对子 view 进行测量</span></div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上代码第二步可以看出，子 view 的 MeasureSpec 的创建与父容器的 MeasureSpec 、子 view 本身的 LayoutParams 有关，此外还与 view 本身的 margin 和 padding 值有关，具体看一下 getChildMeasureSpec 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param spec 父容器的 MeasureSpec，是对子 View 的约束条件</div><div class="line">     * @param padding 当前 View 的 padding、margins 和父容器已经被占用空间值</div><div class="line">     * @param childDimension View 期望大小值，即layout文件里设置的大小:可以是MATCH_PARENT,</div><div class="line">     *WRAP_CONTENT或者具体大小, 代码中分别对三种做不同的处理</div><div class="line">     * @return 返回 View 的 MeasureSpec 值</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</div><div class="line">  <span class="comment">// 获取父容器的 specMode，父容器的测量模式影响子 View  的测量模式</span></div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</div><div class="line">         <span class="comment">// 获取父容器的 specSize 尺寸，这个尺寸是父容器用来约束子 View 大小的</span></div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</div><div class="line"><span class="comment">// 父容器尺寸减掉已经被用掉的尺寸</span></div><div class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</div><div class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="comment">// 如果父容器是 EXACTLY 精准测量模式</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        <span class="comment">//如果子 View 期望尺寸为大于 0 的固定值，对应着 xml 文件中给定了 View 的具体尺寸大小</span></div><div class="line">        <span class="comment">//如 android:layout_width="100dp"</span></div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">          <span class="comment">//那么子 View 尺寸为期望值固定尺寸，测量模式为精准测量模式 EXACTLY</span></div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">             <span class="comment">//如果子 View 期望尺寸为 MATCH_PARENT 填充父布局</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            <span class="comment">// 那么子 View 尺寸为 size 最大值，即父容器剩余空间尺寸，为精准测量模式 EXACTLY</span></div><div class="line">          <span class="comment">//即子 View 填的是 Match_parent, 那么父 View 就给子 View 自己的size(去掉padding)，</span></div><div class="line">          <span class="comment">//即剩余全部未占用的尺寸, 然后告诉子 View 这是 Exactly 精准的大小，你就按照这个大小来设定自己的尺寸</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">          <span class="comment">//如果子 View 期望尺寸为 WRAP_CONTENT ，包裹内容</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">          <span class="comment">//子 View 尺寸为 size  最大值，即父容器剩余空间尺寸 ，测量模式为 AT_MOST 最大测量模式</span></div><div class="line">          <span class="comment">//即子 View 填的是 wrap_Content,那么父 View 就告诉子 View 自己的size(去掉padding),</span></div><div class="line">          <span class="comment">//即剩余全部未占用的尺寸,然后告诉子 View, 你最大的尺寸就这么多，不能超过这个值, </span></div><div class="line">          <span class="comment">//具体大小，你自己根据自身情况决定最终大小。一般当我们继承 View 基类进行自定义 View  的时候</span></div><div class="line">          <span class="comment">//需要在这种情况下计算给定 View 一个尺寸，否则当使用自定义的 View 的时候，使用 </span></div><div class="line">          <span class="comment">// android:layout_width="wrap_content" 属性就会失效</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 父容器为 AT_MOST 最大测量模式</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">           <span class="comment">// 子 View 期望尺寸为一个大于 0的具体值，对应着 xml 文件中给定了 View 的具体尺寸大小</span></div><div class="line">        <span class="comment">//如 android:layout_width="100dp"</span></div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">           <span class="comment">//那么子 View 尺寸为期望固定值尺寸，为精准测量模式 EXACTLY</span></div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">          <span class="comment">//如果子 View 期望尺寸为 MATCH_PARENT 最大测量模式</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">             <span class="comment">//子 View 尺寸为 size，测量模式为 AT_MOST  最大测量模式</span></div><div class="line">          <span class="comment">//即如果子 View 是 Match_parent,那么父 View 就会告诉子 View, </span></div><div class="line">          <span class="comment">//你的尺寸最大为 size 这么大（父容器尺寸减掉已经被用掉的尺寸，即父容器剩余未占用尺寸），</span></div><div class="line">          <span class="comment">//你最多有父 View的 size 这么大，不能超过这个尺寸，至于具体多大，你自己根据自身情况决定。</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">             <span class="comment">//同上</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 父容器为 UNSPECIFIED 模式</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">           <span class="comment">// 子 View 期望尺寸为一个大于 0的具体值</span></div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">             <span class="comment">//那么子 View 尺寸为期望值固定尺寸，为精准测量模式 EXACTLY</span></div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">           <span class="comment">//如果子 View 期望尺寸为 MATCH_PARENT 最大测量模式</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">//子 View 尺寸为 0，测量模式为 UNSPECIFIED</span></div><div class="line">           <span class="comment">// 父容器不对 View 有任何的限制，要多大给多大</span></div><div class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">            resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">           <span class="comment">//如果子 View 期望尺寸为 WRAP_CONTENT ，包裹内容</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">             <span class="comment">//子 View 尺寸为 0，测量模式为 UNSPECIFIED</span></div><div class="line">             <span class="comment">// 父容器不对 View 有任何的限制，要多大给多大</span></div><div class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">            resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码主要作用就是根据父容器的  MeasureSpec 和 view 本身的 LayoutParams 来确定子元素的 MeasureSpec 的整个过程，这个过程清楚的展示了普通 view 的 MeasureSpec  的创建规则，整理一下可得到如下表格（来源艺术探索截图）：</p>
<p><img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/mesureSpec.png?raw=true" alt="mesureSpec">总结：</p>
<ol>
<li>当 View 采用固定宽高时，不管父容器的 MeasureSpec 是什么，View 的 MeasureSpec 都是精确模式，并且大小是LayoutParams 中的大小。</li>
<li>当 View 的宽高是 match_parent 时，如果父容器的模式是精确模式，那么 View 也是精确模式，并且大小是父容器的剩余空间；如果父容器是最大模式，那么 View 也是最大模式，并且大小是不会超过父容器的剩余空间。</li>
<li>当 View 的宽高是 wrap_content 时，不管父容器的模式是精确模式还是最大模式，View 的模式总是最大模式，并且大小不超过父容器的剩余空间。</li>
</ol>
<h1 id="5-View-的工作流程"><a href="#5-View-的工作流程" class="headerlink" title="5 View 的工作流程"></a>5 View 的工作流程</h1><p>View 的工作流程主要是指 measure、layout、draw 这三大流程，即测量、布局和绘制，其中 measure 确定 View 的测量宽和高，layout 确定 View  的最终宽和高及 View 的四个顶点位置，而 draw 是将 View 绘制到屏幕上。</p>
<h2 id="5-1-measure-过程"><a href="#5-1-measure-过程" class="headerlink" title="5.1 measure 过程"></a>5.1 measure 过程</h2><p>分两种情况：</p>
<ol>
<li>如果只是一个原始的 View，通过<code>measure</code>方法就完成了测量过程。</li>
<li>如果是一个 ViewGroup 除了完成自己的测量过程还会遍历调用所有子 View 的<code>measure</code>方法，而且各个子 View 还会递归执行这个过程。</li>
</ol>
<h3 id="5-1-1-View-的-measure-过程"><a href="#5-1-1-View-的-measure-过程" class="headerlink" title="5.1.1 View 的 measure 过程"></a>5.1.1 View 的 measure 过程</h3><p>View 的 measure 过程由 <code>measure</code> 方法来完成， <code>measure</code> 方法是一个 final 类型，子类不可以重写，而 View 的 measure() 方法中会调用 onMeasure 方法，因此我们只需要分析 onMeasure  方法即可，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> widthMeasureSpec 父容器所施加的水平方向约束条件</div><div class="line">     * <span class="doctag">@param</span> heightMeasureSpec 父容器所施加的竖直方向约束条件</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">  <span class="comment">//设置 view 高宽的测量值</span></div><div class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面方法很简单，就是给 View 设置了测量高宽的测量值，而这个测量值是通过 getDefaultSize 方法获取，那么接着分析 getDefaultSize 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> size view 的默认尺寸，一般表示设置了android:minHeight属性</div><div class="line">     *或者该View背景图片的大小值 </div><div class="line">     * <span class="doctag">@param</span> measureSpec 父容器的约束条件 measureSpec</div><div class="line">     * <span class="doctag">@return</span> 返回 view 的测量尺寸</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = size;</div><div class="line">  <span class="comment">//获取测量模式</span></div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">  <span class="comment">//获取尺寸</span></div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        <span class="comment">//如果 测量模式为 UNSPECIFIED ，表示对父容器对子 view 没有限制，那么 view 的测量尺寸为</span></div><div class="line">        <span class="comment">//默认尺寸 size</span></div><div class="line">        result = size;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        <span class="comment">//如果测量模式为 AT_MOST 最大测量模式或者 EXACTLY 精准测量模式，</span></div><div class="line">        <span class="comment">//那么 View 的测量尺寸为 MeasureSpec 的 specSize</span></div><div class="line">        <span class="comment">//即父容器给定尺寸（父容器当前剩余全部空间大小）。</span></div><div class="line">        result = specSize;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里来分析一下 UNSPECIFIED 条件下 View 的测量高宽默认值 size 是通过 getSuggestedMinimumWidth() 和 getSuggestedMinimumHeight()  函数获取，这两个方法原理一样，这里我们就看一下 getSuggestedMinimumHeight() 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码可以看出，如果 View 没有背景，View 的高度就是 mMinHeight，这个 mMinHeight 是由 android：minHeight 这个属性控制，可以为 0，如果有背景，就返回  mMinHeight 和背景的最小高度两者中的最大值。</p>
<p>从 getDefaultSize 方法可以看出，View 的高/宽由 父容器传递进来的 specSize 决定，因此可以得出结论：</p>
<p><strong>直接继承自 View 的自定义控件需要重写 onMeasure 方法来设置 wrap_content 时候的自身大小</strong>，而设置的具体值需要根据实际情况自己去计算或者直接给定一个默认固定值，否则在布局中使用 wrap_content  时候就相当于使用 match_parent ，因为在布局中使用 wrap_content 的时候，它的 specMode 是 AT_MOST 最大测量模式，在这种模式下 View 的宽/高等于 speceSize 大小，即父容器中可使用的大小，也就是父容器当前剩余全部空间大小，这种情况，很显然，View 的宽/高就是等于父容器剩余空间的大小，填充父布局，这种效果和布局中使用 match_parent  一样，解决这个问题代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">    <span class="keyword">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">  <span class="comment">// 在 MeasureSpec.AT_MOST 模式下，给定一个默认值</span></div><div class="line">  <span class="comment">//其他情况下沿用系统测量规则即可</span></div><div class="line">    <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST</div><div class="line">            &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        setMeasuredDimension(mWith, mHeight);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        setMeasuredDimension(mWith, heightSpecSize);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        setMeasuredDimension(widthSpecSize, mHeight);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中在 widthSpecMode 或 heightSpecMode 为 MeasureSpec.AT_MOST 我们就给定一个对应的 mWith 和 mHeight 默认固定值宽高，而这个默认值没有固定依据，需要我们根据自定义的 view 的具体情况去计算给定。</p>
<h3 id="5-1-2-ViewGroup-的-measure-过程"><a href="#5-1-2-ViewGroup-的-measure-过程" class="headerlink" title="5.1.2 ViewGroup 的 measure 过程"></a>5.1.2 ViewGroup 的 measure 过程</h3><p>ViewGroup 除了完成自己的测量过程还会遍历调用所有子 View 的<code>measure</code>方法，而且各个子 View 还会递归执行这个过程，我们知道 View Group 继承自 View ，是一个抽象类，因此没有重写 View  onMeasure 方法，也就是没有提供具体如何测量自己的方法，但是它提供了一个 measureChildren 方法，定义了如何测量子 View 的规则，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> widthMeasureSpec 该 ViewGroup 水平方向约束条件</div><div class="line"> * <span class="doctag">@param</span> heightMeasureSpec 该 ViewGroup 竖直方向约束条件</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">    <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">      <span class="comment">//逐一遍历获取得到 ViewGroup 中的子 View</span></div><div class="line">        <span class="keyword">final</span> View child = children[i];</div><div class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">          <span class="comment">//对获取到的 子 view 进行测量</span></div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们再看一下对子 View 进行测量的 measureChild 方法 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> child 要进行测量的子 view </div><div class="line"> * <span class="doctag">@param</span> parentWidthMeasureSpec ViewGroup 对要进行测量的子 view 水平方向约束条件</div><div class="line"> * <span class="doctag">@param</span> parentHeightMeasureSpec  ViewGroup 对要进行测量的子 view 竖直方向约束条件</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">        <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">  <span class="comment">//第一步，获取 View 的 LayoutParams</span></div><div class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"><span class="comment">//第二步，获取 view 的 WidthMeasureSpec，其中传入的几个参数说明：</span></div><div class="line"><span class="comment">//parentWidthMeasureSpec 父容器的 WidthMeasureSpec</span></div><div class="line"><span class="comment">//mPaddingLeft + mPaddingRight view 本身的 Padding 值，即内边距值</span></div><div class="line"><span class="comment">// lp.width view 本身期望的宽度 with 值</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">            mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">  <span class="comment">//同上</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">            mPaddingTop + mPaddingBottom, lp.height);</div><div class="line">  <span class="comment">// 第三步，根据获取的子 veiw 的 WidthMeasureSpec 和 HeightMeasureSpec </span></div><div class="line">   <span class="comment">//调用子 view 的 measure 方法，对子 view 进行测量，具体后面的测量逻辑就是和我们前面分析 </span></div><div class="line">  <span class="comment">// view 的测量过程一样了。</span></div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中的第二步调用的方法 getChildMeasureSpec  在标题 4 MeasureSpec和LayoutParams的对应关系 中已经分析过。</p>
<p>ViewGroup 并没有定义具体的测量过程，这是因为 ViewGroup 是一个抽象类，其不同子类具有不同的特性，导致他们的测量过程有所不同，不能有一个统一的 onMeasure 方法，所以其测量过程的 onMeasure 方法需要子类去具体实现，比如 LinearLayout 和 RelativeLayout 等，下面通过 LinearLayout 的 onMeasure 方法来分析一下 ViewGroup 的测量过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">      <span class="comment">//垂直方向的 LinearLayout  测量方式</span></div><div class="line">        measureVertical(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//水平方向的 LinearLayout 测量方式</span></div><div class="line">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码可以看出 ViewGroup 内部测量方式分为垂直方向和水平方向，两者原理基本一样，下面看一下垂直方向的 LinearLayout  测量方式，由于这个方法代码比较长，所以贴出重点部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line"> ......................</div><div class="line">    <span class="comment">//记录总高度</span></div><div class="line">    <span class="keyword">float</span> totalWeight = <span class="number">0</span>;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</div><div class="line">  <span class="comment">//获取测量模式</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> widthMode = View.MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightMode = View.MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"> ...........</div><div class="line">    <span class="comment">//第1步，对 LinearLayout 中的子 view 进行第一次测量</span></div><div class="line">    <span class="comment">// See how tall everyone is. Also remember max width.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">            mTotalLength += measureNullChild(i);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class="line">            i += getChildrenSkipCount(child, i);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">            mTotalLength += mDividerHeight;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取子 view 的 LayoutParams 参数</span></div><div class="line">        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">        totalWeight += lp.weight;</div><div class="line">      <span class="comment">//第1.1步，满足该条件，第一次测量时不需要测量该子 view</span></div><div class="line">        <span class="keyword">if</span> (heightMode == View.MeasureSpec.EXACTLY &amp;&amp; lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 满足该条件的话，不需要现在计算该子视图的高度。</span></div><div class="line">            <span class="comment">//因为 LinearLayout 的高度测量规格为 EXACTLY ，说明高度 LinearLayout 是固定的，</span></div><div class="line">            <span class="comment">//不依赖子视图的高度计算自己的高度</span></div><div class="line">            <span class="comment">//lp.height == 0 &amp;&amp; lp.weight &gt; 0 说明子 view 使用了权重模式，即希望使用 LinearLayout 的剩余空间</span></div><div class="line">            <span class="comment">// 测量工作会在之后进行</span></div><div class="line">            <span class="comment">//相反，如果测量规格为 AT_MOST 或者 UNSPECIFIED ，LinearLayout</span></div><div class="line">            <span class="comment">// 只能根据子视图的高度来确定自己的高度，就必须对所有的子视图进行测量。</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</div><div class="line">            <span class="comment">//标记未进行测量</span></div><div class="line">            skippedMeasure = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">//  else 语句内部是对子 view 进行第一次测量</span></div><div class="line">            <span class="keyword">int</span> oldHeight = Integer.MIN_VALUE;</div><div class="line">            <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 如果 LiniearLayout 不是 EXACTLY 模式，高度没给定，</span></div><div class="line">              <span class="comment">//说明 LiniearLayout 高度需要根据子视图来测量，</span></div><div class="line">                <span class="comment">// 而此时子 view 模式为 lp.height == 0 &amp;&amp; lp.weight &gt; 0 ，是希望使用 LinearLayout 的剩余空间</span></div><div class="line">                <span class="comment">// 这种情况下，无法得出子 view 高度，而为了测量子视图的高度，</span></div><div class="line">              <span class="comment">//设置子视图 LayoutParams.height 为 wrap_content。</span></div><div class="line">                oldHeight = <span class="number">0</span>;</div><div class="line">                lp.height = LayoutParams.WRAP_CONTENT;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//该方法只是调用了 ViewGroup 的 measureChildWithMargins() 对子 view 进行测量</span></div><div class="line">            <span class="comment">// measureChildWithMargins() 方法在上面 4 MeasureSpec和LayoutParams的对应关系已经分析过</span></div><div class="line">            measureChildBeforeLayout(</div><div class="line">                    child, i, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec,</div><div class="line">                    totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (oldHeight != Integer.MIN_VALUE) &#123;</div><div class="line">                lp.height = oldHeight;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 获取测量到的子 view 高度</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">            <span class="comment">//第2步， 重新计算 LinearLayout 的 mTotalLength 总高度</span></div><div class="line">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</div><div class="line">                    lp.bottomMargin + getNextLocationOffset(child));</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (useLargestChild) &#123;</div><div class="line">                largestChildHeight = Math.max(childHeight, largestChildHeight);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    ..........................</div><div class="line">        <span class="comment">//以下方法是对 LinearLayout 宽度相关的测量工作，不是我们关心的</span></div><div class="line">        <span class="keyword">if</span> (widthMode != View.MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            .........................</div><div class="line">    <span class="comment">//以上方法是对 LinearLayout 宽度相关的测量工作</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mTotalLength &gt; <span class="number">0</span> &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</div><div class="line">        mTotalLength += mDividerHeight;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//第3步，如果设置了 android:measureWithLargestChild="true"并且测量模式为 AT_MOST或者 UNSPECIFIED</span></div><div class="line">    <span class="comment">// 重新计算 mTotalLength 总高度</span></div><div class="line">    <span class="keyword">if</span> (useLargestChild &amp;&amp;</div><div class="line">            (heightMode == View.MeasureSpec.AT_MOST || heightMode == View.MeasureSpec.UNSPECIFIED)) &#123;</div><div class="line">        mTotalLength = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">                mTotalLength += measureNullChild(i);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</div><div class="line">                i += getChildrenSkipCount(child, i);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</div><div class="line">                    child.getLayoutParams();</div><div class="line">            <span class="comment">// Account for negative margins</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">            <span class="comment">//每个子视图的高度为：最大子视图高度 ＋ 该子视图的上下外边距</span></div><div class="line">            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</div><div class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Add in our padding</span></div><div class="line">    mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> heightSize = mTotalLength;</div><div class="line"></div><div class="line">    <span class="comment">// Check against our minimum height</span></div><div class="line">    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</div><div class="line"></div><div class="line">    <span class="comment">//第4步，根据 heightMeasureSpec 测量模式 和已经测量得到的总高度 heightSize</span></div><div class="line">    <span class="comment">//来确定得到最终 LinearLayout 高度和状态</span></div><div class="line">    <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</div><div class="line">          </div><div class="line">    <span class="comment">//分割线=================以上代码就完成了对  LinearLayout 高度和状态 的测量</span></div><div class="line"></div><div class="line">    <span class="comment">//第5步，下面代码是根据已经测量得到的 LinearLayout 高度来重新测量确定各个子 view 的大小</span></div><div class="line"></div><div class="line">    <span class="comment">//获取 LinearLayout 高度值</span></div><div class="line">    heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</div><div class="line">    <span class="comment">//获取最终测量高度和经过测量各个子 view 得到的总高度差值</span></div><div class="line">    <span class="keyword">int</span> delta = heightSize - mTotalLength;</div><div class="line">    <span class="comment">//第5.1步（第5步中第1小步），如果在上面第一次测量子 view 的过程中有未进行测量的 view 那么执行下面代码</span></div><div class="line">    <span class="keyword">if</span> (skippedMeasure || delta != <span class="number">0</span> &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>) &#123;</div><div class="line">        <span class="keyword">float</span> weightSum = mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</div><div class="line">        mTotalLength = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">            <span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">            <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 计算 weight 属性分配的大小，可能为负值</span></div><div class="line">                <span class="keyword">int</span> share = (<span class="keyword">int</span>) (childExtra * delta / weightSum);</div><div class="line">                weightSum -= childExtra;</div><div class="line">                delta -= share;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</div><div class="line">                        mPaddingLeft + mPaddingRight +</div><div class="line">                                lp.leftMargin + lp.rightMargin, lp.width);</div><div class="line"></div><div class="line">                <span class="comment">// <span class="doctag">TODO:</span> Use a field like lp.isMeasured to figure out if this</span></div><div class="line">                <span class="comment">// child has been previously measured</span></div><div class="line">                <span class="keyword">if</span> ((lp.height != <span class="number">0</span>) || (heightMode != View.MeasureSpec.EXACTLY)) &#123;</div><div class="line">                    <span class="comment">// 子视图在第一次测量时候已经测量过</span></div><div class="line">                    <span class="comment">// 基于上次测量值再次进行新的测量</span></div><div class="line">                    <span class="keyword">int</span> childHeight = child.getMeasuredHeight() + share;</div><div class="line">                    <span class="keyword">if</span> (childHeight &lt; <span class="number">0</span>) &#123;</div><div class="line">                        childHeight = <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 调用子 view 的 measure 方法进行测量，后面逻辑就是 view 的测量逻辑</span></div><div class="line">                    child.measure(childWidthMeasureSpec,</div><div class="line">                            View.MeasureSpec.makeMeasureSpec(childHeight, View.MeasureSpec.EXACTLY));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 子视图第一次测量，即第一步进行测量的时候未得到测量</span></div><div class="line">                    <span class="comment">//对 view 进行测量</span></div><div class="line">                    child.measure(childWidthMeasureSpec,</div><div class="line">                            View.MeasureSpec.makeMeasureSpec(share &gt; <span class="number">0</span> ? share : <span class="number">0</span>,</div><div class="line">                                    View.MeasureSpec.EXACTLY));</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Child may now not fit in vertical dimension.</span></div><div class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState()</div><div class="line">                        &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 处理子视图宽度</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> margin =  lp.leftMargin + lp.rightMargin;</div><div class="line">           ...........................</div><div class="line">        <span class="comment">// Add in our padding</span></div><div class="line">        mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//第5.2步（第5步中第2小步）执行到这里的代码，表明 view 是已经测量过的</span></div><div class="line">        alternativeMaxWidth = Math.max(alternativeMaxWidth,</div><div class="line">                weightedMaxWidth);</div><div class="line">        <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></div><div class="line">        <span class="comment">// Children will have already been measured once.</span></div><div class="line">        <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != View.MeasureSpec.EXACTLY) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">                <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">                <span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">                <span class="comment">//如果 view 使用了权重即 childExtra &gt; 0，使用最大子视图高度进行重新测量</span></div><div class="line">                <span class="comment">//否则不进行测量，保持第一次测量值，那么由于 LinearLayout 的高度使用了子 view 最大高度 ，</span></div><div class="line">                <span class="comment">// 但是子视图没有进行重新测量，没有进行拉伸，可能造成空间剩余。</span></div><div class="line">                <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">//使用最大子视图高度进行重新测量子 view </span></div><div class="line">                    child.measure(</div><div class="line">                            View.MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</div><div class="line">                                    View.MeasureSpec.EXACTLY),</div><div class="line">                            View.MeasureSpec.makeMeasureSpec(largestChildHeight,</div><div class="line">                                    View.MeasureSpec.EXACTLY));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != View.MeasureSpec.EXACTLY) &#123;</div><div class="line">        maxWidth = alternativeMaxWidth;</div><div class="line">    &#125;</div><div class="line">    maxWidth += mPaddingLeft + mPaddingRight;</div><div class="line">    <span class="comment">// Check against our minimum width</span></div><div class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</div><div class="line">    <span class="comment">//第6步，最终设置 LinearLayout 的测量高宽</span></div><div class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class="line">            heightSizeAndState);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (matchWidth) &#123;</div><div class="line">        forceUniformWidth(count, heightMeasureSpec);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码就是对 LinearLayout onMeasure 分析过程，整个过程原理已经在代码中加以注释说明，这里我们重点分析一下 resolveSizeAndState(heightSize, heightMeasureSpec, 0) 这个方法是如何实现最终确定 LinearLayout 高度值的，方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> size view 想要的大小，也就是根据子 view 高度测量得到的高度值.</div><div class="line"> * <span class="doctag">@param</span> measureSpec 父容器的约束条件</div><div class="line"> * <span class="doctag">@param</span> childMeasuredState 子 view 的测量信息</div><div class="line"> * <span class="doctag">@return</span> Size 返回得到的测量值和状态</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasuredState)</span> </span>&#123;</div><div class="line">  <span class="comment">//获取测量模式</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">  <span class="comment">//获取尺寸值</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> result;</div><div class="line">  <span class="comment">//根据不同测量模式决定最终测量结果</span></div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">        <span class="comment">//如果是 AT_MOST 最大测量模式 ，那么总高度值为测量得到的 size 值，但是最大不能超过 specSize 规定值</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">            <span class="keyword">if</span> (specSize &lt; size) &#123;</div><div class="line">              <span class="comment">//如果测量得到的 size 值超过 specSize 值，LinearLayout 高度就为 specSize 值</span></div><div class="line">                result = specSize | MEASURED_STATE_TOO_SMALL;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="comment">//如果测量得到的 size 值未超过 specSize 值，LinearLayout 高度就为 size 值</span></div><div class="line">                result = size;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">       <span class="comment">//如果是 EXACTLY 精准测量模式，即 LinearLayout 值为固定值，那么 最终 LinearLayout 高度值就为 specSize 值</span></div><div class="line">            result = specSize;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        <span class="comment">// 如果是 UNSPECIFIED 测量模式，即对子 view 没有限制 ， LinearLayout 高度值就为 size</span></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            result = size;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result | (childMeasuredState &amp; MEASURED_STATE_MASK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码总结起来就是 LinearLayout 会根据测量子 View 的情况和 MeasureSpec 约束条件来决定自己最终的大小，具体来说就是如果它的布局中高度才用 具体数值，那么它的测量过程和 View 一致，即高度为 specSize 值，如果它的布局中使用 wrap_content 那么它的高度是所有子 View 高度总和，但是不能超过父容器剩余空间。</p>
<p>最后对整个测量过程总结一下就是分为以下几步：</p>
<ol>
<li>对 LinearLayout 中的子 View 进行第一次遍历测量，主要是通过 measureChildBeforeLayout 这个方法，这个方法内部会调用 measureChildWithMargins 方法，而在 measureChildWithMargins 方法内部会去调用 child.measure(childWidthMeasureSpec, childHeightMeasureSpec) 方法进行测量。在这次的测量过程中，如果满足了第1.1步测量条件的子 view 不需要进行测量，会在后面的第5.1步中进行测量。</li>
<li>根据测量各个子 View 的高度会得到一个初步的 LinearLayout 总高度  mTotalLength 值。</li>
<li>如果 LinearLayout 设置了 android:measureWithLargestChild=”true” 属性并且测量模式为 AT_MOST或者 UNSPECIFIED 重新计算 mTotalLength 总高度。</li>
<li>根据 LinearLayout  的 heightMeasureSpec 测量模式 和已经测量得到的总高度 mTotalLength ，来确定得到最终 LinearLayout 高度和状态 。</li>
<li>根据已经测量得到的 LinearLayout 高度来重新测量确定各个子 View 的大小。</li>
<li>最终执行 setMeasuredDimension 方法设置 LinearLayout 的测量高宽。</li>
</ol>
<h1 id="6-实际问题解决"><a href="#6-实际问题解决" class="headerlink" title="6 实际问题解决"></a>6 实际问题解决</h1><p>View 的 measure 过程和 Activity 的生命周期方法不是同步执行的，因此无法保证 Activity 执行了onCreate、onStart、onResume 时某个 View 已经测量完毕了。如果View还没有测量完毕，那么获得的宽和高都是 0。下面是四种解决该问题的方法：</p>
<p>1、<strong>Activity/View#onWindowsChanged 方法</strong></p>
<p>onWindowFocusChanged 方法表示 View 已经初始化完毕了，宽高已经准备好了，这个时候去获取是没问题的。这个方法会被调用多次，当 Activity 继续执行或者暂停执行的时候，这个方法都会被调用，典型代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasWindowFocus)</span> </span>&#123;</div><div class="line">         <span class="keyword">super</span>.onWindowFocusChanged(hasWindowFocus);</div><div class="line">       <span class="keyword">if</span>(hasWindowFocus)&#123;</div><div class="line">       <span class="keyword">int</span> width=view.getMeasuredWidth();</div><div class="line">       <span class="keyword">int</span> height=view.getMeasuredHeight();</div><div class="line">      &#125;      </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>2、<strong>View.post(runnable)</strong> </p>
<p> 通过 post 将一个 Runnable 投递到消息队列的尾部，然后等待 Looper 调用此 runnable 的时候 View 也已经初始化好了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStart();</div><div class="line">    view.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> width=view.getMeasuredWidth();</div><div class="line">            <span class="keyword">int</span> height=view.getMeasuredHeight();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3、<strong>ViewTreeObsever</strong> </p>
<p> 使用 ViewTreeObserver 的众多回调方法可以完成这个功能，比如使用 onGlobalLayoutListener 接口，当 View 树的状态发生改变或者 View 树内部的 View 的可见性发生改变时，onGlobalLayout 方法将被回调。伴随着View树的变化，这个方法也会被多次调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStart();</div><div class="line">    ViewTreeObserver viewTreeObserver=view.getViewTreeObserver();</div><div class="line">    viewTreeObserver.addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</div><div class="line">            view.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">int</span> width=view.getMeasuredWidth();</div><div class="line">            <span class="keyword">int</span> height=view.getMeasuredHeight();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4、<strong>view.measure(int widthMeasureSpec, int heightMeasureSpec)</strong> </p>
<p> 通过手动对 View 进行 measure 来得到 View 的宽高，这个要根据 View 的 LayoutParams 来处理：</p>
<p>（1）<strong>match_parent</strong>：无法 measure 出具体的宽高，原因是根据上面我们分析 View 的measure 过程原理可知，此种 MeasureSpec 需要知道 parentSize ，即父容器剩余空间，而这个时候无法知道 parentSize  大小，所以无法测量。</p>
<p>（2）<strong>wrap_content:</strong> 可以采用设置最大值方法进  measure ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> widthMeasureSpec = MeasureSpec.makeMeasureSpec((<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>, MeasureSpec.AT_MOST);</div><div class="line"></div><div class="line"><span class="keyword">int</span> heightMeasureSpec = MeasureSpec.makeMeasureSpec((<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>, MeasureSpec.AT_MOST);</div><div class="line"></div><div class="line">view.measure(widthMeasureSpec, heightMeasureSpec);</div></pre></td></tr></table></figure>
<p>  <strong>注意这里作者为什么使用</strong> (1 &lt;&lt; 30) - 1 ) 来构造 MeasureSpec 呢？笔者解释是：”通过分析 MeasureSpec  的实现可以得知 View 的尺寸是使用 30 位的二进制表示，也就是说最大是 30 个 1 即（2^30-1)，也就是  (1 &lt;&lt; 30) - 1 )，在最大化模式下，使用 View 能支持的最大值去构造 MeasureSpec  是合理的“。为什么这样就合理呢？我们前面分析在子 View 使用 wrap_content 模式的时候，其测量规则是根据自身的情况去测量尺寸，但是不能超过父容器的剩余空间的最大值，换句话说就是父容器给子 View 一个最大值，然后告诉子 View 你自己看着办，但是别超过这个尺寸就行，但是现在我们自己去测量的时候不知道父容器给定的 MeasureSpec 情况， 也就是不知道父容器给多大的限定值，需要自己去构造一个MeasureSpec ，那么这个最大值我们给定多少合适呢？所以这里干脆就给一个 View 所能支持的最大值，然子 View 根据自身情况去测量，怎么也不能超过这个值就行了。</p>
<p>（3）具体数值（dp/px)：例如100px，如下 measure :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> widthMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">100</span>, MeasureSpec.EXACTLY);</div><div class="line"></div><div class="line"><span class="keyword">int</span> heightMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">100</span>, MeasureSpec.EXACTLY);</div><div class="line"></div><div class="line">view.measure(widthMeasureSpec, heightMeasureSpec);</div></pre></td></tr></table></figure>
<p> 以上四种解决方法的代码和原理上面已经详细说明，大家可以根据需要进行选择使用。</p>
<p><strong>结语：</strong></p>
<p>本次笔记主要记录 View 三大流程中的 onMeasure() 测量原理部分，笔者感觉这一部分也是比较重要和难懂的部分，在我们实际中很多问题会涉及到，所以静下心来详细记录，如有理解错误，还望指出，谢谢！！！！！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/03/view_layout_and_draw/" itemprop="url">
                  View 的工作原理下 View 的 layout 和 draw 过程 （Android 开发艺术探索读书笔记）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-03T00:00:00+08:00" content="2016-09-03">
              2016-09-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-View/" itemprop="url" rel="index">
                    <span itemprop="name">Android View</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/03/view_layout_and_draw/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/03/view_layout_and_draw/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>-文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</p>
<ul>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://github.com/yongyu0102" target="_blank" rel="external">yongyu0102</a></li>
<li>审阅者：<a href="https://github.com/melodyxxx" target="_blank" rel="external">melodyxxx</a></li>
</ul>
</blockquote>
<h1 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h1><p>本次介绍的主要内容是 View 的工作原理下 View 的 layout 和 draw 过程，同时介绍自定义 View 的注意事项并结合一个小的 Demo 进行说明，其中涉及到的 onMeasre  测量部分知识可以看上一篇文章<a href="http://yongyu.itscoder.com/2016/09/11/view_measure/" target="_blank" rel="external">View 的工作原理上 View 绘制流程梳理及 Measure 过程详解</a> ，以下开始正文：</p>
<h1 id="二、-layout-过程详解"><a href="#二、-layout-过程详解" class="headerlink" title="二、 layout 过程详解"></a>二、 layout 过程详解</h1><p> layout 的作用是 ViewGroup 来确定子元素的位置，当 ViewGroup 的位置被确定后，在  layout 中会调用 onLayout ，在 onLayout 中会遍历所有的子元素并调用子元素的 layout 方法，在子元素的 layout 方法中 onLayout 方法又会被调用，layout 方法是确定 View 本身在屏幕上显示的具体位置，即在代码中设置其成员变量 mLeft，mTop，mRight，mBottom 的值，这几个值是在屏幕上构成矩形区域的四个坐标点，就是该 View 显示的位置，不过这里的具体位置都是相对与父视图的位置而言，而 onLayout 方法则会确定所有子元素位置，ViewGroup 在 onLayout 函数中通过调用其 children 的 layout 函数来设置子视图相对与父视图中的位置，具体位置由函数 layout 的参数决定。下面我们先看 View 的layout 方法如下：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/* </span></div><div class="line"> *@param l view 左边缘相对于父布局左边缘距离</div><div class="line"> *@param t view 上边缘相对于父布局上边缘位置</div><div class="line"> *@param r view 右边缘相对于父布局左边缘距离</div><div class="line"> *@param b view 下边缘相对于父布局上边缘距离</div><div class="line"> */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line"> <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">      onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">      mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//记录 view 原始位置</span></div><div class="line">  <span class="keyword">int</span> oldL = mLeft;</div><div class="line">  <span class="keyword">int</span> oldT = mTop;</div><div class="line">  <span class="keyword">int</span> oldB = mBottom;</div><div class="line">  <span class="keyword">int</span> oldR = mRight;</div><div class="line"><span class="comment">//第1步，调用 setFrame 方法 设置新的 mLeft、mTop、mBottom、mRight 值，</span></div><div class="line"><span class="comment">//设置 View 本身四个顶点位置</span></div><div class="line"><span class="comment">//并返回 changed 用于判断 view 布局是否改变</span></div><div class="line">  <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">          setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line">             <span class="comment">//第二步，如果 view 位置改变那么调用 onLayout 方法设置子 view 位置</span></div><div class="line">             <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">    <span class="comment">//调用 onLayout</span></div><div class="line">      onLayout(changed, l, t, r, b);</div><div class="line">      mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line">      ListenerInfo li = mListenerInfo;</div><div class="line">      <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">          ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                  (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">          <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">              listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p> layout 方法大致流程：先通过上面代码第一步调用  setFrame 设置 view 本身四个顶点位置，其中 setOpticalFrame 内部也是调用 setFrame  方法来完成设置的，即为 View 的4个成员变量（mLeft，mTop，mRight，mBottom）赋值，View 的四个顶点一旦确定，那么 View 在父容器中的位置就确定了，接着进行第二步，调用 onLayout 方法，这个方法用途是父容器确定子 View 位置，和 onMeasure 方法类似， onLayout 方法的具体实现同样和具体布局有关，所以 View 和 ViewGroup 中都没有真正实现 onLayout 方法，都是一个空方法。</p>
<p>   先看一下 View 的 onLayout 方法：</p>
 <figure class="highlight plain"><figcaption><span>void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125;```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   那么对于我们自定义的 View 是继承自 View 的情况下，我们一般不需要重写 onLayout 方法，因为 这个方法用途是父容器确定子 View 位置，对于 View 来说是没有子 View 的，所以一般不需要重写。</div><div class="line"></div><div class="line">   再看一下 ViewGroup 的 onLayout 方法：</div><div class="line"></div><div class="line">```java</div><div class="line">protected abstract void onLayout(boolean changed,</div><div class="line">           int l, int t, int r, int b);</div></pre></td></tr></table></figure>
<p>   相对于 view 来说，ViewGroup 中 onLayout 多了关键字abstract的修饰，也就说对于继承自 ViewGroup 的自定义 View 必须要重写 onLayout 方法，而重载 onLayout 的目的就是安排其子元素在父视图中的具体位置，为了更好的理解，接下来我们看一下 LinearLayout  的 onLayout 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">        layoutVertical(l, t, r, b);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        layoutHorizontal(l, t, r, b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   和 onMeasure 类似，这里也是分为竖直方向和水平方向的布局安排，二者原理一样，我们选择竖直方向的 layoutVertical 来进行分析，这里给出主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = mPaddingLeft;</div><div class="line">  <span class="comment">//记录子 View 上边缘相对于父容器上边缘距离</span></div><div class="line">    <span class="keyword">int</span> childTop;</div><div class="line">    <span class="comment">//记录子 View 左边缘相对于父容器左边缘距离</span></div><div class="line">    <span class="keyword">int</span> childLeft;</div><div class="line">  <span class="comment">//第1步，主要是根据不同的 gravity 属性来确定子元素的 child 的位置</span></div><div class="line">    <span class="keyword">switch</span> (majorGravity) &#123;</div><div class="line">           <span class="keyword">case</span> Gravity.BOTTOM:</div><div class="line">               <span class="comment">// mTotalLength contains the padding already</span></div><div class="line">               childTop = mPaddingTop + bottom - top - mTotalLength;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">               <span class="comment">// mTotalLength contains the padding already</span></div><div class="line">           <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</div><div class="line">               childTop = mPaddingTop + (bottom - top - mTotalLength) / <span class="number">2</span>;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line"></div><div class="line">           <span class="keyword">case</span> Gravity.TOP:</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               childTop = mPaddingTop;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">   ...............................</div><div class="line"><span class="comment">//第2步，循环遍历子 view </span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">      <span class="comment">//获取指定位置 view </span></div><div class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">            childTop += measureNullChild(i);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</div><div class="line">          <span class="comment">//第2.1步，如果 view 可见，获取 view  的测量宽/高</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line">            <span class="comment">//获取 view  的 LayoutParams 参数</span></div><div class="line">            <span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">                    (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">        .............</div><div class="line">            <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">                childTop += mDividerHeight;</div><div class="line">            &#125;</div><div class="line">			</div><div class="line">            childTop += lp.topMargin;</div><div class="line">          <span class="comment">//第3步，设置子 view 位置</span></div><div class="line">            setChildFrame(child, childLeft, childTop + getLocationOffset(child),</div><div class="line">                    childWidth, childHeight);</div><div class="line">          <span class="comment">//第4步，重新计算子 view 的 顶部 top 位置，也就是每增加一个子 view </span></div><div class="line">          <span class="comment">//下一个子 view 的 top 顶部位置就会相应的增加</span></div><div class="line">            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</div><div class="line">            i += getChildrenSkipCount(child, i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  简单梳理下整个流程，此方法会遍历所有子 view ，并调用 setChildFrame 方法来设定子元素位置，然后重新计算 childTop ，childTop  随着子元素的遍历而逐渐增大，这就意味着后面的子元素会被放置在当前子元素的下方，这正是我们平时使用竖直方向 LinearLayout 的特性。这里我们看一下第三步执行的 setChildFrame 方法类设置子元素位置方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChildFrame</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;        </div><div class="line">    child.layout(left, top, left + width, top + height);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，这个方法只是调用子元素的 layout 方法而已，这样父元素在自己的 layout 方法中完成自己的定位之后，通过 onLayout 方法去调用了子元素的 layout 方法，子元素又会通过自己的 layout 方法完成自己的位置设定，这样一层一层的传递下去就完成了整个 view 数的 layout 过程。</p>
<p>这里我们注意到在第三步调用 setChildFrame 方法中的 传入的参数 childWidth 和 childHeight 是上面第2.1步获取的子元素的测量宽/高，而在 layout 过程中会通过 setFrame 方法设置子元素四个顶点位置，这样子元素的位置就确定了，在 setFrame 中有如下赋值语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mLeft = left;</div><div class="line">mTop = top;</div><div class="line">mRight = right;</div><div class="line">mBottom = bottom;</div></pre></td></tr></table></figure>
<p>也就是说在 LinearLayout 中其子视图显示的宽和高由 measure 过程来决定的，因此 measure 过程的意义就是为 layout 过程提供视图显示范围的参考值。为什么说是提供参考值呢？因为 layout 过程中的4个参数  left,  top, iwidth, height 完全可以由视图设计者任意指定，而最终视图的布局位置和大小完全由这4个参数决定，measure 过程得到的mMeasuredWidth 和 mMeasuredHeight 提供了视图大小的测量值，只是提供一个参考一般情况下我们使用这个参考值，但我们完全可以不使用这两个值，而自己在 layout 过程中去设定一个值，可见 measure 过程并不是必须的。</p>
<p>说到这里就不得说一下 getWidth() 、getHeight() 和 getMeasuredWidth()、getMeasuredHeight() 这两对函数之间的区别，即 View 的测量宽/高和最终显示宽/高之间的区别。首先我们看一下 getWith() 和 getHeight() 方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mRight - mLeft;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mBottom - mTop;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过 getWith() 和 getHeight() 源码和上面 setChildFrame(View child, int left, int top, int width, int height) 方法设置子元素四个顶点位置的四个变量 mLeft、mTop、mRight、mBottom 的赋值过程来看，默认情况下 getWidth() 、getHeight() 方法返回的值正好就是 view 的测量宽/高，只不过 view 的测量宽/高形成于 view 的measure 过程，而最终宽/高形成于 view 的 layout 方法中，但是对于特殊情况，两者的值是不相等的，就是我们在 layout 过程中不按默认常规套路出牌，即不使用 measure 过程得到的 mMeasuredWidth 和 mMeasuredHeight ，而是人为的去自己根据需要设定的一个值的情况，例如以下代码，重写 view 的 layout 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">  <span class="comment">//在得到的测量值基础上加100</span></div><div class="line">    <span class="keyword">super</span>.layout(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r+<span class="number">100</span>, <span class="keyword">int</span> b+<span class="number">100</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面代码会导致在任何情况下 view 的最终宽/高总会比测量宽高大100px。</p>
<h1 id="三、-draw-过程详解"><a href="#三、-draw-过程详解" class="headerlink" title="三、 draw 过程详解"></a>三、 draw 过程详解</h1><p>draw 的作用是将 view 绘制到屏幕上，view 的绘制过程准守以下几个步骤：</p>
<ol>
<li>绘制背景：<code>background.draw(canvas)</code>；</li>
<li>绘制自己：<code>onDraw()</code>；</li>
<li>绘制 children：<code>dispatchDraw</code>；</li>
<li><p>绘制装饰：<code>onDrawScrollBars</code>。</p>
<p>通过源码可以看出来，部分源码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Draw traversal performs several drawing steps which must be executed</div><div class="line">     * in the appropriate order:</div><div class="line">     *</div><div class="line">     *      1. Draw the background</div><div class="line">     *      2. If necessary, save the canvas' layers to prepare for fading</div><div class="line">     *      3. Draw view's content</div><div class="line">     *      4. Draw children</div><div class="line">     *      5. If necessary, draw the fading edges and restore layers</div><div class="line">     *      6. Draw decorations (scrollbars for instance)</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="comment">// Step 1, draw the background, if needed</span></div><div class="line">  <span class="comment">//绘制背景</span></div><div class="line">    <span class="keyword">int</span> saveCount;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</div><div class="line">        drawBackground(canvas);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class="line">        <span class="comment">// Step 3, draw the content</span></div><div class="line">      <span class="comment">//调用 onDraw 方法，绘制自己本身内容，这个方法是个空方法，没有具体实现，</span></div><div class="line">      <span class="comment">//因为每个视图的内容部分肯定都是各不相同的，这部分的功能交给子类来去实现，</span></div><div class="line">      <span class="comment">//如果要自定义 view ，需要重载该方法完成绘制工作</span></div><div class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</div><div class="line"></div><div class="line">        <span class="comment">// Step 4, draw the children</span></div><div class="line">      <span class="comment">//绘制子视图</span></div><div class="line">      <span class="comment">//View 中的 dispatchDraw()方法也是一个空方法，因为 view 本身没有子视图，所以不需要，</span></div><div class="line">      <span class="comment">//而 ViewGroup 的 dispatchDraw() 方法中就会有具体的绘制代码，来实现子视图的绘制工作</span></div><div class="line">        dispatchDraw(canvas);</div><div class="line"></div><div class="line">        <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></div><div class="line">        <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></div><div class="line">      <span class="comment">//绘制装饰</span></div><div class="line">      <span class="comment">//对视图的滚动条进行绘制，其实任何一个视图都是有滚动条的，只是一般情况下都没有让它显示出来，</span></div><div class="line">      <span class="comment">//而例如像 ListView 等控件是进行了显示而已。</span></div><div class="line">        onDrawForeground(canvas);</div><div class="line"></div><div class="line">        <span class="comment">// we're done...</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过上面代码可以发现，View 绘制过程的传递是通过 dispatchDraw() 方法完成，这个方法会遍历调用所有子视图的 draw ()方法，这样事件就一层一层的传递下去了。其中 View 中有一个特殊方法 setWillNotDraw ，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * If this view doesn't do any drawing on its own, set this flag to</div><div class="line"> * allow further optimizations. By default, this flag is not set on</div><div class="line"> * View, but could be set on some View subclasses such as ViewGroup.</div><div class="line"> *</div><div class="line"> * Typically, if you override &#123;<span class="doctag">@link</span> #onDraw(android.graphics.Canvas)&#125;</div><div class="line"> * you should clear this flag.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> willNotDraw whether or not this View draw on its own</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;</div><div class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看注释部分大概意思是，如果一个 View 不需要绘制任何内容，那么设置这个标记位为 true 后，系统会进行相应的优化，默认情况下 View 没有启动这个默认标记位，但 viewGroup 默认启用这个标记位，这个标记位对实际开发的意义是：当我们的自定义的控件继承自 viewGroup 并且本身不具备绘制功能的时候，就可以开启这个标记位，从而便于系统进行后续的优化工作，当我们明确知道 viewGrop 需要通过 onDraw 来绘制本身内容时，需要我们去关闭 WILL_NOT_DRAW 这个标记位。</p>
<h1 id="四、自定义-View"><a href="#四、自定义-View" class="headerlink" title="四、自定义 View"></a>四、自定义 View</h1><h2 id="4-1-自定义-View-分类"><a href="#4-1-自定义-View-分类" class="headerlink" title="4.1 自定义 View 分类"></a>4.1 自定义 View 分类</h2><ol>
<li><p><strong>继承自 View 重写 ondraw 方法</strong> </p>
<p>这种方法主要用于实现一些不规则的效果，即想要达到的 View 效果无法使用已有的 View 通过布局组合的方式来实现，所以需要我们自己去绘制去画一个出来，即重写 onDraw 方法，采用这种方式需要注意处理自定义的 View 支持 wrap_content ，并且 padding 也需要自己处理。</p>
</li>
<li><p><strong>继承自 ViewGroup 实现特殊的 Layout 容器</strong></p>
<p>主要实现除了 LinearLayout 、 RelativeLayout  等系统已有的 View 容器之外的特殊 View 容器，需要处理 ViewGroup 的测量 onMeasure 和布局 onLayout 这两个方法，并同时处理子元素的测量和布局。</p>
</li>
<li><p><strong>继承自 Android 系统本身已有的特定 View （如 TextView）</strong></p>
<p>这种方法是要是为拓展某个已有 View 的功能，在已有的 View 的基础上添加一些功能，方便我们重复使用，这种方法不需要我们进行特殊的处理。</p>
</li>
<li><p><strong>继承自 Android 系统本身已有的特定的 ViewGroup （如 LinearLayout)</strong></p>
<p>这种方法主要是为了实现将几个 View 组合在一起形成一个特定的组合模块，来方便我们后续进行使用，例如我们想要一个特定的 TitleBar ，我们可以可以将几个 TextView 和 Button 放在一个 LinearLayout 布局中组合成一个自定义的控件，采用这种方式不需要进行特殊的处理。</p>
</li>
</ol>
<h2 id="4-2-自定义-View-须知"><a href="#4-2-自定义-View-须知" class="headerlink" title="4.2 自定义 View 须知"></a>4.2 自定义 View 须知</h2><p>自定义 View 过程中需要注意一些事项，如果这些问题处理不好，可能会影响 View 的正常使用和性能。</p>
<ol>
<li><p><strong>让 View 支持 wrap_content</strong> </p>
<p>在自定义 View 时，如果是直接继承自 View 或者 View Group ，并且不在 onMeasure 中对 wrap_content 做特殊处理，那么在我们使用这个自定义的 View  的 wrap_content 属性时，就无法达到预期效果，而是和使用 match_parent 属性效果一样。</p>
</li>
<li><p><strong>如果有必要，让自定义的 View 支持 padding 属性</strong></p>
<p>在自定义 View 时，如果是直接继承自 View  ，不在 onDraw 方法中处理 padding ，那么该自定义的 View padding属性将失效；如果是直接继承自 ViewGrop 需要在 onMeasure 和 onLayout 中考虑 padding 和 margin 对其造成的影响，否则将导致自定义的控件 padding 和子元素的 margin 属性失效。</p>
</li>
<li><p><strong>尽量不要在 View 中使用 Handler ，没必要</strong></p>
<p>View 本身内部提供了一些列的 post 方法，完全可以替代 Handler 作用。</p>
</li>
<li><p><strong>View 中如果有线程或者动画需要在特定生命周期进行停止</strong></p>
<p>当包含此 View 的 Activity 退出或者当前 View 被 remove 掉时，View 的 onDetachedFromWindow() 方法会被调用，所以如果有需要停止的线程或者动画可以在这个方法中执行，和此方法相对应的是 onAttachedToWindow() 方法，当包含该 View 的 Activity 启动的时候，该方法就会被调用。同时当 View 变得不可见时，我们需要及时停止线程和动画，否则可能造成内存泄露。</p>
</li>
<li><p><strong>View 带有滑动嵌套情形时，需要处理好滑动冲突</strong></p>
<p>如果有滑动冲突需要合适的进行处理。如果要处理好滑动处理可以看一下<a href="http://yongyu.itscoder.com/2016/08/28/view_touchEvent_dispatch/" target="_blank" rel="external">View 事件的分发机制</a></p>
</li>
</ol>
<h2 id="4-3-自定义-View-示例"><a href="#4-3-自定义-View-示例" class="headerlink" title="4.3 自定义 View 示例"></a>4.3 自定义 View 示例</h2><h3 id="4-3-1-继承自-View-重写-onDraw-方法"><a href="#4-3-1-继承自-View-重写-onDraw-方法" class="headerlink" title="4.3.1 继承自 View 重写 onDraw 方法"></a>4.3.1 继承自 View 重写 onDraw 方法</h3><p>这种方法一般为了实现一些不规则的效果，需要我们自己去绘制去画一个出来 View 出来，即重写 onDraw 方法，采用这种方式需要考虑 View 四周的空白即处理 padding 值，而 margin 值是受父容器控制所以不需要进行处理，并且需要注意处理自定义的 View 支持 wrap_content ，即重写 onMeasure 方法，如果不进行处理那么当在 xml 文件中使用 wrap_content 属性的时候，就相当于 match_parent 属性，这里为了更详细的说明问题，我们一起来实现一个简单的自定义 View ，只简单的画一个圆出来，这里给出关键地方的代码，先看看 onMeasure 部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 这里进行重写 onMeasure 方法，让自定义的 View 支持 Wrap_content 模式</div><div class="line"> * 当使用该自定义的 View 时候，如果使用了 Wrap_content 属性后</div><div class="line"> * 该 View  的宽和高都为 200dp ，这个尺寸在实际应用中需要根据具体需要和情况进行计算</div><div class="line"> * 这里只是为了解释这个原理，任意给定了一个值恰巧是 200dp 而已</div><div class="line"> * <span class="doctag">@param</span> widthMeasureSpec 父容器给定的宽度约束条件</div><div class="line"> * <span class="doctag">@param</span> heightMeasureSpec 父容器给定的高度约束条件</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    <span class="comment">// 在 xml 文件中使用 wrap_content 属性时，该 View 的默认宽/高值为 200dp</span></div><div class="line">    <span class="keyword">int</span> width=<span class="number">200</span>;</div><div class="line">    <span class="keyword">int</span> height=<span class="number">200</span>;</div><div class="line">  <span class="comment">//获取测量值和模式</span></div><div class="line">    <span class="keyword">int</span> widthMode=MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> heightMode=MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">    <span class="keyword">int</span> withSize=MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> heightSize=MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">    <span class="keyword">if</span>(widthMode==MeasureSpec.AT_MOST&amp;&amp;heightMode==MeasureSpec.AT_MOST)&#123;</div><div class="line">        <span class="comment">//宽和高都为 wap_content 模式，进行设定默认值</span></div><div class="line">        setMeasuredDimension(width,height);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(widthMode==MeasureSpec.AT_MOST)&#123;</div><div class="line">        <span class="comment">//如果只有宽为 wrap_content 模式</span></div><div class="line">        setMeasuredDimension(width,heightSize);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(heightMode==MeasureSpec.AT_MOST)&#123;</div><div class="line">        <span class="comment">//如果只有高为 wrap_content 模式</span></div><div class="line">        setMeasuredDimension(withSize,height);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码就解决了让 自定义的 View 支持 wrap_content 的问题。下面在看看在 onDraw 方法中进行绘制的时候处理  padding 值的问题，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 这里进行绘制 View 的内容，这里要注意需要处理 padding 值，</div><div class="line"> * 让自定义的 View 支持 padding 属性，如果不处理，</div><div class="line"> *那么在 xml 文件中使用该自定义的 View 的 padding</div><div class="line"> * 属性时候，将会失效</div><div class="line"> * <span class="doctag">@param</span> canvas 画布</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">    <span class="comment">//获取 view 最终宽和高</span></div><div class="line">    <span class="keyword">int</span> width=getWidth();</div><div class="line">    <span class="keyword">int</span> height=getHeight();</div><div class="line">    <span class="comment">//获取 padding 值</span></div><div class="line">    <span class="keyword">int</span> paddingLeft=getPaddingLeft();</div><div class="line">    <span class="keyword">int</span> paddingRight=getPaddingRight();</div><div class="line">    <span class="keyword">int</span> paddingTop=getPaddingTop();</div><div class="line">    <span class="keyword">int</span> paddingBottom=getPaddingBottom();</div><div class="line">    <span class="comment">//计算去掉 padding 的宽和高</span></div><div class="line">    <span class="keyword">int</span> withFinal=width-paddingLeft-paddingRight;</div><div class="line">    <span class="keyword">int</span> heightFinal=height-paddingTop-paddingBottom;</div><div class="line">    <span class="comment">//计算半径</span></div><div class="line">    <span class="keyword">int</span> radius=Math.min(withFinal/<span class="number">2</span>,heightFinal/<span class="number">2</span>);</div><div class="line">    <span class="comment">//绘制视图内容</span></div><div class="line">    <span class="comment">//确定x轴和y轴圆中心点位置，主要受 paddingLeft 和 withFinal/2 影响</span></div><div class="line">    <span class="comment">//即受左上方侧偏移量和圆半径有关，与 RightPadding 无关</span></div><div class="line">    canvas.drawCircle(paddingLeft+withFinal/<span class="number">2</span>,paddingTop+heightFinal/<span class="number">2</span>,radius,paint);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码解决了让自定义的 View 支持 padding 属性。</p>
<h3 id="4-3-2-继承自-ViewGroup-实现特殊的-Layout-容器"><a href="#4-3-2-继承自-ViewGroup-实现特殊的-Layout-容器" class="headerlink" title="4.3.2 继承自 ViewGroup  实现特殊的 Layout 容器"></a>4.3.2 继承自 ViewGroup  实现特殊的 Layout 容器</h3><p>这种自定义的 ViewGroup 需要处理 onMeasure 测量和 onLayout 布局两个过程，同时需要处理子元素的测量和布局过程。采用这种方法实现一个规范的自定义 View 是相当复杂的，通过前面分析的 LinearLayout 代码就可以发现，因为要考虑如何摆放子视图以及各种细节的处理，Android 开发艺术探索书中给出了一个相对规范（不完全规范）的自定义的 HorizontalScrollViewEx 视图容器，实现了一个类似 ViewPaper 的控件，内部子视图可以水平方向滑动，并且子视图的内部子元素可以实现竖直方向滑动，很显然这个控件解决了水平方向和竖直方向滑动冲突的问题，该部分知识可以看一下<a href="http://yongyu.itscoder.com/2016/08/28/view_touchEvent_dispatch/" target="_blank" rel="external">View 的事件分发机制（Android 开发艺术探索读书笔记）</a> 这篇文章从源码角度分析了事件分发机制，理解了就可以解决滑动冲突的问题。下面一起看一下关键部分代码，先看 onMeasure 部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 重写 onMeasure 方法，处理自定义 View 支持 wrap_content 模式</div><div class="line"> * <span class="doctag">@param</span> widthMeasureSpec 父容器给定宽度约束条件</div><div class="line"> * <span class="doctag">@param</span> heightMeasureSpec 父容器给定高度约束条件</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    <span class="keyword">int</span> measuredWidth = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> measuredHeight = <span class="number">0</span>;</div><div class="line">    <span class="comment">//获取子视图个数</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">    <span class="comment">//测量子视图</span></div><div class="line">    measureChildren(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    <span class="comment">//获取父容器给定测量模式和测量值</span></div><div class="line">    <span class="keyword">int</span> widthSpaceSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> heightSpaceSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">    <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">    <span class="keyword">if</span> (childCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//如果没有子视图直接设定 View 的宽/高为0</span></div><div class="line">        setMeasuredDimension(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        <span class="comment">//如果视图宽/高都采用 wrap_content 模式</span></div><div class="line">        <span class="keyword">final</span> View childView = getChildAt(<span class="number">0</span>);</div><div class="line">        <span class="comment">//宽度为第一个视图宽度乘以所有子视图个数</span></div><div class="line">        measuredWidth = childView.getMeasuredWidth() * childCount;</div><div class="line">       <span class="comment">// 高度为第一个视图宽度</span></div><div class="line">        measuredHeight = childView.getMeasuredHeight();</div><div class="line">        <span class="comment">//设置 自定义视图宽/高值</span></div><div class="line">        setMeasuredDimension(measuredWidth, measuredHeight);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        <span class="comment">//如果只有视图高采用 wrap_content 模式</span></div><div class="line">        <span class="keyword">final</span> View childView = getChildAt(<span class="number">0</span>);</div><div class="line">        <span class="comment">//设置视图高度为第一个视图高度</span></div><div class="line">        measuredHeight = childView.getMeasuredHeight();</div><div class="line">        setMeasuredDimension(widthSpaceSize, childView.getMeasuredHeight());</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        <span class="comment">//如果视图宽度使用 wrap_content 模式，设置宽度为第一个视图宽度乘以所有子视图个数</span></div><div class="line">        <span class="keyword">final</span> View childView = getChildAt(<span class="number">0</span>);</div><div class="line">        measuredWidth = childView.getMeasuredWidth() * childCount;</div><div class="line">        setMeasuredDimension(measuredWidth, heightSpaceSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码实现了让自定义的 View 支持  wrap_content 属性。</p>
<p><strong>说明，这里为了方便处理有几处不规范的地方如下：</strong></p>
<ol>
<li>假设了所有子视图的高度和宽度都相等，而实际应用中这是不可能的，所以计算起来会更复杂。</li>
<li>没有子元素的时候不应该直接设置宽/高为 0，而是应该根据 LayoutParams 的宽/高来做相应的处理，因为当使用 padding 属性的时候，虽然没有子视图，但 padding 值也会占据一定空间，你可以设置 LinearLayout 子视图个数为 0，然后给定一个 padding 值去试试。</li>
<li>在测量 HorizontalScrollViewEx  的高/宽的时候没有考虑它的 padding 值和子视图的 margin 值，因为自己的 padding 值和子视图的 margin 值都是占据空间的。</li>
</ol>
<p>下面再看一下 onLayout 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 重写 onLayout 方法，实现摆放子视图功能</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="comment">//记录子视图左边距位置</span></div><div class="line">    <span class="keyword">int</span> childLeft = <span class="number">0</span>;</div><div class="line">    <span class="comment">//获取子视图个数</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">    <span class="comment">//记录子视图个数</span></div><div class="line">    mChildrenSize = childCount;</div><div class="line">    <span class="comment">//遍历子视图</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">        <span class="comment">//获取子视图</span></div><div class="line">        <span class="keyword">final</span> View childView = getChildAt(i);</div><div class="line">        <span class="keyword">if</span> (childView.getVisibility() != View.GONE) &#123;</div><div class="line">            <span class="comment">//如果子视图可见，获取子视图测量宽度</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidth = childView.getMeasuredWidth();</div><div class="line">            <span class="comment">//记录子视图宽度</span></div><div class="line">            mChildWidth = childWidth;</div><div class="line">            <span class="comment">//设置摆放子视图位置，每次子视图放置在上一个子视图右边依次排放</span></div><div class="line">            childView.layout(childLeft, <span class="number">0</span>, childLeft + childWidth,</div><div class="line">                    childView.getMeasuredHeight());</div><div class="line">            childLeft += childWidth;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码实现了摆放子视图的功能，从代码可以看出放置子视图是从左至右依次摆放。</p>
<p><strong>说明，以上代码不规范之处：</strong></p>
<p>在摆放子视图的过程中，没有考虑自身的 padding 和子视图的 margin 值。</p>
<h3 id="4-3-3-自定义-View-的总结"><a href="#4-3-3-自定义-View-的总结" class="headerlink" title="4.3.3 自定义 View 的总结"></a>4.3.3 自定义 View 的总结</h3><p>到这里，关于 View 的基础知识基本学习完毕，笔者写到这里也完全不能写出了一个牛逼的自定义控件（一个基友曾经这样问我：你学完了这些知识，还不徒手撸出一个牛逼的自定义 View 啊——–<a href="http://extremej.itscoder.com/" target="_blank" rel="external">阿风</a> ，我的回答当然不能。因为自定义 View 是一个综合的知识体系，需要灵活的运用各种知识和经验，这里我们只是学习了一下基础理论知识，知其原理，懂其思路，如果我们想自定义 View，首先要掌握基本功，比如 <a href="http://yongyu.itscoder.com/2016/08/14/view_to_scroll/" target="_blank" rel="external">View 的弹性滑动</a>，<a href="http://yongyu.itscoder.com/2016/08/28/view_touchEvent_dispatch/" target="_blank" rel="external">滑动冲突</a>，绘制原理等，这些都是自定义 View 所必须知识点，再复杂的自定义 View 也是离不开这些知识点，尤其是那些看起来很炫酷的自定义 View，往往对这些技术点要求更高，只有熟悉掌握这些基础知识点以后，在面对新的自定义 View 时，才能够根据需求情况选择合适的实现思路，实现大体方法就是 4.1 节中介绍的四种分类，另外还需要学习一下 Canvas 这个类的用法才能画出想要的 View 。</p>
<p>最后，文章中的 Demo 会上传在 github，<a href="https://github.com/yongyu0102/ViewDrawDemo" target="_blank" rel="external">链接地址</a> ，这里只是一个简单的 Demo ，分析一下原理，（这些 Demo 源码出自 Android 开发艺术探索）如果想撸出更炫酷的 View 还需要掌握 Canvas 这个类的用法，后面需要续学习。</p>
<p>以上就是本次的笔记内容，如有错误，希望指出，谢谢！！！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/28/view_touchEvent_dispatch/" itemprop="url">
                  View 的事件分发机制（Android 开发艺术探索读书笔记）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-28T18:19:27+08:00" content="2016-08-28">
              2016-08-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-View/" itemprop="url" rel="index">
                    <span itemprop="name">Android View</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/28/view_touchEvent_dispatch/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/28/view_touchEvent_dispatch/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>-文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</p>
<ul>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://github.com/yongyu0102" target="_blank" rel="external">yongyu0102</a></li>
<li>审阅者：<a href="https://github.com/melodyxxx" target="_blank" rel="external">HanJie</a></li>
</ul>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在写这篇笔记的时候想了好久，也拖了好长时间，关于事件分发的博客看了很多，有的写的思路很清晰，画了事件分发的整体流程图，但是没有源码，看过之后只能知道事件是怎么分发的，但完全是记住的，而不是通过源码分析出来的，试想，如果以后再遇到其他知识点还是这样，那么我们就完全成了不能靠自己去分析问题，只能去食他人知识，没有自我学习分析能力，所以笔者试着结合艺术探索的讲解，尝试在源码的基础上加以理解，本文的写作逻辑是先从文字描述上尽量让大家先大概了解，事件分发的概况，先有个感性认识，再结合源码进行分析，如果错误的地方，还请指出。</p>
<h3 id="1-1-点击事件的传递规则"><a href="#1-1-点击事件的传递规则" class="headerlink" title="1.1 点击事件的传递规则"></a>1.1 点击事件的传递规则</h3><p>在我们进行分析事件分发机制之前，先思考一下我们要研究哪些问题：</p>
<p><strong>1、事件分发的对象是什么？</strong></p>
<p>当用户触摸屏幕时，将创建一个 MotionEvent 对象即点击事件。MotionEvent 包含关于发生触摸的位置、时间、历史记录、手势动作等细节信息， Touch 事件相关细节被封装成了 MotionEvent 对象。理解了这一个知识点后，其实我们就很容易理解所谓点击事件的分发，其实就是对 MotionEvent 事件分发的过程，即当一个 MotionEvent 产生后，系统需要把这个事件传递给一个具体的 View 去处理, 而这个传递的过程就是分发过程。</p>
<p><strong>2、事件是在哪些对象之间传递？</strong></p>
<p>Android 与用户交互的界面就是由一系列 Activity（Fragment)、ViewGroup、View 组成如图：</p>
<p>​                                                 <img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/Activity_ViewGroup_View.png?raw=true" alt="Activity_ViewGroup_View"></p>
<p>当然一个界面可能由多个ViewGroup或者多个View 组成，所以事件就是在这三者之间进行传递，我们要分析的就是要捋清楚事件是由哪个对象发出，经过哪些对象，最终达到哪个对象，在某些条件改变的时候下他们之间的关系又是怎样的，理解了这些之后，当我们在遇到点击或者滑动事件冲突的情况，相信一切问题就迎刃而解了。</p>
<p><strong>3、这个分发过程由哪些对象协作完成？</strong></p>
<p>其实点击事件分发过程主要由三个重要方法共同完成：dispatchTouchEvent(MotionEvent event) 、onInterceptTouchEvent(MotionEvent event)和onTouchEvent(MotionEvent event)，下面先介绍一下这三个方法的主要作用，这样有利于后面我们对源码的分析：</p>
<ol>
<li><p>public boolean dispatchTouchEvent(MotionEvent event) ：用来进行事件的分发。如果事件能够传递给当前view，那么此方法一定会被调用，返回结果受当前 view 的 onTouchEvent 和下级 view 的 dispatchTouchEvent 方法的影响，表示是否消耗当前事件。返回值 true，表示触摸事件被消费，已经分发出去，后续事件会继续分发到该 View；返回值 false，则表示触摸事件没有被消费，即事件没有分发出去，那么后续事件就不会继续向该 View 分发，该方法在 View 和 ViewGroup 中都有。</p>
</li>
<li><p>public boolean onInterceptTouchEvent(MotionEvent event)<br>在 dispatchTouchEvent 方法内部调用，用来判断是否拦截某个事件，如果当前 view 拦截了某个事件，那么在同一个事件序列当中，此方法不会再被调用，返回结果表示是否拦截当前事件。只有 ViewGroup 中才有该方法 ，返回值 true，表示ViewGroup拦截了该触摸事件，该事件就不会分发给它的子 View 或者子 ViewGroup，事件会由自己的 onTouchEvent() 方法处理。返回值 false，表示 ViewGroup 没有拦截该事件，该事件就可以分发给它的子 View 和子 ViewGroup ，事件传递到子 view 的 dispatchTouchEvent() 方法中去处理。</p>
</li>
<li><p>public boolean onTouchEvent(MotionEvent event)<br>在 dispatchTouchEvent 方法内部调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果 ACTION_DOWN不消耗，则在同一个事件序列中，当前 view 无法再次接收到事件。返回值为 True ，事件由自己处理，后续事件序列让其处理；返回值为 False ，自己不消耗事件，向上返回让其他的父容器的onTouchEvent接受处理。</p>
<p>这三个方法都是通过 dispatchTouchEvent() 联系在一起，他们之间的关系可以用如下伪代码表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">  <span class="comment">//表示事件是否被分发出去（消耗），默认为false，即默认不拦截</span></div><div class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;</div><div class="line">      <span class="comment">//如果拦截了，那么事件交给当前view的onTouchEvent(ev)</span></div><div class="line">      <span class="comment">//方法进行处理，返回值即onTouchEvent(ev)的结果</span></div><div class="line">        consume = onTouchEvent(ev);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">     <span class="comment">//如果不拦截，那么事件交给子view的dispatchTouchEvent(ev)</span></div><div class="line">      <span class="comment">//方法进行处理，返回值即是dispatchTouchEvent(ev)事件</span></div><div class="line">      <span class="comment">//处理结果</span></div><div class="line">        consume = child.dispatchTouchEvent(ev);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> consume;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>结论：对于一个根 ViewGroup，点击事件产生后，首先会传递给它，这时 ViewGroup 的 dispatchTouchEvent 会调用，而在 dispatchTouchEvent 方法中会调用 onInterceptTouchEvent() 方法，如果它的 onInterceptTouchEvent 返回 true 表示要拦截当前事件，接下来事件会交给这个 ViewGroup 处理，此时 ViewGroup 的 onTouchEvent 方法就会被调用，如果这个ViewGroup 的 onInterceptTouchEvent 返回 false，则事件会继续传递给子元素，子元素的 dispatchTouchEvent 会调用，如此反复直到事件被处理。</p>
<p>当一个View需要处理事件时，如果设置了 OnTouchListener ，那么 OnTouchListener 的 onTouch方法会回调，如果 onTouch 返回 false，则当前 View 的 onTouchEvent 方法会被调用；如果返回 true，那么 onTouchEvent 方法将不会调用。由此可见，OnTouchListener 优先级高于 onTouchEvent。OnClickListener 优先级处在事件传递的尾端。</p>
<p><strong>4、事件的传递顺序是什么？</strong></p>
<p>这里就直接给出答案:一个点击事件产生后，传递顺序：Activity -&gt; Window -&gt; ViewGroup  -&gt; View；如果一个 View 的 onTouchEvent 返回 false 即 View 没有处理事件，那么它的父容器的onTouchEvent 会被调用，以此类推，所有元素都不处理该事件，最终将传递给 Activity 处理，即 Activity 的 onTouchEvent 会被调用，事件顺序为：View -&gt;  ViewGroup -&gt; Window -&gt;  Activity。</p>
<p>5、关于事件传递的其他一些结论这里先给出，以便我们更好的理解时间传递机制，结论如下：</p>
<ol>
<li>同一个事件序列是指从手指触摸屏幕那一刻开始，中间包含数量不定的 move 事件到手指离开屏幕那一刻（down-&gt;move…move-&gt;up)。</li>
<li>正常情况下一个事件序列只能被一个 View 拦截且消耗，每个 View  一旦决定拦截，同一个事件序列所有事件都会直接交给它处理，并且它的 onInterceptTouchEvent 不会再被调用。</li>
<li>某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN（ onTouchEvent  返回了 false ），那么同一事件序列中其他事件都不会再交给它来处理，事件将重新交给他的父元素处理，即父元素的 onTouchEvent 会被调用。</li>
<li>如果某个 View 不消耗除  ACTION_DOWN 以外的其他事件，那么这个点击事件会消失，此时父元素的 onTouchEvent 并不会被调用，并且当前 View 可以收到后续事件，最终这些消失的点击事件会传递给 Activity 处理。</li>
<li>ViewGroup 默认不拦截任何事件，ViewGroup 的 onInterceptTouchEvent 方法默认返回 false。</li>
<li>View 没有 onInterceptTouchEvent 方法，一旦有事件传递给它，那么它的 onTouchEvent 方法就会被调用。</li>
<li>View 的 onTouchEvent 方法默认消耗事件（返回 true ），除非他是不可点击的（ clickable 和 longClickable 同时为 false ）。View 的 longClickable 属性默认都为 false ，clickable 属性分情况，Button 默认为 true，TextView 默认为 false。</li>
<li>onClick 发生的前提是View可点击，并且它收到了down 和 up 事件。</li>
<li>事件传递过程是由外而内，事件总是先传递给父元素，然后在由父元素分发给子 View，通过requestDisallowInterceptTouchEvent 方法可以在子元素干预父元素的事件分发过程，但 ACTION_DOWN 事件除外。                </li>
</ol>
<h3 id="1-2-事件分发的源码解析"><a href="#1-2-事件分发的源码解析" class="headerlink" title="1.2 事件分发的源码解析"></a>1.2 事件分发的源码解析</h3><p>这里要分别分析 Activity  、ViewGroup 和 View 对事件的分发。</p>
<h4 id="1-Activity-对点击事件的分发过程"><a href="#1-Activity-对点击事件的分发过程" class="headerlink" title="1. Activity 对点击事件的分发过程"></a>1. Activity 对点击事件的分发过程</h4><p>   由于平时我们对 Activity 事件分发接触不是很多（笔者是这样），使用应该不是很多，所以这里只做简单介绍。</p>
<p>   (1) Activity 中与触摸事件相关API主要是 dispatchTouchEvent() 和 onTouchEvent()。dispatchTouchEvent() 是传递触摸事件的API，而 onTouchEvent() 则是 Activity 处理触摸事件的API。</p>
<p>   (2) Activity 中的 dispatchTouchEven 会将触摸事件传递给Activity 所包含的视图。具体的实现方式在通过调用到 Activity 所属 Window 的  superDispatchTouchEvent，进而调用到 Window 的 DecorView 的 superDispatchTouchEvent，进一步又调用到 ViewGroup 的 dispatchTouchEvent() ，这样事件就从 Activity 传递到了 ViewGroup 。<br>   如果 Activity 所包含的视图拦截或者消费了该触摸事件的话，就不会再执行 Activity 的 onTouchEvent() ；<br>   如果 Activity 所包含的视图没有拦截或者消费该触摸事件的话，则会执行 Activity 的 onTouchEvent() 。<br>   (3) Activity 中的 onTouchEvent 是 Activity 自身对触摸事件的处理。如果该 Activity 的 android:windowCloseOnTouchOutside 属性为 true，并且当前触摸事件是 ACTION_DOWN ，而且该触摸事件的坐标在 Activity 之外，同时 Activity 还包含了视图的话就会导致 Activity 被结束。</p>
<h4 id="2-View-对点击事件的处理过程"><a href="#2-View-对点击事件的处理过程" class="headerlink" title="2. View 对点击事件的处理过程"></a>2. View 对点击事件的处理过程</h4><p>   这里的 View 不包含 ViewGroup ，这里说下为什么先分析 View 而不是像书上那样先分析 ViewGroup ，因为在 ViewGroup 的事件分发过程中会调用到 View 对事件的处理，而且 View 的事件处理相比 ViewGroup 而言简单些，所以这里先分析 View 。</p>
<p>   我们来看一下 View 中 dispatchTouchEvent 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span> <span class="params">(MotionEvent event)</span></span>&#123;</div><div class="line">        .........</div><div class="line">        <span class="comment">//标记处理结果是否成功</span></div><div class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">        ...........</div><div class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            <span class="comment">// 如果 mListenerInfo 不为 null，且点击的控件是否是 enable 的</span></div><div class="line">            <span class="comment">//那么就会调用 mOnTouchListener.onTouch(this, event) 方法</span></div><div class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></div><div class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">                <span class="comment">//如果 mOnTouchListener.onTouch(this, event)</span></div><div class="line">                <span class="comment">//方法返回值为 Ture</span></div><div class="line">                <span class="comment">//那么 设置 result = true;即 dispatchTouchEvent </span></div><div class="line">                <span class="comment">//方法返回值为 true</span></div><div class="line">                result = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果 result 为 false ，则调用 onTouchEvent(event)方法</span></div><div class="line">        <span class="comment">//也就是如果 mOnTouchListener.onTouch(this, event)方法返回 true</span></div><div class="line">        <span class="comment">//那么 onTouchEvent(event)方法就不会调用</span></div><div class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">            <span class="comment">//如果 onTouchEvent(event) 返回值为 true ，</span></div><div class="line">            <span class="comment">//那么 dispatchTouchEvent 方法返回 true</span></div><div class="line">            result = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">.............</div><div class="line">    <span class="comment">//返回处理结果</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   从上面源码的10行代码可以看出，首先会判断 mOnTouchListener 是否为空，而mOnTouchListener 是在 setOnTouchListener 方法里赋值的，也就是说只要我们给控件注册了touch 事件，mOnTouchListener 就一定不为空，而(mViewFlags &amp; ENABLED_MASK) == ENABLED 是判断当前点击的控件是否是 enable 的，按钮默认都是 enable 的，因此这个条件恒定为 true。mOnTouchListener.onTouch(this, event)，其实也就是去回调控件注册 touch 事件时的 onTouch 方法。也就是说如果我们在 onTouch 方法里返回 true，就会让这三个条件全部成立，从而整个方法返回 true。在结合22行代码 if (!result &amp;&amp; onTouchEvent(event))，可以得出结论，如果我们在 onTouch 方法里返回 false，就会再去执行 onTouchEvent(event)方法，如果 onTouch 方法里返回 true ，onTouchEvent(event) 方法将不会执行, 可见 OnTouchListener 优先级高于 onTouchEvent(event) 方法。<br>   接下来我们分析一下 onTouchEvent(event) 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;   </div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</div><div class="line">      <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</div><div class="line">  <span class="comment">// 如果是不可用状态下</span></div><div class="line">      <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">          <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">              setPressed(<span class="keyword">false</span>);</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// A disabled view that is clickable</span></div><div class="line">          <span class="comment">//still consumes the touch</span></div><div class="line">          <span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">          <span class="comment">//只要 view 是 clickable 那么仍然会消费事件，</span></div><div class="line">          <span class="comment">//返回值为 true，</span></div><div class="line">          <span class="comment">//只不过不响应事件</span></div><div class="line">          <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</div><div class="line">                  || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class="line">                  || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 如果 view 是 CLICKABLE 或者 LONG_CLICKABLE，</span></div><div class="line">      <span class="comment">//即 view 是 clickable 状态</span></div><div class="line">      <span class="comment">// 就会进入以下方法的 switch 语句 ACTION_MOVE、ACTION_UP、</span></div><div class="line">      <span class="comment">// ACTION_DOWN、ACTION_CANCEL、ACTION_CANCEL</span></div><div class="line">      <span class="comment">//各种状态的处理</span></div><div class="line">      <span class="comment">//无论处于那种状态，最终返回结果都是 true</span></div><div class="line">      <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">              (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||(viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</div><div class="line">          <span class="keyword">switch</span> (action) &#123;</div><div class="line">              <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                  <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</div><div class="line">                  <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepresse</div><div class="line">                      <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</div><div class="line">                      <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class="line">                          focusTaken = requestFocus();</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                          setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class="line">                          removeLongPressCallback();</div><div class="line">                          <span class="keyword">if</span> (!focusTaken) &#123;</div><div class="line">                              <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</div><div class="line">                                  mPerformClick = <span class="keyword">new</span> PerformClick();</div><div class="line">                              &#125;</div><div class="line">                              <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                                  performClick();</div><div class="line">                              &#125;</div><div class="line">                          &#125;</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</div><div class="line">                          mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                          postDelayed(mUnsetPressedState,</div><div class="line">                                  ViewConfiguration.getPressedStateDuration());</div><div class="line">                      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</div><div class="line">                          mUnsetPressedState.run();</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      removeTapCallback();</div><div class="line">                  &#125;</div><div class="line">                  mIgnoreNextUpEvent = <span class="keyword">false</span>;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line"></div><div class="line">              <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                  mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                  <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  &#125;</div><div class="line">                  <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</div><div class="line"></div><div class="line">                  <span class="keyword">if</span> (isInScrollingContainer) &#123;</div><div class="line">                      mPrivateFlags |= PFLAG_PREPRESSED;</div><div class="line">                      <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</div><div class="line">                          mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</div><div class="line">                      &#125;</div><div class="line">                      mPendingCheckForTap.x = event.getX();</div><div class="line">                      mPendingCheckForTap.y = event.getY();</div><div class="line">                      postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class="line">                  &#125; <span class="keyword">else</span> &#123;</div><div class="line">                      setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                      checkForLongClick(<span class="number">0</span>);</div><div class="line">                  &#125;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line"></div><div class="line">              <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">                  setPressed(<span class="keyword">false</span>);</div><div class="line">                  removeTapCallback();</div><div class="line">                  removeLongPressCallback();</div><div class="line">                  mInContextButtonPress = <span class="keyword">false</span>;</div><div class="line">                  mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line">                  mIgnoreNextUpEvent = <span class="keyword">false</span>;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line"></div><div class="line">              <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                  drawableHotspotChanged(x, y);</div><div class="line">                  <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                      <span class="comment">// Outside button</span></div><div class="line">                      removeTapCallback();</div><div class="line">                      <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">                          removeLongPressCallback();</div><div class="line"></div><div class="line">                          setPressed(<span class="keyword">false</span>);</div><div class="line">                      &#125;</div><div class="line">                  &#125; </div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">      <span class="comment">//如果该控件是可以点击的就会进入 switch 判断中去，</span></div><div class="line">      <span class="comment">//最终返回值为 true ，即 onTouchEvent</span></div><div class="line">          <span class="comment">//返回值为 true 。</span></div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">  <span class="comment">//如果该控件是不可点击的返回 false ，如 TextView</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>   先看第7行代码 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) 这个条件是判断 view 是不可用状态，而在该条件下我们看第17行代码 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class="line"> || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div></pre></td></tr></table></figure>
<p>   这个返回结果是判断只要 view 是可点击状态 那么返回值就问 true ，即如果  view 是不可用状态，但只要 view 是可点击状态，就会消耗点击事件，只不过不响应结果。<br>   再看第33行会判断只要 view 是可点击的，那么就会进入到下面的 switch 语句，最终在第123行返回 true，即只要 view 是可点击的，那么 ontouchEvent（Event v) 方法就会返回 true 消费点击事件。<br>   然后在 ACTION_UP 事件触发的时候，在55行代码会执行 performClick() 方法，我们看一下这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> result;</div><div class="line">          <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</div><div class="line">          <span class="comment">//如果 mOnClickListener 不为null，就会调用</span></div><div class="line">          <span class="comment">// mOnClickListener.onClick(this) 方法</span></div><div class="line">          <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</div><div class="line">              playSoundEffect(SoundEffectConstants.CLICK);</div><div class="line">              <span class="comment">//这个方法就是 回调</span></div><div class="line">              <span class="comment">//我们给 view 设置的 view.setOnClickListener()方法</span></div><div class="line">              li.mOnClickListener.onClick(<span class="keyword">this</span>);</div><div class="line">              result = <span class="keyword">true</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              result = <span class="keyword">false</span>;</div><div class="line">          &#125;</div><div class="line">   sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</div><div class="line">     <span class="keyword">return</span> result;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>   上面第6行代码 if (li != null &amp;&amp; li.mOnClickListener != null) 判断如果给当前 view 设置了点击事件，那么就会执行回调设置的 onClick() 方法即 mOnClickListener.onClick(this)，这样 view 的 dispatchTouchEvent(MotionEvent event) 这里就分析结束了！</p>
<h4 id="3-ViewGroup-对点击事件的处理过程"><a href="#3-ViewGroup-对点击事件的处理过程" class="headerlink" title="3 ViewGroup 对点击事件的处理过程"></a>3 ViewGroup 对点击事件的处理过程</h4><p>   同样我们来看一下 ViewGroup 中 dispatchTouchEvent 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">  ............</div><div class="line"><span class="comment">//标记是否分发成功</span></div><div class="line"><span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</div><div class="line"><span class="comment">// 第1步：检测是否要分发该触摸事件</span></div><div class="line"><span class="comment">// 如果该 View 不是位于顶部，并且有设置属性使该 View 不在顶部时不响应触摸事件</span></div><div class="line"><span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        <span class="comment">// 如果是 ACTION_DOWN(即按下事件)，则清空之前的触摸事件处理目标和状态。</span></div><div class="line">        cancelAndClearTouchTargets(ev);</div><div class="line">        resetTouchState();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 标记 ViewGroup 是否要拦截事件</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</div><div class="line">  <span class="comment">//第2步，判断是否拦截事件</span></div><div class="line">    <span class="comment">// 如果是 ACTION_DOWN  或者 mFirstTouchTarget不为null , </span></div><div class="line">  <span class="comment">//记住 mFirstTouchTarget 在事件分发到</span></div><div class="line">    <span class="comment">// 子 view 的时候会被负值， 即一旦 事件传递到子 view 后 mFirstTouchTarget 不为 null ,而</span></div><div class="line">    <span class="comment">// 一旦在 ACTION_DOWN 时候拦截了事件，那么 mFirstTouchTarget=null ;此时 intercepted=true</span></div><div class="line">    <span class="comment">//进行拦截，这就是前面说的，一旦在 ACTION_DOWN 时候拦截了事件，那么后续事件将由 ViewGroup</span></div><div class="line">    <span class="comment">//处理，不分发到子 view 。</span></div><div class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">            || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 检查禁止拦截标记：FLAG_DISALLOW_INTERCEPT</span></div><div class="line">        <span class="comment">// 如果调用了子 view 调用了 requestDisallowInterceptTouchEvent()标记的话，</span></div><div class="line">      <span class="comment">//则FLAG_DISALLOW_INTERCEPT会为true。</span></div><div class="line">        <span class="comment">//意思是禁止父类进行拦截事件</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">            <span class="comment">// 如果禁止拦截标示为 false ,那么调用 ViewGroup 的onInterceptTouchEvent(ev) 方法</span></div><div class="line">            <span class="comment">//获取是否拦截标记 ，onInterceptTouchEvent(ev) 返回值默认为 false</span></div><div class="line">            intercepted = onInterceptTouchEvent(ev);</div><div class="line">            ev.setAction(action); <span class="comment">// restore action in case it was changed</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//如果子 view 调用了requestDisallowInterceptTouchEvent() ，</span></div><div class="line">          <span class="comment">//那么 !disallowIntercept 为false ，此时 intercepted=false，</span></div><div class="line">          <span class="comment">//ViewGroup 的 onInterceptTouchEvent(ev) 将失效</span></div><div class="line">            intercepted = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//这就是上面提到的 一旦在 ACTION_DOWN 时候拦截了事件，那么 mFirstTouchTarget=null</span></div><div class="line">        <span class="comment">//此时  intercepted = true; 继续拦截</span></div><div class="line">        intercepted = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ..............</div><div class="line"></div><div class="line">    TouchTarget newTouchTarget = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//  标记已经将事件是否发生到目标 view</span></div><div class="line">    <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</div><div class="line">        View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</div><div class="line">                ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</div><div class="line">         <span class="comment">//第3步，如果不拦截，不取消，进行事件分发</span></div><div class="line">        <span class="comment">// 在 ACTION_DOWN、ACTION_POINTER_DOWN 或者 ACTION_HOVER_MOVE 动作的时候执行</span></div><div class="line">        <span class="comment">// 在MotionEvent.ACTION_MOVE 、MotionEvent.ACTION_UP 动作的时候不会执行以下代码</span></div><div class="line">        <span class="comment">//会从下面 第7步开始执行</span></div><div class="line">      <span class="comment">//if (mFirstTouchTarget == null) 行代码执行，而如果从ACTION_DOWN开始没有事件传</span></div><div class="line">      <span class="comment">//递到子 view ，那么if (mFirstTouchTarget == null) 条件就会成立，</span></div><div class="line">      <span class="comment">// 否则会执行 while (target != null) ， </span></div><div class="line">      <span class="comment">//直接遍历mFirstTouchTarget链表，查找之前接受ACTION_DOWN的子view，</span></div><div class="line">        <span class="comment">// 并将触摸事件分配给这些子 view 。也就是前面说的说，</span></div><div class="line">      <span class="comment">//如果ViewGroup的某个孩子没有接受ACTION_DOWN事件；</span></div><div class="line">        <span class="comment">// 那么，ACTION_MOVE和ACTION_UP等事件也一定不会分发给这个孩子！</span></div><div class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</div><div class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</div><div class="line">                    : TouchTarget.ALL_POINTER_IDS;</div><div class="line"></div><div class="line">            <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></div><div class="line">            <span class="comment">// have become out of sync.</span></div><div class="line">            removePointersFromTouchTargets(idBitsToAssign);</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</div><div class="line">            <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</div><div class="line">                <span class="comment">// Find a child that can receive the event.</span></div><div class="line">                <span class="comment">// Scan children from front to back.</span></div><div class="line">                <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></div><div class="line">                        &amp;&amp; isChildrenDrawingOrderEnabled();</div><div class="line">                   <span class="comment">// 获取该 ViewGroup 包含的子 View 和 ViewGroup </span></div><div class="line">                <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">                <span class="comment">// 第4步，遍历 ViewGroup的 孩子，对触摸事件进行分发。</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder</div><div class="line">                            ? getChildDrawingOrder(childrenCount, i) : i;</div><div class="line">                    <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</div><div class="line">                            ? children[childIndex] : preorderedList.get(childIndex);</div><div class="line">                    <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line">                        childWithAccessibilityFocus = <span class="keyword">null</span>;</div><div class="line">                        i = childrenCount - <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//判断子 View 是否可以接受事件</span></div><div class="line">                    <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</div><div class="line">                            || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</div><div class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// getTouchTarget() 的作用是查找 child 是否存在于</span></div><div class="line">                  <span class="comment">//mFirstTouchTarget 的单链表中。</span></div><div class="line">                    <span class="comment">// 是的话，返回对应的 TouchTarge t对象；跳出循环</span></div><div class="line">                    newTouchTarget = getTouchTarget(child);</div><div class="line">                    <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// Child is already receiving touch within its bounds.</span></div><div class="line">                        <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></div><div class="line">                        newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    resetCancelNextUpFlag(child);</div><div class="line">                    <span class="comment">// 第5步，真正开始执行事件分发</span></div><div class="line">                  <span class="comment">//调用 dispatchTransformedTouchEvent() 执行触摸事件分发给 child。</span></div><div class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">                        <span class="comment">// Child wants to receive touch within its bounds.</span></div><div class="line">                        mLastTouchDownTime = ev.getDownTime();</div><div class="line">                        <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</div><div class="line">                            <span class="comment">// childIndex points into presorted list, find original index</span></div><div class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</div><div class="line">                                <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                                    mLastTouchDownIndex = j;</div><div class="line">                                    <span class="keyword">break</span>;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            mLastTouchDownIndex = childIndex;</div><div class="line">                        &#125;</div><div class="line">                        mLastTouchDownX = ev.getX();</div><div class="line">                        mLastTouchDownY = ev.getY();</div><div class="line">                           </div><div class="line">                        <span class="comment">//第6步，如果事件分发成功  调用 addTouchTarget()</span></div><div class="line">                      <span class="comment">//将 child 添加到 mFirstTouchTarget 链表中，</span></div><div class="line">                        <span class="comment">// 并返回表头对应的 TouchTarge ,mFirstTouchTarget 将被负值</span></div><div class="line">                        newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                        <span class="comment">// 分发成功 设置 alreadyDispatchedToNewTouchTarget </span></div><div class="line">                      <span class="comment">//标记为 true 跳出循环</span></div><div class="line">                        alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">// The accessibility focus didn't handle the event, so clear</span></div><div class="line">                    <span class="comment">// the flag and do a normal dispatch to all children.</span></div><div class="line">                    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Did not find a child to receive the event.</span></div><div class="line">                <span class="comment">// Assign the pointer to the least recently added target.</span></div><div class="line">                newTouchTarget = mFirstTouchTarget;</div><div class="line">                <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</div><div class="line">                    newTouchTarget = newTouchTarget.next;</div><div class="line">                &#125;</div><div class="line">                newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 第7步，进一步的对触摸事件进行分发，如果mFirstTouchTarget为null，</span></div><div class="line">    <span class="comment">// 意味着还没有任何View来接受该触摸事件；</span></div><div class="line">    <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 调用 ViewGroup 的父类，即 view 的dispatchTouchEvent(MotionEvent ev)方法处理</span></div><div class="line">      <span class="comment">//处理方法就是我们上面分析的 view 对点击事件的分发流程</span></div><div class="line">        <span class="comment">// 并将分发结果的返回值赋值给 handler 进行返回</span></div><div class="line">        handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</div><div class="line">                TouchTarget.ALL_POINTER_IDS);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></div><div class="line">        <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></div><div class="line">        TouchTarget predecessor = <span class="keyword">null</span>;</div><div class="line">        TouchTarget target = mFirstTouchTarget;</div><div class="line">        <span class="comment">// 如果mFirstTouchTarget ！= null，则循环从链表 mFirstTouchTarget 中取出 target</span></div><div class="line">        <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> TouchTarget next = target.next;</div><div class="line">            <span class="comment">// 如果 alreadyDispatchedToNewTouchTarget 为 true</span></div><div class="line">            <span class="comment">// 并且target == newTouchTarget 即事件(ACTION_DOWN)已经分发成功设置 handled=true</span></div><div class="line">            <span class="comment">// 返回事件分发成功</span></div><div class="line">            <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</div><div class="line">                handled = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</div><div class="line">                        || intercepted;</div><div class="line">                <span class="comment">// 如果 alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget 条件</span></div><div class="line">                <span class="comment">//不成立，说明该事件还没有进行分发(ACTION_MOVE、ACTION_UP）</span></div><div class="line">              <span class="comment">//那么将此事件分发给之前已经成功接收事件的子</span></div><div class="line">                <span class="comment">// view ，即 target.child ，并将执行 handled = true 表示事件分发结果成功</span></div><div class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class="line">                        target.child, target.pointerIdBits)) &#123;</div><div class="line">                    handled = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                ..........</div><div class="line">                <span class="comment">//返回事件处理结果</span></div><div class="line">                <span class="keyword">return</span> handled;</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>事件分发主要分为以上几个步骤，代码中已经标出，下面加以总结：</p>
<p>在上面执行第2步的时候，ViewGroup 在两种情况下会判断是否拦截事件即 事件类型为 ACTION_DOWN 和 mFirstTouchTarget ！= null 条件下， ACTION_DOWN  好理解，那么 mFirstTouchTarget ！= null  是什么意思呢，我们看一下在执行第5步，事件由 ViewGroup 子 View 处理成功的时候有一行代码是：newTouchTarget = addTouchTarget(child, idBitsToAssign);这行代码实现方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</div><div class="line">    TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</div><div class="line">    target.next = mFirstTouchTarget;</div><div class="line">    mFirstTouchTarget = target;</div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面代码可以看出，事件由 ViewGroup 子 View 处理成功的时候 mFirstTouchTarget 将会被赋值，即事件分发到子 view 的时候mFirstTouchTarget ！= null，反过来如果事件由 ViewGroup 进行拦截，那么mFirstTouchTarget ！= null 就不成立，那么当 ACTION_MOVE 和 ACIONT_UP 事件到来的时候  if (actionMasked == MotionEvent.ACTION_DOWN    || mFirstTouchTarget != null) 条件为 false，将导致 ViewGroup 的 onInterceptTouchEvent(ev) 方法不再调用，同一系列事件中的其他事件将由 ViewGroup 进行处理。当然有一种特殊情况，就是 FLAG_DISALLOW_INTERCEPT 这个标记位，这个标记位是子 view 调用了 requestDisallowInterceptTouchEvent() 来进行设置，ViewGroup 将无法进行拦截除了 ACTION_DOWN 以外的其他事件，这是因为在进行 ACTION_DOWN 的时候，会重置 FLAG_DISALLOW_INTERCEPT  这个标记位，这样导致子 view 设置的 requestDisallowInterceptTouchEvent() 失效。</p>
<p>在看一下第5步，是如何调用 dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)  方法进行事件分发的，这行代码实现方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></div><div class="line">        View child, <span class="keyword">int</span> desiredPointerIdBits) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</div><div class="line"></div><div class="line">    <span class="comment">// Canceling motions is a special case.  We don't need to perform any transformations</span></div><div class="line">    <span class="comment">// or filtering.  The important part is the action, not the contents.</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</div><div class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</div><div class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</div><div class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            handled = child.dispatchTouchEvent(event);</div><div class="line">        &#125;</div><div class="line">        event.setAction(oldAction);</div><div class="line">        <span class="keyword">return</span> handled;</div><div class="line">    &#125;</div><div class="line">    .......</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们只看与我们要分析目标相关的代码，上面代码中我们看到，如果 child!=null ，那么执行 handled = child.dispatchTouchEvent(event) 之后的逻辑就是前面分析的 view 的事件分发，这样就完成了事件分发到子 view 的流程，我们看 child.dispatchTouchEvent(event) 是由返回值的，即如果返回 true ，事件由子 view 消费，事件分发成功，跳出第4步 for 循环，停止遍历子 view。</p>
<p>我们再看一下第7步，如果 mFirstTouchTarget == null ，说明没有任何子 view 接受触摸事件，那么调用 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS) 注意这里第三个参数传入 null，就是我们上面分析的另一种情况 ，如果 child == null ，执行 handled = super.dispatchTouchEvent(event) ，而 ViewGroup 的父类是 view ，所以之后的处理逻辑又和前面说的 view 一样了，即 ViewGroup 的 onTouch 方法会得到执行 ，而如果 mFirstTouchTarget ！= null ，表明已经有事件分发成功了，那么会执行  while (target != null) 循环从从链表 mFirstTouchTarget 中取出 target，条件 if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget)  如果成立，那么说明这个事件是是已经分发过成功的事件，那么直接执行 handled = true ，即让 dispatchTouchEvent 方法返回 true， 表明事件分发成功，而如果 if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget)  不成立，表明该事件是新到来的事件还没进行分发，那么执行 dispatchTransformedTouchEvent(ev, cancelChild,  target.child, target.pointerIdBits)) ，进一步对事件进行分发，并将 分发处理结果进行返回，这这情况下就是前面 第3步所说，不执行第三步，直接执行第7步对事件进一步就行分发。</p>
<p>最后说了这么多，大家可以结合下面这张流程图来对整理分发流程进行梳理，图片引自：</p>
<p><a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="external">图解 Android 事件分发机制</a>  </p>
<p><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/TouchEvent_disaptch.png?raw=true" alt="TouchEvent_disaptch"></p>
<p>其中 super 表示调用关系，true 表示消费事件， false 表示没有消费事件。</p>
<p>到这里关于 View 的事件分发分析就结束了！</p>
<p>如果感觉笔者写的不好，可以参考以下博客：</p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/9153747" target="_blank" rel="external">郭神的 Android事件分发机制完全解析，带你从源码的角度彻底理解(下)</a></p>
<p><a href="http://wangkuiwu.github.io/2015/01/04/TouchEvent-ViewGroup/" target="_blank" rel="external">skywangkw 的Android 触摸事件机制(四) ViewGroup中触摸事件详解</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/14/view_to_scroll/" itemprop="url">
                  Android 开发艺术探索第3章 3.2-3.3 View 滑动和弹性滑动读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-14T21:53:40+08:00" content="2016-08-14">
              2016-08-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-View-学习/" itemprop="url" rel="index">
                    <span itemprop="name">Android View 学习</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/14/view_to_scroll/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/14/view_to_scroll/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="3-2-View-的滑动"><a href="#3-2-View-的滑动" class="headerlink" title="3.2 View 的滑动"></a>3.2 View 的滑动</h2><p>3.1节中介绍了View的基础知识，有了这些基础知识和概念，我们就可以根据需要对 View 做一些操作，在Android设备上，最常见的一个操作就是滑动，如此可见滑动是很重要的知识，只有具备了滑动的基础知识才能做出更复杂炫酷的滑动效果，复杂的效果是由不同的滑动基础组成，通常View 的滑动可以由三种方式：使用scrollTo或scrollBy、通过动画给View 添加平移效果实现滑动、通过改变 View 的布局参数 LayoutParams 实现滑动，下面进行逐一分析。</p>
<h3 id="3-2-1-使用scrollTo或scrollBy进行滑动"><a href="#3-2-1-使用scrollTo或scrollBy进行滑动" class="headerlink" title="3.2.1 使用scrollTo或scrollBy进行滑动"></a>3.2.1 使用scrollTo或scrollBy进行滑动</h3><p>Android 中 View 为我们提供了两个专门的方法 scrollTo或scrollBy 来实现  View 的滑动，scrollTo 是滑动到某一坐标，是绝对滑动，View 调用的时候只能进行一次滑动，比如将 View 从 A 点滑动到 B 点；而scrollBy是滑动一段距离，是相对滑动，可以进行连续滑动，View 每次进行调用的时候都会将 View 滑动指定的距离。下面看一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * 绝对滑动</div><div class="line">  * <span class="doctag">@param</span> x 指定水平方向滑动像素</div><div class="line">  * <span class="doctag">@param</span> y 指定竖直方向滑动像素</div><div class="line">  */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">      <span class="comment">//位置发生了改变</span></div><div class="line">        <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</div><div class="line">            <span class="keyword">int</span> oldX = mScrollX;</div><div class="line">            <span class="keyword">int</span> oldY = mScrollY;</div><div class="line">            mScrollX = x;</div><div class="line">            mScrollY = y;d</div><div class="line">          <span class="comment">//使父视图清出子view，作用是重新创建显示的内容</span></div><div class="line">          <span class="comment">//主要应用场景是view 的渐变度改变，滑动，旋转等</span></div><div class="line">            invalidateParentCaches();</div><div class="line">          <span class="comment">//使View内容进行滑动</span></div><div class="line">            onScrollChanged(mScrollX, mScrollY, oldX, oldY);	</div><div class="line">          <span class="comment">//触发scrollbars进行绘制		              	      </span></div><div class="line">          <span class="comment">//如果正在动画播放完毕返回</span></div><div class="line">          <span class="comment">//ture 否则返回false</span></div><div class="line">            <span class="keyword">if</span> (!awakenScrollBars()) &#123;</div><div class="line">              <span class="comment">//在动画期间（下一个动画开始)，使view重新绘制</span></div><div class="line">                postInvalidateOnAnimation();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">  * 进行相对滑动</div><div class="line">  * <span class="doctag">@param</span> x  指定水平方向滑动像素</div><div class="line">  * <span class="doctag">@param</span> y 指定竖直方向滑动像素</div><div class="line">  */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        scrollTo(mScrollX + x, mScrollY + y);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过源码可以看出实际上scrollBy调用了scrollTo方法，实现了基于当前位置的相对滑动。其中 mScrollX 、mScrollY 这两个参数表示View内容的偏移量，单位为px，可以通过getScrollX 和 getScrollY 得到，mScrollX  是等于View的左边缘和View内容左边缘在水平方向的距离，并且当View内容左边缘在View左边缘的右侧的时候，mScrollX为负，反之为正,View边缘是指 View 的位置，由四个顶点组成，而 View内容边缘是指 View 的内容边缘；同理，mScrollY是等于View的上边缘和View内容上边缘在数值方向的距离，并且 View 内容上边缘在View上边缘下侧的时候，mScrollY为负，反之为正；scrollTo或scrollBy只能改变 View内容的位置不能改变View 在布局中的位置（即View的布局参数比如Top、Left、X、Y等不会改变），即不能改变 View 本身的位置，对于一个View来说，其本身是一个容器，而View内容是容器里面的东西，对于一个ViewGroup来说，那么它的内容是它的所有子View。</p>
<p>为了方便理解，下面用几幅图描述mScrollX、mScrollY和View内容的关系：</p>
<p><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/view_scroll.png?raw=true" alt="view_scroll"></p>
<h3 id="3-2-2-使用动画"><a href="#3-2-2-使用动画" class="headerlink" title="3.2.2 使用动画"></a>3.2.2 使用动画</h3><p>使用动画来移动view主要是操作view的translationX和translationY属性，既可以使用传统的view动画，也可以使用属性动画，使用后者需要考虑兼容性问题，如果要兼容Android 3.0以下版本系统的话推荐使用开元动画库<a href="http://nineoldandroids.com/" target="_blank" rel="external">nineoldandroids</a>。采用 View 动画 示例代码如下，此动画可以使 View在100ms内从原始位置向右下角移动100个像素。在项目的res目录中，创建一个名为anim的目录，创建动画资源文件 translation.xml 代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;set xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    android:fillAfter="true"&gt;</div><div class="line">    &lt;translate</div><div class="line">        android:duration="100"</div><div class="line">        android:fromXDelta="0"</div><div class="line">        android:fromYDelta="0"</div><div class="line">        android:toXDelta="100"</div><div class="line">        android:toYDelta="100" /&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure>
<p>java 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Animation animation = AnimationUtils.loadAnimation(<span class="keyword">this</span>,R.anim.translation);</div><div class="line"><span class="comment">//开始动画平移</span></div><div class="line">targetView.startAnimation(animation);</div></pre></td></tr></table></figure>
<p>注意，使用这种方式进行平移，View动画只是对View的影像做操作，它并不能真正改变View的位置参数，如果这个View设置了点击事件，点击动画后的新位置无法触发点击事件的，点击原来的位置可以出发事件，这这是因为View本身位置其实没有变化造成，解决方案是通过在目标位置创建一个一模一样的隐藏的view，设置同样的点击事件，当view移动到目标位置后，隐藏被移动的view，显示目标位置view，这样就可以达到点击效果。使用属性动画没有此问题，但3.0之前系统无属性动画，这个时候可以使用动画兼容库<a href="http://nineoldandroids.com/" target="_blank" rel="external">nineoldandroids</a>来实现属性动画，尽管如此，使用动画兼容库在3.0以后手机上实现属性动画本质上还是View动画。在100ms内将view向右平移100个像素代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, <span class="string">"translationX"</span>, <span class="number">0.0f</span>, <span class="number">100.0f</span>);</div><div class="line">animator.setDuration(<span class="number">100</span>).start();</div></pre></td></tr></table></figure>
<p>fFloat()方法的第一个参数表示动画操作的对象（可以是任意对象），第二个参数表示操作对象的属性名字（只要是对象有的属性都可以）,第三个参数之后就是动画过渡值。过度值可以有一个到N个，如果是一个值的话默认这个值是动画过渡值的结束值。如果有N个值，动画就在这N个值之间过渡。</p>
<h3 id="3-2-3-改变布局参数"><a href="#3-2-3-改变布局参数" class="headerlink" title="3.2.3 改变布局参数"></a>3.2.3 改变布局参数</h3><p>改变布局参数实现滑动，即改变LayoutParams,如想将一个View右平移100px，只需要将该View的LayoutParams里的marginLeft增加100px即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) view.getLayoutParams();  <span class="comment">//获取view的布局参数</span></div><div class="line">params.leftMargin += <span class="number">100</span>;     <span class="comment">//修改leftMargin的值，相当于xml布局文件中的margin_left的值</span></div><div class="line">view.setLayoutParams(params);  <span class="comment">//将新的params值设置进view</span></div><div class="line"><span class="comment">//或者调用   view.requestLayout();</span></div></pre></td></tr></table></figure>
<p>作者还提供了另一种思路是：可以在目标View 旁边放置一个宽度为0的view，当需要移动目标view 的时候，只需要给旁边的view设定需要移动的宽度即可，这样目标view自然就会被挤到目标位置。</p>
<p>针对以上三种view滑动总结如下：</p>
<ol>
<li>scrollTo/scrollBy:只适合对view的内容的滑动</li>
<li>属性动画：操作简单，功能强大，能实现复杂的动画效果，不建议用于有交互的View。</li>
<li>改变布局参数:适用于交互性强的View。</li>
</ol>
<p>根据以上三种滑动原理我们选择一种来实现一个可以在全屏进行滑动的view，实现原理是通过重写view 的TouchEvent方法，处理ACTION_MOVE方法，那么我们选择哪一种方式合适呢？第一种scrollBy方式，由于scrollBy是能实现view的内容滑动，而view本身没有滑动，所以所以不能满足需求，而属性动画和改变view布局方式，都可以满足，下面是选择较为简单方式，通过动画动画兼容库<a href="http://nineoldandroids.com/" target="_blank" rel="external">nineoldandroids</a>方式实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestButton</span> <span class="keyword">extends</span> <span class="title">TextView</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"TestButton"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mScaledTouchSlop;</div><div class="line"><span class="comment">// 分别记录上次滑动的坐标</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mLastX = <span class="number">0</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mLastY = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestButton</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestButton</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(context, attrs);</div><div class="line">    init();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestButton</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">    init();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">    mScaledTouchSlop = ViewConfiguration.get(getContext())</div><div class="line">            .getScaledTouchSlop();</div><div class="line">    Log.d(TAG, <span class="string">"sts:"</span> + mScaledTouchSlop);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressLint</span>(<span class="string">"ClickableViewAccessibility"</span>)</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">  <span class="comment">//获取当前点击事件在屏幕中的坐标，注意：不是相对view本身坐标，不能用getX 和getY</span></div><div class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getRawX();</div><div class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getRawY();</div><div class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">        <span class="comment">//按下手势，无需处理</span></div><div class="line">    <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">        <span class="comment">//在此处理滑动事件</span></div><div class="line">    <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</div><div class="line">      <span class="comment">//计算滑动距离</span></div><div class="line">        <span class="keyword">int</span> deltaX = x - mLastX;</div><div class="line">        <span class="keyword">int</span> deltaY = y - mLastY;</div><div class="line">        Log.d(TAG, <span class="string">"move, deltaX:"</span> + deltaX + <span class="string">" deltaY:"</span> + deltaY);</div><div class="line">      <span class="comment">//就算偏移距离</span></div><div class="line">        <span class="keyword">int</span> translationX = (<span class="keyword">int</span>)ViewHelper.getTranslationX(<span class="keyword">this</span>) + deltaX;</div><div class="line">        <span class="keyword">int</span> translationY = (<span class="keyword">int</span>)ViewHelper.getTranslationY(<span class="keyword">this</span>) + deltaY;</div><div class="line">      <span class="comment">//进行滑动</span></div><div class="line">        ViewHelper.setTranslationX(<span class="keyword">this</span>, translationX);</div><div class="line">        ViewHelper.setTranslationY(<span class="keyword">this</span>, translationY);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">        <span class="comment">//抬起手势无需处理</span></div><div class="line">    <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//记录滑动后坐标</span></div><div class="line">    mLastX = x;</div><div class="line">    mLastY = y;</div><div class="line">  <span class="comment">//事件消费，返回false，无法滑动，后面会讲到view的事件分发机制有关。</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-3-弹性滑动"><a href="#3-3-弹性滑动" class="headerlink" title="3.3 弹性滑动"></a>3.3 弹性滑动</h2><p>实现弹性滑动的原理是：将一次大的滑动分成若干次小的滑动，并在一个时间段内完成。可以通过scroller、Handler#postDelayed 以及Thread#Sleep来完成，下面逐一介绍。</p>
<h3 id="3-3-1-使用Scroller"><a href="#3-3-1-使用Scroller" class="headerlink" title="3.3.1 使用Scroller"></a>3.3.1 使用Scroller</h3><p>在3.1.4章节介绍过通过Scroller实现滑动的典型代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Scroller mScroller = <span class="keyword">new</span> Scroller(mContext);</div><div class="line"><span class="comment">// 缓慢滚动到指定的位置  </span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX, <span class="keyword">int</span> destY)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> scrollX = getScrollX();</div><div class="line">    <span class="keyword">int</span> deltaX = destX - scrollX;</div><div class="line">    <span class="comment">// 以 1000ms 内滑向 destX， 效果是慢慢滑动  </span></div><div class="line">    mScroller.startScroll(scrollX, destY, deltaX , <span class="number">0</span>, <span class="number">1000</span>);</div><div class="line">    <span class="comment">// View 的重绘  </span></div><div class="line">    invalidate();</div><div class="line">&#125;</div><div class="line">  <span class="comment">// 重写 computeScroll 方法，并在内部完成平滑滚动的逻辑  </span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">//判断view是在指定时间内是否完成滑动</span></div><div class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset())&#123;</div><div class="line">      <span class="comment">//通过mScroller获取当前位置，实现滑动</span></div><div class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</div><div class="line">        <span class="comment">// 再次进行重绘  </span></div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面分析一下Scroller是如何实现弹性滑动的，上面代码我们调用了mScroller.startScroll(scrollX, destY, deltaX , 0, 1000);方法，下面一起来看一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> startX 水平方向开始滑动像素. 正值代表内容向左滑动.</div><div class="line"> * <span class="doctag">@param</span> startY 竖直方向开始滑动像素. 正值代表内容向上滑动</div><div class="line"> * <span class="doctag">@param</span> dx 水平方向滑动距离. 正值代表内容向左滑动</div><div class="line"> * <span class="doctag">@param</span> dy 竖直方向滑动距离，正值代表向上滑动</div><div class="line"> * <span class="doctag">@param</span> duration 滑动时间.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span> </span>&#123;</div><div class="line">    mMode = SCROLL_MODE;</div><div class="line">  <span class="comment">//滑动是否完成标志</span></div><div class="line">    mFinished = <span class="keyword">false</span>;</div><div class="line">  <span class="comment">//滑动时间</span></div><div class="line">    mDuration = duration;</div><div class="line">  <span class="comment">//获取当前时间</span></div><div class="line">    mStartTime = AnimationUtils.currentAnimationTimeMillis();</div><div class="line">  <span class="comment">//水平方向滑动起点</span></div><div class="line">    mStartX = startX;</div><div class="line">  <span class="comment">//竖直方向滑动起点</span></div><div class="line">    mStartY = startY;</div><div class="line">  <span class="comment">//滑动终点</span></div><div class="line">    mFinalX = startX + dx;</div><div class="line">    mFinalY = startY + dy;</div><div class="line">  <span class="comment">//水平方向要滑动距离</span></div><div class="line">    mDeltaX = dx;</div><div class="line">  <span class="comment">//竖直方向要滑动距离</span></div><div class="line">    mDeltaY = dy;</div><div class="line">  <span class="comment">//滑动时间的倒数</span></div><div class="line">    mDurationReciprocal = <span class="number">1.0f</span> / (<span class="keyword">float</span>) mDuration;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意以上滑动是实现view的内容滑动，而且可以看到startScroll方法竟然没有做任何滑动的事情，只是将要进行滑动的参数传递进来并进行了保存，因此仅仅调用startScroll方法是无法实现滑动的，而正在使view 进行滑动的关键代码是invalidate()，为什么呢？因为调用invalidate()方法后会使 view进行重新绘制，这样就会调用view的 draw 方法，view 的draw方法又会去调用computeScroll() 方法，computeScroll方法在view 内部是一个空方法，需要我们自己去实现，上面典型代码中我们调用scrollTo方法，因此实现了view 的滑动，接着又调用postInvalidate（）方法，使view进行第二次重新绘制，这样绘制过程又和第一次一样重新走一遍，这样反复调用就完成了view 的滑动；那么什么时候完成停止绘制呢?判断条件就是mScroller.computeScrollOffset()，这个方法会根据时间的流逝计算当前Scrollx和ScrollYD 值，返回ture表示滑动未结束。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">computeScrollOffset</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mFinished) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> timePassed = (<span class="keyword">int</span>)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);</div><div class="line">    <span class="keyword">if</span> (timePassed &lt; mDuration) &#123;</div><div class="line">        <span class="keyword">switch</span> (mMode) &#123;</div><div class="line">        <span class="keyword">case</span> SCROLL_MODE:</div><div class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</div><div class="line">            mCurrX = mStartX + Math.round(x * mDeltaX);</div><div class="line">            mCurrY = mStartY + Math.round(x * mDeltaY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">           ......</div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        mCurrX = mFinalX;</div><div class="line">        mCurrY = mFinalY;</div><div class="line">        mFinished = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结： Scroller 本身不能实现 View 的滑动，它需要配合 View 的 computeScroll 方法才能完成弹性滑动的效果。通过不断地让 View 重绘，而每一次重绘距离滑动其实起始时间会有一个时间间隔，通过这个时间间隔 Scroller 得出 View 当前的滑动位置，知道了滑动位置就可以通过 scrollTo 方法完成 View 的滑动。 View 的每一次重绘都会导致 View 的小幅度滑动，而多次的小幅度滑动组成了弹性滑动，这就是 Scroller 滑动的工作机制。</p>
<h3 id="3-3-2-通过动画"><a href="#3-3-2-通过动画" class="headerlink" title="3.3.2 通过动画"></a>3.3.2 通过动画</h3><p>动画本身就是一个循序渐进的过程，因此使用动画进行滑动自然就具有弹性效果，比如以下代码就可以让一个View 在100ms内向右移动100像素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, <span class="string">"translationX"</span>, <span class="number">0.0f</span>, <span class="number">100.0f</span>);</div><div class="line">animator.setDuration(<span class="number">100</span>).start();</div></pre></td></tr></table></figure>
<p>这里我们是直接使用属性动画作用于 view 使其进行滑动，很简单，下面要作者提供了一个有意思的思路实现同样的效果，就是利用属性动画的特性结合ScrollTo 方法实现 Scroller 弹性滑动效果，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scroller</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="comment">//动画起始位置</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> startX = <span class="number">0</span>;</div><div class="line">  <span class="comment">//动画要滑动的距离</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> deltax = <span class="number">1000</span>;</div><div class="line">    <span class="keyword">final</span> ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">1</span>).setDuration(<span class="number">2000</span>);</div><div class="line">  <span class="comment">//动画添加监听器</span></div><div class="line">    animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">          <span class="comment">//获取动画完成比例值</span></div><div class="line">            <span class="keyword">float</span> fraction = animator.getAnimatedFraction();</div><div class="line">          <span class="comment">//根据比例值对目标view进行滑动</span></div><div class="line">            targetView.scrollTo(startX +(<span class="keyword">int</span>)(deltax * fraction), <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">  <span class="comment">//开始执行</span></div><div class="line">    animator.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码属性动画animator 对象没有作用于任何 view 对象上，它的作用只是在2000ms内完成整个动画的过程，利用这个特性就可以在动画每一帧到来时获取动画完成比例，然后再根据这个比例计算出当前 view 所要滑动的距离，注意由于这里是使用的scrollTo() 方法，所以实质滑动的是 view 的内容。这个方法实现的思路其实和 Scroller 比较类似，都是通过计算 改变一个百分比配合 Scroller 实现 view 滑动，但是这个方法中我们还可以在onAnimationUpdate方法中添加一些我们想要实现的操作，使用更加灵活。</p>
<h3 id="3-3-3-使用延时策略"><a href="#3-3-3-使用延时策略" class="headerlink" title="3.3.3 使用延时策略"></a>3.3.3 使用延时策略</h3><p>延时策略的思想是通过发送一系列的消息从而达到一种渐进式的效果，具体来说就是使用 Handler 或 View 的 postDelayed 方法，也可以使用线程的 sleep 方法。对于postDelayed 来说可以发送一个延时消息，然后在消息中对 view 进行滑动，连续不断的发送消息，就可以对 view 实现弹性滑动。对于sleep 来说，可以通过在while 循环中不断的对 view 进行滑动和 sleep，这样把整个滑动过程切成无数个小的滑动操作达到弹性滑动的效果。</p>
<p>采用Handler大约在1000ms内将 view 向左滑动100像素，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_SCROLL_TO = <span class="number">1</span>;</div><div class="line"><span class="comment">//发送消息次数，即要滑动次数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRAME_COUNT = <span class="number">30</span>;</div><div class="line"><span class="comment">//延时时间</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAYED_TIME = <span class="number">33</span>;</div><div class="line"><span class="comment">//从0次开始</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span>  mCount = <span class="number">0</span>;</div><div class="line"><span class="meta">@SuppressLint</span>(<span class="string">"HandlerLeak"</span>)</div><div class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_SCROLL_TO:</div><div class="line">            mCount++;</div><div class="line">            <span class="keyword">if</span>(mCount &lt;= FRAME_COUNT) &#123;</div><div class="line">              <span class="comment">//计算滑动百分比</span></div><div class="line">                <span class="keyword">float</span> fraction = mCount / (<span class="keyword">float</span>) FRAME_COUNT;</div><div class="line">              <span class="comment">//计算每次要滑动距离</span></div><div class="line">                <span class="keyword">int</span> scrollX = (<span class="keyword">int</span>) (fraction * <span class="number">100</span>);</div><div class="line">              <span class="comment">//开始滑动</span></div><div class="line">                view.scrollTo(scrollX, <span class="number">0</span>);</div><div class="line">              <span class="comment">//循环发送消息实现滑动</span></div><div class="line">                mHandler.sendEmptyMessageDelayed(MESSAGE_SCROLL_TO,DELAYED_TIME);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以上是关于 view 滑动的基础知识基本讲解完毕！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/10/yongyu_20160810_View3.1 basic_knowledge/" itemprop="url">
                  Android 开发艺术探索第3章 3.1View 基础知识读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-10T23:53:03+08:00" content="2016-08-10">
              2016-08-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-View/" itemprop="url" rel="index">
                    <span itemprop="name">Android View</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/10/yongyu_20160810_View3.1 basic_knowledge/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/10/yongyu_20160810_View3.1 basic_knowledge/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载请附原文链接：<a href="http://yongyu.itscoder.com/2016/08/10/yongyu_20160810_View3.1%20basic_knowledge/" target="_blank" rel="external">Android 开发艺术探索第3章 3.1View 基础知识读书笔记</a> </p>
<h1 id="3-1-View-基础知识"><a href="#3-1-View-基础知识" class="headerlink" title="3.1 View 基础知识"></a>3.1 View 基础知识</h1><p>主要介绍内容：View 的位置参数、MotionEvent 和 TouchSlop对象、VelocityTracker, GestureDetector 和 Scroller对象。</p>
<h2 id="3-11-什么是-View"><a href="#3-11-什么是-View" class="headerlink" title="3.11 什么是 View"></a>3.11 什么是 View</h2><p>View 是Android中所有控件的基类，例如Button和TextView、ViewGroup 等常见控件他们的基类都是View，View是一种界面层的控件的一种抽象，代表了一个控件。View 本身可以是单个控件也可以是由多个控件组成的一组控件，通过这种关系就形成了View 树的结构，与Web前端中的DOM树概念相似。</p>
<h2 id="3-1-2-View的位置参数"><a href="#3-1-2-View的位置参数" class="headerlink" title="3.1.2 View的位置参数"></a>3.1.2 View的位置参数</h2><p>View 的位置主要有四个顶点决定的， top（左上角纵坐标）、left（左上角横坐标）、right（右下角横坐标）、bottom（右下角纵坐标），这些顶点的坐标是相对于 View 的父容器来说，是一种相对坐标。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/View_%20XYZ.png?raw=true" alt="View_ XYZ"></h2><p>根据上图View的坐标位置关系可以得出以下view的宽度（width)和高度（height)：</p>
<p>View的宽高和坐标关系：width = right - left，height = top - bottom。</p>
<p>view 源码中他们对应于mLeft、mRight、mTop、mBottom这四个成员变量，获取方式如下：</p>
<p>Left=getLeft() 、Right=getRight() 、Top=getTop() 、Bottom=getBottom() </p>
<p>从Android 3.0开始，view增加了：x、y、translationX、translationY 四个参数，这几个参数也是相对于父容器的坐标。x和y是左上角的坐标（偏移前或者偏移后左上角坐标，即当前坐标），而translationX和translationY是view左上角相对于父容器的偏移量(偏移坐标），默认值都是0。View 也提供了相应的方法，通过这几个坐标可以得到如下换算关系：</p>
<p>x = left + translationX  其中：x为左上角偏移后当前横坐标，left为view原始位置横坐标即可以通过getLeft（）获取，translationX  为view相对于父容器偏移横坐标。</p>
<p>y = top + translationY  其中y为左上角偏移后当前纵坐标，left为view原始位置纵坐标可以通过getTop（）获取，translationY 为view相对于父容器偏移纵坐标。</p>
<p>注意：在 View 平移的过程中， top 和 left 表示的是原始左上角的位置信息， 其值并不会发生变化， 改变的是 x, y, traslationX 和 translation Y 。</p>
<h2 id="3-1-3-MotionEvent-和-TouchSlop"><a href="#3-1-3-MotionEvent-和-TouchSlop" class="headerlink" title="3.1.3 MotionEvent 和 TouchSlop"></a>3.1.3 MotionEvent 和 TouchSlop</h2><ol>
<li>MotionEvent 是指用户手指触摸屏幕产生的一系列事件 分为  ACTION_DOWN（手指刚接触屏幕）, ACTION_MOVE（手指在屏幕上滑动）, ACTION_UP（手指从屏幕上松开瞬间）。</li>
<li>点击屏幕后松开，事件序列 DOWN-&gt;UP点击屏幕滑动一会再松开，事件序列为 DOWN-&gt;MOVE-&gt;…-&gt;MOVE-&gt;UP。</li>
<li>getX/getY获取相对当前View左上角的x和y坐标；getRawX/getRawY获取相对手机屏幕左上角的x和y坐标。</li>
<li>TouchSlop 是系统能识别滑动的最小距离，是系统常量，与设备有关，不同设备，值可能不同，当手指在屏幕上滑动，小于这个距离，系统不认为你在进行滑动操作；可通过ViewConfiguration.get（getContext()).getScaledTouchSlop()方法来获取;可以利用此参数进行一些滑动过滤，当未达到此值的时候可以认为未达到滑距离的临界值。 </li>
</ol>
<h2 id="3-1-4-VelocityTracker-、GestureDetector-和Scroller"><a href="#3-1-4-VelocityTracker-、GestureDetector-和Scroller" class="headerlink" title="3.1.4 VelocityTracker  、GestureDetector 和Scroller"></a>3.1.4 VelocityTracker  、GestureDetector 和Scroller</h2><ol>
<li><p>VelocityTracker 用于追踪手指在滑动过程中的速度。如在View的onTouchEvent方法中追踪当前单击事件的速度方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取VelocityTracker对象</span></div><div class="line">VelocityTracker velocityTracker = VelocityTracker.obtain(); </div><div class="line"><span class="comment">//将事件event添加进去</span></div><div class="line">velocityTracker.addMovement(event); </div><div class="line"><span class="comment">//获取当前滑动速度计算方法</span></div><div class="line"><span class="comment">//这里的速度是指一段时间内手指滑动过的像素数</span></div><div class="line"><span class="comment">//获取速度前需输入计算速度参数时间间隔单位ms，即计算在1000ms内手指滑动过的像素数</span></div><div class="line">velocityTracker.computeCurrentVelocity(<span class="number">1000</span>);  </div><div class="line"><span class="comment">//获取x轴速度</span></div><div class="line"><span class="keyword">int</span> xVelocity = (<span class="keyword">int</span>)velocityTracker.getXVelocity(); </div><div class="line"><span class="comment">//获取y轴速度</span></div><div class="line"><span class="keyword">int</span> yVelocity = (<span class="keyword">int</span>)velocityTracker.getYVelocity();</div></pre></td></tr></table></figure>
<p>注意：这里的速度可以为负数，手指从右向左滑动，水平方向速度即为负数，计算公式为：</p>
<p>速度 = （终点位置 - 起点位置）/ 时间段</p>
<p>计算得到的速度即为在给定时间间隔内水平方向或者竖直方向所滑动的像素数。</p>
<p>最后如果不在使用，需要调用clear进行清除和回收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重置和回收</span></div><div class="line">mVelocityTracker.clear(); <span class="comment">//一般在MotionEvent.ACTION_UP的时候调用</span></div><div class="line">mVelocityTracker.recycle(); <span class="comment">//一般在onDetachedFromWindow中调用</span></div></pre></td></tr></table></figure>
</li>
<li><p>GestureDetector</p>
<p>用于辅助检测用户的单击、滑动、长按、双击等行为；下面笔者写一个小的demo如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GestureActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span>  <span class="keyword">implements</span> <span class="title">GestureDetector</span>.<span class="title">OnGestureListener</span>,<span class="title">GestureDetector</span>.<span class="title">OnDoubleTapListener</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG =<span class="string">"GestureActivity"</span> ;</div><div class="line">    <span class="keyword">private</span> GestureDetector gestureDetector;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="comment">//创建GestureDetector对象,并设置OnGestureListener监听</span></div><div class="line">        <span class="comment">//第一个this参数为context，第二个参数为OnGestureListener</span></div><div class="line">        gestureDetector =<span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>,<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//设置双击监听</span></div><div class="line">        gestureDetector.setOnDoubleTapListener(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//解决长按屏幕无法拖拽的现象</span></div><div class="line">        gestureDetector.setIsLongpressEnabled(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//重写Activity 的onTouchEvent将MotionEvent事件设置给gestureDetector</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="comment">//接管目标 View 的 onTouchEvent 方法</span></div><div class="line">        gestureDetector.onTouchEvent(event);</div><div class="line">        <span class="comment">//返回事件处理结果</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDown</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指轻轻触摸屏幕的瞬间，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onDown"</span>+e.toString());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShowPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指轻触屏幕，尚未松开或者拖动，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onShowPress"</span>+e.toString());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指松开，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onSingleTapUp"</span>+e.toString());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指按下屏幕并拖动，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onScroll"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//手指长按，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onLongPress"</span>+e.toString());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</div><div class="line">        <span class="comment">// 用户按下触摸屏，快速移动后松开，根据需要处理相应事件</span></div><div class="line">        Log.d(TAG,<span class="string">"onFling"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapConfirmed</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//单击行为；根据需要处理事件</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDoubleTap</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">//表示双击行为，在双击的期间,根据需要处理事件</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDoubleTapEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">       <span class="comment">// 双击，由两次连续的单击组成，根据需要处理事件</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本例子中是将手势监听设置给了整个Activity，你也可以根据实际需求设置给某个view，同样是在onTouchEvent方法中设置。</p>
<p><strong>OnGestureListener 接口的方法</strong></p>
<p>onDown : 手指轻轻触摸屏幕的瞬间，由一个 ACTION_DOWN 触发；</p>
<p>onShowPress : 手指轻触屏幕，尚未松开或者拖动， 由一个 ACTION_DOWN 触发；</p>
<p>onSingTapUp : 手指松开，由 ACTION_DOWN 触发， 这是单击行为；</p>
<p>onScroll: 手指按下屏幕并拖动，由一个 ACTION_DOWN , 多个 ACTION_MOVE 触发， 这是拖动行为；</p>
<p>onLongPress: 用户长久地按着屏幕不放，即长按；</p>
<p>onFling: 用户按下触摸屏，快速移动后松开，由一个 ACTION_DWON、多个 ACTION_MOVE 和一个 ACTION_UP 触发，快速滑动行为；</p>
<p><strong>OnDoubleTapListener 接口中的方法</strong></p>
<p>onDoubleTap: 双击，由两次连续的单击组成，不能和 onSingleTapConfirmed 共存；</p>
<p>onSingleTapConfirmed: 单击行为；</p>
<p>onDoubleEvent: 表示双击行为，在双击的期间， ACTION_DOWN、ACTION_MOVE、ACTION_UP 都不会触发此回调。</p>
<p>在实际开发中可以不使用 GestureDetector ，完全可以在View的 onTouchEvent 方法中根据MotionEvent类型以及滑动速度等条件实现所需的监听，作者建议：如果只是监听滑动相关的推荐在onTouchEvent中实现，如果需要监听双击，使用GeststureDetector。</p>
</li>
<li><p>Scroller</p>
<p>用来实现View的弹性滑动，View的scrollTo/scrollBy是瞬间完成的，Scroller本身并不能实现view的滑动，使用Scroller配合View的computeScroll方法配合使用达到弹性滑动的效果，它不断地让view重绘，而每一次重绘距滑动起始时间会有一个时间间隔，通过这个时间间隔Scroller就可以得出view的当前的滑动位置，知道了滑动位置就可以通过scrollTo方法来完成view的滑动。就这样，view的每一次重绘都会导致view进行小幅度的滑动，而多次的小幅度滑动就组成了弹性滑动，这就是Scroller的工作原理，下面3.2节会详细介绍，典型固定代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Scroller mScroller = <span class="keyword">new</span> Scroller(mContext);</div><div class="line"><span class="comment">// 缓慢滚动到指定的位置  </span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX, <span class="keyword">int</span> destY)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> scrollX = getScrollX();</div><div class="line">    <span class="keyword">int</span> deltaX = destX - scrollX;</div><div class="line">    <span class="comment">// 以 1000ms 内滑向 destX， 效果是慢慢滑动  </span></div><div class="line">    mScroller.startScroll(scrollX, destY, deltaX , <span class="number">0</span>, <span class="number">1000</span>);</div><div class="line">    <span class="comment">// View 的重绘  </span></div><div class="line">    invalidate();</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 重写 computeScroll 方法，并在内部完成平滑滚动的逻辑  </span></div><div class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset())&#123;</div><div class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</div><div class="line">        <span class="comment">// 再次进行重绘  </span></div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此关于View的基础知识基本结束，如有笔误，或者理解错误的地方，望多多指导！！</p>
<p>​</p>
<p>​</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/07/yongyu_20160803_volley_use_and_source_code_study/" itemprop="url">
                  Volley学习笔记之简单使用及部分源码详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-07T22:49:40+08:00" content="2016-08-07">
              2016-08-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android源码学习/" itemprop="url" rel="index">
                    <span itemprop="name">Android源码学习</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/07/yongyu_20160803_volley_use_and_source_code_study/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/07/yongyu_20160803_volley_use_and_source_code_study/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载请附原文链接：<a href="http://yongyu.itscoder.com/2016/08/07/yongyu_20160803_volley_use_and_source_code_study/" target="_blank" rel="external">Volley学习笔记之简单使用及部分源码详解</a> </p>
<h2 id="一、使用背景简介"><a href="#一、使用背景简介" class="headerlink" title="一、使用背景简介"></a>一、使用背景简介</h2><p>现在大多数手机 App 几乎都离不开网络技术，需要手机端与网络服务端进行数据交互，Android 系统中主要提供了两种方式来进行HTTP通信，HttpURLConnection 和 HttpClient，在初学 Android 的时候，这两个类是我们最开始学着使用的，但是在使用过程中需要调取各种API，进行封，然后请求到的结果需要自己去解析，最后再将解析到的数据进行封装存到数据库，整个过程，相当复杂，而且重复性很高，于是针对这种情况，网络上就有大神封装了各种第三方框架供我们使用，将这些复杂冗余操作进行组合优化，使得整个编写过程得以简化，只需简单配置几行代码就可以完成整个流程操作。今天我们介绍的 Volley  就是其中一个优秀第三方框架。笔者所在公司目前项目使用的就是Volley ，所以在使用的同时决定写一系列笔记分析，从学会简单使用，到最后的 Volley 源码分析一系列循序渐进的流程来理解Volley的实现原理。</p>
<h2 id="二、Volley简介"><a href="#二、Volley简介" class="headerlink" title="二、Volley简介"></a>二、Volley简介</h2><p>Volley 是 Google在 Google I/O 2013 大会上 推出的 Android 异步网络请求和图片加载框架。</p>
<ul>
<li><p>主要作用 ：实现异步网络请求、图片加载。</p>
</li>
<li><p>主要特点：</p>
<p>(1).  Volley基于接口设计，扩展性强，我们可以根据我们的需求定制自己想要的请求方式方法。<br>(2).  一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。<br>(3).  默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现。</p>
<p>(4). 支持指定请求的优先级。</p>
<p>(5). 高并发网络连接。</p>
</li>
<li><p>使用下载地址：<a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="external">https://android.googlesource.com/platform/frameworks/volley</a></p>
<p>可以使用git 下载命令 git clone  <a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="external">https://android.googlesource.com/platform/frameworks/volley</a></p>
<ul>
<li>编译jar：<br><code>android update project -p . ant jar</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>添加volley.jar到你的项目中</p>
<p>  <strong>不过已经有人将volley的代码放到github上了：</strong><br>  <a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="external">https://github.com/mcxiaoke/android-volley</a>，你可以使用更加简单的方式来使用volley</p>
</li>
</ul>
<h2 id="三、简单使用"><a href="#三、简单使用" class="headerlink" title="三、简单使用"></a>三、简单使用</h2><p>使用Volley框架实现网络数据请求主要有以下三个步骤：</p>
<ol>
<li>创建RequestQueue对象，定义网络请求队列，RequestQueue内部的设计就是非常合适高并发的，因此我们不必为每一次HTTP请求都创建一个RequestQueue对象，避免非常浪费资源的，一般全局使用一个就可以。</li>
<li>创建XXXRequest对象(XXXRequest对象可以自己继承Request类进行封装定义，也可以使用Volley已经为我们提供的的StringReqeust、JsonArrayRequest、JsonObjectRequest)，这个类主要是功能是传入请求网址、解析返回数据、回调监听返回数据等功能的实现，也是我们经常继承包装的类，在这里可以实现我们想要的返回数据类型。</li>
<li>把XXXRequest对象添加到RequestQueue中，开始执行网络请求。</li>
</ol>
<p>怎么样，这样看来整个网络请求是否是变得便捷，不需要你去考虑，如何调取Http请求各种API，不需要考虑异步等问题，Volley已经帮助我们完成，下面简单以StringReqeust为例子发起一个Get请求，编写一个小的Demo用例，结合代码，加深理解：</p>
<p>网络请求队列一般都是整个APP内使用的全局性对象，因此最好写入Application类中，全局只使用一个，避免浪费资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"><span class="comment">// 建立请求队列</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue queue;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    queue = Volley.newRequestQueue(getApplicationContext());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">getVolleyRequestQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> queue;</div><div class="line"> &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们还需要修改AndroidManifest.xml文件，使APP的Application对象为我们刚定义的MyApplication，并添加INTERNET权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</div><div class="line"></div><div class="line">&lt;application</div><div class="line"></div><div class="line">    android:name=&quot;.MyApplication&quot;</div><div class="line"></div><div class="line">    android:allowBackup=&quot;true&quot;</div><div class="line"></div><div class="line">    android:icon=&quot;@mipmap/ic_launcher&quot;</div><div class="line"></div><div class="line">    android:label=&quot;@string/app_name&quot;</div><div class="line"></div><div class="line">    android:supportsRtl=&quot;true&quot;</div><div class="line"></div><div class="line">    android:theme=&quot;@style/AppTheme&quot; &gt;</div><div class="line"></div><div class="line">&lt;/application&gt;</div></pre></td></tr></table></figure>
<p>创建StringReqeust对象，并将其添加到RequestQueue中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Request.Method.GET 指定请求方法，如果不输入，默认为Get方法</div><div class="line">  *  new Response.Listener &lt;String&gt; 请求成功回调接口</div><div class="line">  *   new Response.ErrorListener() 请求失败回到接口</div><div class="line">  * <span class="doctag">@param</span> url 要请求的网址</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">     StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Request.Method.GET,url, <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</div><div class="line">             <span class="comment">//这里得到我们请求成功的结果</span></div><div class="line">             Log.d(<span class="string">"TAG"</span>, response);</div><div class="line">         &#125;</div><div class="line">     &#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</div><div class="line">             <span class="comment">//这里得到我们请求请求失败的信息</span></div><div class="line">             Log.e(<span class="string">"TAG"</span>, error.getMessage());</div><div class="line">         &#125;</div><div class="line">     &#125;);</div><div class="line">     <span class="comment">//将stringRequest添加到RequestQueue中</span></div><div class="line">     MyApplication.getVolleyRequestQueue().add(stringRequest);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>好了，这样我们就完成完成了StringRequest请求操作，在onResponse方法内得到我们想要的请求结果String 类型数据。</p>
<h2 id="四、使用思考"><a href="#四、使用思考" class="headerlink" title="四、使用思考"></a>四、使用思考</h2><p>在上面使用StringRequest请求过程中，我们只需要简单三步就完成了整个请求，那么有没有想过，Volley内部是如何实现的呢，思考以下几个问题：</p>
<ol>
<li>如何实现高并发请求</li>
<li>如何实现异步请求</li>
<li>如何实现数据缓存</li>
<li>内部是如何各种继承，组合封装最后几行代码就可以实现请求功能，但是使用拓展性又那么强。</li>
</ol>
<p>相信不想只做代码搬运工的你在使用过程中也会有这些甚至更多疑问，笔者在使用过程中一直好奇这些，否则在项目中只是简单调用人家已经封装好的几行代码，总感觉自己是一个搬运工，不知其所以然，所以现在决定，静下心来，去尝试分析一下Volley源码，以此记录分享。</p>
<h2 id="五、源码分析"><a href="#五、源码分析" class="headerlink" title="五、源码分析"></a>五、源码分析</h2><p>首先我们来看看Volley官方给出的一张Volley工作流程图 </p>
<p><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/operating_principle.png?raw=true" alt="“Volley工作原理如”"></p>
<p>下面将这张图翻译如下：</p>
<p><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/operating%20principle-cn.png?raw=true" alt="“Volley工作原理如”"></p>
<p>通过上面这张图我们可以对Volley工作流程有一个大概的印象，下面我们根据这张流程图以及Volley使用过程来结源码进行分析：</p>
<p>首先从我们使用的入口Volley.newRequestQueue(context)方法来来作为我们分析的切入点，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用volley的入口，一般默认调用这个方法即可创建一个默认的网络请求列队，启动一个请求队列RequestQueue，</div><div class="line"> * 只需要往这个RequestQueue不断 add Request 即可发起请求</div><div class="line"> * <span class="doctag">@param</span> context用于创建缓存文件夹</div><div class="line"> * <span class="doctag">@return</span> 返回 instance.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法仅仅只有一行代码，只是调用了newRequestQueue()的方法重载，并给第二个参数传入null。那我们接着分析带有两个参数的newRequestQueue()方法中的代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> context A 用于创建缓存文件夹</div><div class="line"> * <span class="doctag">@param</span> stack HttpStack处理http网络请求包装，可以自己定义，如果传入null，</div><div class="line"> *那么就使用系统默认的HttpStack</div><div class="line"> * <span class="doctag">@return</span> A 返回 instance.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">return</span> newRequestQueue(context, stack, -<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法也很简单，直接调用了含三个参数的构造方法，那么我们接着看看含三个参数的构造方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> context A 用于创建缓存文件夹</div><div class="line">     * <span class="doctag">@param</span> stack HttpStack处理http网络请求包装，内部就是我		</div><div class="line">     *们使用过的HttpURLConnection或者HttpClient，进行包装处</div><div class="line">     *理，可以自己定义，也可以传入null，那么就使用系统默认的HttpStack</div><div class="line">     * <span class="doctag">@param</span> maxDiskCacheBytes 设置最大sd卡缓存,如果传入-1</div><div class="line">     *就使用默认缓存</div><div class="line">     * <span class="doctag">@return</span> A 返回 instance.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack, <span class="keyword">int</span> maxDiskCacheBytes)</span> </span>&#123;</div><div class="line">        <span class="comment">//创建指定缓存文件</span></div><div class="line">        File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * UA一般都用于统计与识别</div><div class="line">         * User-Agent是Http协议中的一部分，属于头域的组成部</div><div class="line">         *分，User Agent也简称UA。用较为普通的一点来说</div><div class="line">         * ，是一种向访问网站提供你所使用的浏览器类型、操作系统</div><div class="line">         *及版本、CPU 类型、浏览器渲染引擎、浏览器语言、浏览器插</div><div class="line">         *件等信息的标识。</div><div class="line">         * UA字符串在每次浏览器 HTTP 请求时发送到服务器</div><div class="line">         */</div><div class="line">        String userAgent = <span class="string">"volley/0"</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//获取包名</span></div><div class="line">            String packageName = context.getPackageName();</div><div class="line">            <span class="comment">//获取包信息</span></div><div class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</div><div class="line">            <span class="comment">//获取userAgent</span></div><div class="line">            userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</div><div class="line">        &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//如果传入stack参数为null，那么创建默认的stack</span></div><div class="line">        <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//如果 API 大于9采用基于 HttpURLConnection 的 //HurlStack</span></div><div class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</div><div class="line">                stack = <span class="keyword">new</span> HurlStack();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// API小于9采用基于 HttpClient 的 //HttpClientStack</span></div><div class="line">            stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="comment">//new一个网络请求包装对象，并传入stack</span></div><div class="line">        Network network = <span class="keyword">new</span> BasicNetwork(stack);</div><div class="line">        RequestQueue queue;</div><div class="line">        <span class="keyword">if</span> (maxDiskCacheBytes &lt;= -<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//没有设置最大缓存maxDiskCacheBytes，创建默认大小缓存</span></div><div class="line">           queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">//设置最大缓存大小为maxDiskCacheBytes</span></div><div class="line">           queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir, maxDiskCacheBytes), network);</div><div class="line">        &#125;</div><div class="line"><span class="comment">//启动列队</span></div><div class="line">        queue.start();</div><div class="line"><span class="comment">//返回列队instance</span></div><div class="line">        <span class="keyword">return</span> queue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法代码稍微多一点，代码已经注释，这个构造方法主要是new 了一个 负责处理网络请求部分的stack对象，然后 用BasicNetwork将stack进行包装处理，又new了一个负责缓存部分的DiskBasedCache对象，并将这两个参数传入了列队queue中，并启动了列队；这里说明一下，在创建HttpStack对象的时候是比较了一下版本号，如果Build.VERSION.SDK_INT &gt;= 9（ API大于9）， stack = new HurlStack();这里是因为在Android 2.2版本之前，HttpURLConnection一直存在着一些令人厌烦的bug，在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量。到这里我们就完成使用volley的第一步分析，即获取RequestQueue对象，那么接下来我们分析下RequestQueue构造方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 创建请求列队，传入sd卡缓存包装类，和网络请求包装类</div><div class="line"> * 会调用含三个参数的构造方法，并传入参数默认参数DEFAULT_NETWORK_THREAD_POOL_SIZE为4，即默认</div><div class="line"> *线程数为4</div><div class="line"> * <span class="doctag">@param</span> cache sd卡缓存类</div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面分析含三个参数的构造方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 调用含四个参数的构造方法并传递默认 new ExecutorDelivery(new Handler(Looper.getMainLooper()))参数</div><div class="line"> * <span class="doctag">@param</span> cache sd卡缓存类</div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> * <span class="doctag">@param</span> threadPoolSize 网络请求线程的数量，这里threadPoolSize为DEFAULT_NETWORK_THREAD_POOL_SIZE</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(cache, network, threadPoolSize,</div><div class="line">            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>含四个参数的构造方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> cache sd卡缓存类 </div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> * <span class="doctag">@param</span> threadPoolSize 网络请求线程的数量</div><div class="line"> * <span class="doctag">@param</span> delivery用来回调网络请求结果的事件分发类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,</span></span></div><div class="line">        ResponseDelivery delivery) &#123;</div><div class="line">    mCache = cache;</div><div class="line">    mNetwork = network;</div><div class="line">    <span class="comment">//创建数量为DEFAULT_NETWORK_THREAD_POOL_SIZE 即数量为4的NetworkDispatcher数组</span></div><div class="line">    mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</div><div class="line">    <span class="comment">//mDelivery为含有三个参数构造函数调用传入的new ExecutorDelivery(new </span></div><div class="line">    <span class="comment">//Handler(Looper.getMainLooper()))对象</span></div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里我们来我们发现从调用含有两个参数的RequestQueue构造方法是逐渐调用三个、四个参数构造方法，那么最终实现了：mCachesd卡缓存类的实例化，network网络请求包装类 的实例化，创建了一个数量为4的NetworkDispatcher数组，mDelivery=new ExecutorDelivery(new Handler(Looper.getMainLooper())网络请求结果回调类的实例化。那么这里我们看一下回调网络请求结果类ExecutorDelivery构造方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> 创建一个回调网络请求结果的对象</div><div class="line"> * <span class="doctag">@param</span> handler 利用handler将runnable发送出去</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">//创建一个excuter包含了一个handler，然后利用传递进来的handler来将runnable发送出去</span></div><div class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">            handler.post(command);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的handler为new Handler(Looper.getMainLooper())，即handler是创建在主线程中，所以当调用 handler.post(command)的时候，是将网络请求结果发送到主线程主去处理，这样就完成了异步任务，将子线程中网络请求的结果发送到主线程中去处理。以上就完成了构造RequestQueue对象过程中的代码分析。</p>
<p>下面还有一个疑问要分析就是我们在调用volley的时候执行的RequestQueue.add()方法，分析一下是如何将请求添加到缓存列队和网络请求列队，以及如何进行管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 该方法用于向列队中添加请求request</div><div class="line"> * 其中包含了几种列队，起到不同的作用</div><div class="line"> * mCurrentRequests列队，用于存储目前正在进行但是尚未完成的请求</div><div class="line"> * mNetworkQueue网络请求列队，用于存储走网络的请求</div><div class="line"> * mWaitingRequests 如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将当前请求和处理请求的queue进行关联，这样当该请求结束的时候就会通知负责处理该请求的queue</span></div><div class="line">    request.setRequestQueue(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">      <span class="comment">//将请求添加到当前请求列队中</span></div><div class="line">        mCurrentRequests.add(request);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//添加序列号</span></div><div class="line">    request.setSequence(getSequenceNumber());</div><div class="line">    <span class="comment">//添加标记</span></div><div class="line">    request.addMarker(<span class="string">"add-to-queue"</span>);</div><div class="line">    <span class="comment">//如果请求不能缓存，直接添加到网络请求列队，结束方法</span></div><div class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;</div><div class="line">        mNetworkQueue.add(request);</div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//如果方法走到这一步说明，我们使用了缓存功能</span></div><div class="line">    <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">      <span class="comment">//取出请求的缓存键</span></div><div class="line">        String cacheKey = request.getCacheKey();</div><div class="line">      </div><div class="line">        <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class="line">            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class="line">            <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</div><div class="line">                stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果mWaitingRequests已经包含该请求，那么将该请求添加到mWaitingRequests中</span></div><div class="line">            stagedRequests.add(request);</div><div class="line">            mWaitingRequests.put(cacheKey, stagedRequests);</div><div class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//如果该请求不在正在执行等待的类列队mWaitingRequests中，直接添加到mCacheQueue中</span></div><div class="line">            mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</div><div class="line">            mCacheQueue.add(request);</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//返回当前请求</span></div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们来捋一捋request是如何被添加到请求列队中的步骤如下：</p>
<p>1、当add一个请求request时候，首先该请求会被添加当当前请求列队mCurrentRequests中。</p>
<p>2、如果该请求不使用缓存那么直接被添加到网络请求列队mNetworkQueue结束方法。</p>
<p>3、如果该请求使用了缓存，那么先判断mWaitingRequests列队中是否有该请求，如果有那么添加到mWaitingRequests中，如果没有直接添加到缓存请求列队mCacheQueue中。</p>
<p>到这里我们理解了一个请求是如何被添加到列队中，但是同时会产生一个疑问就是mCurrentRequests和mWaitingRequests这两个列队的作用是什么，以及如何调用的，我们初略猜想一下，这两个列队中维护的请求应该在一个请求结束的时候，将该请求移除，那么应该是RequestQueue的finish方法中进行调用，那么下面我们来看一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 该方法会在Request的方法中进行调用finish(String)，表明当前请求已经结束</div><div class="line"> * 需要从mCurrentRequests和mWaitingRequests中移除保存的请求Request</div><div class="line"> */</div><div class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">      <span class="comment">//从当前请求列队mCurrentRequests中移除请求request</span></div><div class="line">        mCurrentRequests.remove(request);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (mFinishedListeners) &#123;</div><div class="line">      <span class="keyword">for</span> (RequestFinishedListener&lt;T&gt; listener : mFinishedListeners) &#123;</div><div class="line">        listener.onRequestFinished(request);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (request.shouldCache()) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">            String cacheKey = request.getCacheKey();</div><div class="line">            <span class="comment">//如果请求可以使用缓存，将mWaitingRequests中存储的waitingRequests移除</span></div><div class="line">            Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class="line">         </div><div class="line">            <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</div><div class="line">                    VolleyLog.v(<span class="string">"Releasing %d waiting requests for cacheKey=%s."</span>,</div><div class="line">                            waitingRequests.size(), cacheKey);</div><div class="line">                &#125;</div><div class="line">                 <span class="comment">//如果移除当前结束的请求后，如果移除的waitingRequests！=null，</span></div><div class="line">            <span class="comment">// 那么将其添加到缓存列队mCacheQueue</span></div><div class="line">                mCacheQueue.addAll(waitingRequests);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码只需要看注释部分即可，并不复杂，那么RequestQueue的finish应该是什么时候调用呢，我们猜想应该是在一个request方法请求结束的时候，我们来看一下在Request类的finish方法中代码是否如此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">final</span> String tag)</span> </span>&#123;</div><div class="line">  <span class="comment">//调用处</span></div><div class="line">    <span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) &#123;</div><div class="line">        mRequestQueue.finish(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (MarkerLog.ENABLED) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> threadId = Thread.currentThread().getId();</div><div class="line">        <span class="keyword">if</span> (Looper.myLooper() != Looper.getMainLooper()) &#123;</div><div class="line">            Handler mainThread = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">            mainThread.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    mEventLog.add(tag, threadId);</div><div class="line">                    mEventLog.finish(<span class="keyword">this</span>.toString());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mEventLog.add(tag, threadId);</div><div class="line">        mEventLog.finish(<span class="keyword">this</span>.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码我们在第三行看到了mRequestQueue.finish(this);那么request方法结束请求有三种可能分别是：手动调用request.cancel方法取消请求、request请求成功回调成功结果、request请求失败回调失败结果，这三种请求都是表面当前request请求结束，那么我们分别看一下这三处的代码是否进行了调用，我们以网络请求线程NetworkDispatcher为例（缓存线程调度原理相同）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行网络请求线程，耗时任务的执行</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      ........</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                    <span class="comment">//如果请求取消，结束请求</span></div><div class="line">                    request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                  <span class="comment">//继续从列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">          ........</div><div class="line">               </div><div class="line">                <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                   <span class="comment">//如果networkResponse状态为304，并且已经返回了响应结果，那么结束请求不进行第二次返回</span></div><div class="line">                    request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                  <span class="comment">//继续请求列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">               ..........</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后看一下请求结果回调类ExecutorDelivery的run，执行了该方法表明将request请求结果进行了回调，所以request.finish()方法在此处也有调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//调用处</span></div><div class="line">        <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</div><div class="line">            mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">       ........</div><div class="line">        <span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">          <span class="comment">//如果这个请求需要刷新那么这个请求又被添加到了列队中，所以还在列队中，不要finish</span></div><div class="line">            mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">//否则调用finish</span></div><div class="line">            mRequest.finish(<span class="string">"done"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">.......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样mCurrentRequests和mWaitingRequests这两个列队的管理基本就捋清楚了。</p>
<p>下面我们就要思考获取到requestQueue对象，调用requestQueue.add（request）方法后，是如何启动网络请求的，那么我们看到在RequestQueue构造方法中有一行代码    queue.start()方法，那么接下来我们来分析一下这个方法具体内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 开始执行在列队中的各个线程分发调度</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//停止所有当前正在执行分发调度事件</span></div><div class="line">    stop();  </div><div class="line">    <span class="comment">//创建一个执行缓存分发调度线程，并将mCacheQueue缓存列队, mNetworkQueue网络请求列队, mCache缓存对象, mDelivery事件分发对象传递进去</span></div><div class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class="line">    <span class="comment">//启动缓存事件分发</span></div><div class="line">    mCacheDispatcher.start();</div><div class="line">    <span class="comment">//当i &lt; mDispatchers.length时循环创建networkDispatcher对象</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">       <span class="comment">//创建一个网络请求线程调度networkDispatcher线程，并将 mCacheQueue缓存列队, mNetworkQueue网络</span></div><div class="line">       <span class="comment">//请求列队, mCache负责处理缓存对象, mDelivery事件分发对象传递进去</span></div><div class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class="line">                mCache, mDelivery);</div><div class="line">        mDispatchers[i] = networkDispatcher;</div><div class="line">        <span class="comment">//启动网络缓存线程</span></div><div class="line">        networkDispatcher.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码主要实现功能是创建一个缓存事件调度线程并启动，然后循环创建了n个网络请求线程调度networkDispatcher对象，这里n= mDispatchers.length。mDispatchers数组的长度即是构造RequestQueue过程中传入的参数DEFAULT_NETWORK_THREAD_POOL_SIZE 即数量为4，也就是说创建了4个负责网络请求调度的线程。下面我们一起分析一下CacheDispatcher缓存调度线程代码，CacheDispatcher 继承自Thread，是一个线程，先看一下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> cacheQueue 缓存列队</div><div class="line"> * <span class="doctag">@param</span> networkQueue 网络请求列队</div><div class="line"> * <span class="doctag">@param</span> cache 缓存类</div><div class="line"> * <span class="doctag">@param</span> delivery 请求结果回调分发类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheDispatcher</span><span class="params">(</span></span></div><div class="line">        BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue, BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,</div><div class="line">        Cache cache, ResponseDelivery delivery) &#123;</div><div class="line">    mCacheQueue = cacheQueue;</div><div class="line">    mNetworkQueue = networkQueue;</div><div class="line">    mCache = cache;</div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后主要看一下run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//复写Run方法，这里执行耗时操作，在子线程中执行</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</div><div class="line">    <span class="comment">//设置线程优先级</span></div><div class="line"> Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">    <span class="comment">//初始化缓存类</span></div><div class="line">    mCache.initialize();</div><div class="line">  <span class="comment">//循环从列队中读取请求并执行</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//从列队的首部取出一个request</span></div><div class="line">            <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</div><div class="line">            <span class="comment">//添加一个标记</span></div><div class="line">            request.addMarker(<span class="string">"cache-queue-take"</span>);</div><div class="line">            <span class="comment">//如果取出的请求取消，那么结束请求</span></div><div class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                request.finish(<span class="string">"cache-discard-canceled"</span>);</div><div class="line">              <span class="comment">//继续循环从缓存列队中拿请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//从缓存中读取缓存数据</span></div><div class="line">            Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//如果请求结果为null，那么添加标记</span></div><div class="line">                request.addMarker(<span class="string">"cache-miss"</span>);</div><div class="line">                 <span class="comment">//然后将请求发送到网络请求列队</span></div><div class="line">                mNetworkQueue.put(request);</div><div class="line">               <span class="comment">//然后继续循环去缓存列队中拿取请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (entry.isExpired()) &#123;</div><div class="line">                <span class="comment">//如果缓存过期，添加标记</span></div><div class="line">                request.addMarker(<span class="string">"cache-hit-expired"</span>);</div><div class="line">                request.setCacheEntry(entry);</div><div class="line">              <span class="comment">//将请求发送到网络请求列队</span></div><div class="line">                mNetworkQueue.put(request);</div><div class="line">              <span class="comment">//然后继续去缓存列队中拿取请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//走到这一步，说明已经拿到缓存，添加标记命中</span></div><div class="line">            request.addMarker(<span class="string">"cache-hit"</span>);</div><div class="line">            <span class="comment">//解析网络缓存数据NetworkResponse得到Response&lt;T&gt; 结果</span></div><div class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">                    <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line">            <span class="comment">//标记解析完成</span></div><div class="line">            request.addMarker(<span class="string">"cache-hit-parsed"</span>);</div><div class="line">            <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</div><div class="line">                <span class="comment">//如果不需要刷新，那么直接将解析结果回调</span></div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//如果需要刷新，那么添加标记</span></div><div class="line">                request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</div><div class="line">                request.setCacheEntry(entry);</div><div class="line">                response.intermediate = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">//返回数据，并将将请求添加到网络请求列队，但是是发送出去到主线程中执行</span></div><div class="line">                mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            mNetworkQueue.put(request);</div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="comment">//调用mQuit方法结束循环</span></div><div class="line">            <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">          <span class="comment">//否则继续缓存列队中取出request</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个run方法主要作用是：启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code> 去执行，将请求结果发送到主线程中。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入<code>NetworkDispatcher</code>去调度处理。这里有一行代码mDelivery.postResponse(request, response);是将请求结果发送到主线程中，前面我们提到是利用handler.post()方法执行，那么我们看看ExecutorDelivery 类的postResponse的具体细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</div><div class="line">    <span class="comment">//直接调用三个参数的post方法</span></div><div class="line">    postResponse(request, response, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就一行代码，调用含三个参数的构造方法，那么我们继续追溯：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</div><div class="line">    request.markDelivered();</div><div class="line">    request.addMarker(<span class="string">"post-response"</span>);</div><div class="line">    <span class="comment">//通过ResponseDeliveryRunnable将request, response, runnable包装后发送出去到主线程handle中</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的mResponsePoster就是在构造ExecutorDelivery 时候生成的Executor对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">    <span class="comment">// Make an Executor that just wraps the handler.</span></div><div class="line">    <span class="comment">//创建一个excuter包含了一个handler，handler来将runnable发送出去</span></div><div class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">          <span class="comment">//将Runnable对象发送到主线程</span></div><div class="line">            handler.post(command);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而ResponseDeliveryRunnable继承Runnable，所以当调用mResponsePoster.execut（new ResponseDeliveryRunnable(request, response, runnable)）方法时候就会将ResponseDeliveryRunnable对象发送到主线程中，那么我们看一下ResponseDeliveryRunnable类的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在主线程中运行</span></div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</div><div class="line">              <span class="comment">//如果请求取消，那么结束方法</span></div><div class="line">                mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</div><div class="line">              <span class="comment">//如果请求成功调用mRequest.deliverResponse，这个方法在我们自定义request时候需要重写的，每一条网络请求的响应都是回调到这个方法中，主线程中运行</span></div><div class="line">            mRequest.deliverResponse(mResponse.result);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="comment">//请求失败回调</span></div><div class="line">                mRequest.deliverError(mResponse.error);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (mResponse.intermediate) &#123;</div><div class="line">                mRequest.addMarker(<span class="string">"intermediate-response"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mRequest.finish(<span class="string">"done"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="comment">//如果传入Runnable不为空，那么执行Runnable</span></div><div class="line">                mRunnable.run();</div><div class="line">            &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码我们看自定义Request时候需要复写的方法   mRequest.deliverResponse(mResponse.result);和mRequest.deliverError(mResponse.error)。到这里请求回调的疑问我们已经解决。</p>
<p>下面我们先分析一下NetworkDispatcher网络缓存线程，NetworkDispatcher 继承自Thread，也就是说NetworkDispatcher 是一个线程先看一下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> queue 网络请求列队</div><div class="line"> * <span class="doctag">@param</span> network 网络请求包装类</div><div class="line"> * <span class="doctag">@param</span> cache 缓存类</div><div class="line"> * <span class="doctag">@param</span> delivery 请求结果回调分发类</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkDispatcher</span><span class="params">(BlockingQueue&lt;Request&lt;?&gt;&gt; queue,</span></span></div><div class="line">        Network network, Cache cache,</div><div class="line">        ResponseDelivery delivery) &#123;</div><div class="line">    mQueue = queue;</div><div class="line">    mNetwork = network;</div><div class="line">    mCache = cache;</div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后看一下复写的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行网络请求线程，耗时任务的执行,在子线程中执行</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">//设置线程优先级</span></div><div class="line"> Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        Request&lt;?&gt; request;</div><div class="line">      <span class="comment">//从网络请求列队中循环读取request并执行请求</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">long</span> startTimeMs = SystemClock.elapsedRealtime();</div><div class="line">            request = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//从网络请求列队中拿到一个请求</span></div><div class="line">                request = mQueue.take();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                <span class="comment">//如果调用了mQuit就直接结束该方法</span></div><div class="line">                <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">              <span class="comment">//否则继续从列队中拿请求</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//添加拿到标记</span></div><div class="line">                request.addMarker(<span class="string">"network-queue-take"</span>);</div><div class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">                    <span class="comment">//如果请求取消，结束请求</span></div><div class="line">                    request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                  <span class="comment">//继续从列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//设置线程状态</span></div><div class="line">                addTrafficStatsTag(request);</div><div class="line">                <span class="comment">//执行网络请求，得到请求结果NetworkResponse</span></div><div class="line">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">                <span class="comment">//添加执行请求完成状态</span></div><div class="line">                request.addMarker(<span class="string">"network-http-complete"</span>);</div><div class="line">               </div><div class="line">                <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                   <span class="comment">//如果networkResponse状态为304，并且已经传递了响应结果，那么结束请求不进行第二次返回</span></div><div class="line">                    request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                  <span class="comment">//继续请求列队拿请求</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//将networkResponse解析成  Response&lt;?&gt; response，这个解析方法我们可以自己在</span></div><div class="line">              <span class="comment">//Request类进行复写，自己定义解析方法</span></div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">              <span class="comment">//添加解析完成标记</span></div><div class="line">                request.addMarker(<span class="string">"network-parse-complete"</span>);</div><div class="line">                <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//如果请求使用了缓存，并且响应结果不为空，那么将请求结果存入缓存</span></div><div class="line">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">                  <span class="comment">//添加完成缓存标记</span></div><div class="line">                    request.addMarker(<span class="string">"network-cache-written"</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//添加请求结果回调标记</span></div><div class="line">                request.markDelivered();</div><div class="line">              <span class="comment">//回调响应结果，即将请求响应结果，发送到主线程</span></div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</div><div class="line">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">              <span class="comment">//请求网络失败回调</span></div><div class="line">                parseAndDeliverNetworkError(request, volleyError);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</div><div class="line">                VolleyError volleyError = <span class="keyword">new</span> VolleyError(e);</div><div class="line">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">              <span class="comment">//请求失败回调</span></div><div class="line">                mDelivery.postError(request, volleyError);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>run方法启动后会不断从网络请求队列中取请求处理，队列为空则等待，拿到请求后，则执行网络请求，请求处理结束则将结果传递给 ResponseDelivery 去执行后续处理，并判断结果是否要进行缓存。</p>
<p>下面我们来捋一捋volley如如何进行网络请求、缓存请求和请求结果的回调，步骤如下：</p>
<p>1、创建了一个缓存事件调度线程CacheDispatcher，负责从缓存列队中读取请求，然后从缓存中读取数据，进行解析返回，从缓存中读取数据为null，或者数据过期、需要刷新，那么将请求添加到网络请求列队。</p>
<p>2、创建了四个网络请求事件调度线程NetworkDispatcher，负责处理网络请求，并解析请求结果进行返回，并将结果缓存到本地。</p>
<p>3、创建了一个请求结果回调类ResponseDelivery，负责将请求结果返回到主线程，原理是利用handler将结果post到主线程。</p>
<p>到这里volley框架的主要流程我们基本梳理通顺了，下面我们在看一下细节方面，网络请求是如何执行的，上面代码中执行网络请求代码mNetwork.performRequest(request)，其中mNetwork就是我们在构造RequestQueue时候传入的BasicNetwork对象，那么看一下具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 通过HttpStack，即执行http网络请求请求</div><div class="line"> * 并将HttpStack请求结果包装成NetworkResponse返回NetworkRespons</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</div><div class="line">    <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="comment">//http请求头文件包装信息</span></div><div class="line">        HttpResponse httpResponse = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//请求返回内容body</span></div><div class="line">        <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//生成一个map对象</span></div><div class="line">        Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">            <span class="comment">//添加请求头文件信息，entry即是定义request类时候复写setCacheEntry传入</span></div><div class="line">            addCacheHeaders(headers, request.getCacheEntry());</div><div class="line">            <span class="comment">//执行mHttpStack操作返回请求结果httpResponse</span></div><div class="line">            httpResponse = mHttpStack.performRequest(request, headers);</div><div class="line">            <span class="comment">//获取到请求状态</span></div><div class="line">            StatusLine statusLine = httpResponse.getStatusLine();</div><div class="line">            <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</div><div class="line">            <span class="comment">//取出httpResponse中header添加到responseHeaders</span></div><div class="line">            responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class="line">            <span class="comment">//如果是304状态没有更新状态</span></div><div class="line">            <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class="line">                <span class="comment">//缓存中取出entry对象</span></div><div class="line">                Entry entry = request.getCacheEntry();</div><div class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//如果entry为null，返回一个entry为null的NetworkResponse</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, <span class="keyword">null</span>,</div><div class="line">                            responseHeaders, <span class="keyword">true</span>,</div><div class="line">                            SystemClock.elapsedRealtime() - requestStart);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                entry.responseHeaders.putAll(responseHeaders);</div><div class="line">                <span class="comment">//如果entry不为null，返回一个entry的NetworkResponse</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class="line">                        entry.responseHeaders, <span class="keyword">true</span>,</div><div class="line">                        SystemClock.elapsedRealtime() - requestStart);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//301/302 Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</span></div><div class="line">            <span class="keyword">if</span> (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class="line">               String newUrl = responseHeaders.get(<span class="string">"Location"</span>);</div><div class="line">               request.setRedirectUrl(newUrl);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//获取entry不为null,将entry转换为byte类型</span></div><div class="line">              responseContents = entityToBytes(httpResponse.getEntity());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//否则new 一个responseContents对象</span></div><div class="line">              responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class="line">            <span class="comment">//打印请求生命周期，请求，响应内容，和状态</span></div><div class="line">            logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class="line">            <span class="comment">//根据状态码抛出异常</span></div><div class="line">            <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//返回包含响应entry和header的NetworkResponse</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>,</div><div class="line">                    SystemClock.elapsedRealtime() - requestStart);</div><div class="line">            <span class="comment">//抛出各种异常</span></div><div class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</div><div class="line">            attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</div><div class="line">        ...........</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段方法中大多都是一些网络请求细节方面的东西，部分已经添加注释，我们抓重点看即可，其中httpResponse = mHttpStack.performRequest(request, headers);这一行代码中的mHttpStack就是我们在构造RequestQueue的时候传入的HttpStack对象，负责处理http网络请求的，然后就是有几处代码是return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,        responseHeaders, true,        SystemClock.elapsedRealtime() - requestStart))，其中区别就是参数不同，所以这个方法其实只要实现功能就是调用<code>HttpStack</code>处理网络请求，并将结果进行包装转换为可被<code>ResponseDelivery</code>处理的<code>NetworkResponse</code>对象返回。</p>
<p>下面我们看一下mHttpStack.performRequest(request, headers)这个方法是如何处理网络请求的（以HurlStack类为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 封装执行HttpURLConnection网络请求，返回HttpResponse对象</div><div class="line"> * <span class="doctag">@param</span> request the request to perform</div><div class="line"> * <span class="doctag">@param</span> additionalHeaders 附加的请求头文件信息</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException, AuthFailureError &#123;</div><div class="line">    <span class="comment">//获取网络请求url</span></div><div class="line">    String url = request.getUrl();</div><div class="line">    <span class="comment">//new 一个map对象</span></div><div class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">    <span class="comment">//将请求header信息添加进去</span></div><div class="line">    map.putAll(request.getHeaders());</div><div class="line">    map.putAll(additionalHeaders);</div><div class="line">    <span class="keyword">if</span> (mUrlRewriter != <span class="keyword">null</span>) &#123;</div><div class="line">        String rewritten = mUrlRewriter.rewriteUrl(url);</div><div class="line">        <span class="keyword">if</span> (rewritten == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"URL blocked by rewriter: "</span> + url);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取到url</span></div><div class="line">        url = rewritten;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//解析url</span></div><div class="line">    URL parsedUrl = <span class="keyword">new</span> URL(url);</div><div class="line">    <span class="comment">//创建HttpURLConnection网络请求连接</span></div><div class="line">    HttpURLConnection connection = openConnection(parsedUrl, request);</div><div class="line">    <span class="keyword">for</span> (String headerName : map.keySet()) &#123;</div><div class="line">        <span class="comment">//添加请求头信息</span></div><div class="line">        connection.addRequestProperty(headerName, map.get(headerName));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置连接参数，主要设置各种请求类型</span></div><div class="line">    setConnectionParametersForRequest(connection, request);</div><div class="line">  ........</div><div class="line">    <span class="comment">//解析请求body请求体</span></div><div class="line">    response.setEntity(entityFromConnection(connection));</div><div class="line">    <span class="keyword">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</div><div class="line">        <span class="keyword">if</span> (header.getKey() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//解析请求header添加请求头</span></div><div class="line">            Header h = <span class="keyword">new</span> BasicHeader(header.getKey(), header.getValue().get(<span class="number">0</span>));</div><div class="line">            response.addHeader(h);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//请求结果返回</span></div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码中我们终于看见了我们熟悉的HttpURLConnection对象，并进行了一系列的参数设置，解析返回数据返回HttpResponse对象。到这里负责执行网络请求部分的内容我们也梳理结束。</p>
<p>至此，关于volley的学习笔记到此结束，如有理解错误地方，还请指教！！</p>
<p>最后其实网络上关 Volley源码分析有很多文章，东西都差不多，但是每个人的侧重点和分析角度以及能否把事情讲的通俗易懂差别就大了，关键是要找到适合自己的，如果感觉本人分析你读着比较懵逼，那可能是我写的不清真，那么可以出门左拐<a href="http://yongyu.itscoder.com/2016/08/01/Volley%20Study/" target="_blank" rel="external"><a href="http://extremej.itscoder.com/volley_source/" target="_blank" rel="external">黑丫山上的小帅比 对Volley的深入分析</a></a> 和郭霖大神的博客去看一下，如果还是看不懂，那就有肯能是你理解的不清真了（just a joke) !!</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://github.com/yongyu0102/Images/blob/master/avatar/avatar.png?raw=true"
               alt="Yongyu" />
          <p class="site-author-name" itemprop="name">Yongyu</p>
          <p class="site-description motion-element" itemprop="description">这里记录你的故事！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://extremej.itscoder.com/" title="Joe" target="_blank">Joe</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://jaeger.itscoder.com/" title="写代码的猴子" target="_blank">写代码的猴子</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://brucezz.itscoder.com/" title="Brucezz" target="_blank">Brucezz</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://allenwu.itscoder.com/" title="小刚" target="_blank">小刚</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yongyu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
 </script>
 </br>本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"yongyu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>

<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android View," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="-文章来源：itsCoder 的 WeeklyBolg 项目

itsCoder主页：http://itscoder.com/
作者：yongyu0102
审阅者：hymane


1 前言View 是 Android 中所有控件的基类，例如 Button 和 TextView、ViewGroup 等常见控件他们的基类都是 View，View 是一种界面层的控件的一种抽象，代表了一个控件。Vie">
<meta property="og:type" content="article">
<meta property="og:title" content="View 的工作原理上 View 绘制流程梳理及 Measure 过程详解（Android 开发艺术探索笔记）">
<meta property="og:url" content="http://yoursite.com/2016/09/11/view_measure/index.html">
<meta property="og:site_name" content="一个写代码的地方">
<meta property="og:description" content="-文章来源：itsCoder 的 WeeklyBolg 项目

itsCoder主页：http://itscoder.com/
作者：yongyu0102
审阅者：hymane


1 前言View 是 Android 中所有控件的基类，例如 Button 和 TextView、ViewGroup 等常见控件他们的基类都是 View，View 是一种界面层的控件的一种抽象，代表了一个控件。Vie">
<meta property="og:image" content="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/decorView_view.png?raw=true">
<meta property="og:image" content="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/decorView.png?raw=true">
<meta property="og:image" content="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/view.png?raw=true">
<meta property="og:image" content="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/mesureSpec.png?raw=true">
<meta property="og:updated_time" content="2016-09-19T13:41:06.209Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="View 的工作原理上 View 绘制流程梳理及 Measure 过程详解（Android 开发艺术探索笔记）">
<meta name="twitter:description" content="-文章来源：itsCoder 的 WeeklyBolg 项目

itsCoder主页：http://itscoder.com/
作者：yongyu0102
审阅者：hymane


1 前言View 是 Android 中所有控件的基类，例如 Button 和 TextView、ViewGroup 等常见控件他们的基类都是 View，View 是一种界面层的控件的一种抽象，代表了一个控件。Vie">
<meta name="twitter:image" content="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/decorView_view.png?raw=true">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/09/11/view_measure/"/>





  <title> View 的工作原理上 View 绘制流程梳理及 Measure 过程详解（Android 开发艺术探索笔记） | 一个写代码的地方 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一个写代码的地方</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">记录你的学习</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/11/view_measure/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Yongyu">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://github.com/yongyu0102/Images/blob/master/avatar/avatar.png?raw=true">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一个写代码的地方">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="一个写代码的地方" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                View 的工作原理上 View 绘制流程梳理及 Measure 过程详解（Android 开发艺术探索笔记）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-11T00:00:00+08:00">
                2016-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android-View/" itemprop="url" rel="index">
                    <span itemprop="name">Android View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/09/11/view_measure/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/11/view_measure/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>-文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</p>
<ul>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://github.com/yongyu0102" target="_blank" rel="external">yongyu0102</a></li>
<li>审阅者：<a href="https://github.com/hymanme" target="_blank" rel="external">hymane</a></li>
</ul>
</blockquote>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>View 是 Android 中所有控件的基类，例如 Button 和 TextView、ViewGroup 等常见控件他们的基类都是 View，View 是一种界面层的控件的一种抽象，代表了一个控件。View 本身可以是单个控件也可以是由多个控件组成的一组控件，通过这种关系就形成了 View 树的结构。Android 系统本身就提供好了很多好用的 View，你也可以自己根据需求去自定义一个 View，拿最简单的一个例子来说，当我们想在界面上显示一行文字的时候，我们会在 xml 文件中写好布局然后在  Activity 中的 onCreate 方法中使用 setContentView 方法来加载布局就可以显示出我们想要的文字，这时候你是否有思考过这个过程是怎么完成的， View 是如何被显示到界面上的；还有一个我们经常遇到的问题是：当我们在一个 ScrollView 控件内部嵌套一个 ListView 的时候 ListView 只会显示一行；当使用自定义的 View 的时候，View 可以显示到界面，但是当使用 WrapContent 属性的时候不起作用，这些问题笔者就曾都遇到过，如果你也曾有过这样的疑问，可以阅读以下这篇文章。</p>
<h2 id="1-1-主要内容简介"><a href="#1-1-主要内容简介" class="headerlink" title="1.1 主要内容简介"></a>1.1 主要内容简介</h2><p>View 的工作原理主要包含 View 的三大流程 onMeasure()、onLayout()和onDraw()  ，而由于一次性全部写完内容会有点长，所以本次主要先介绍关于 View 的工作流程的整体梳理和 Measure 过程相关知识，而下一篇笔记会把剩下的部分写完。</p>
<h1 id="2-初识-ViewRoot-和-DecorView"><a href="#2-初识-ViewRoot-和-DecorView" class="headerlink" title="2 初识 ViewRoot 和 DecorView"></a>2 初识 ViewRoot 和 DecorView</h1><p>在正式介绍 View 的三大流程 onMeasure()、onLayout()和onDraw() 之前，先简单介绍一下当我们在 Activity 方法 onCreate 里执行 setContentView 之后 View 是如何显示到屏幕上的，这里我们就不分析源码过程了，因为这个过程不是我们要分析的重点，只是辅助我们去理解，有助于我们对整个流程有更好的理解和把握。</p>
<p>当调用 Activity 的  setContentView 方法后会调用  PhoneWindow 类 的 setContentView  方法，PhoneWindow 类是抽象类Window的实现类，Window 类用来描述 Activity 视图最顶端的窗口显示和行为操作，PhoneWindow 类 的 setContentView  方法中最终会 生成一个 DecorView 对象，DecorView 是 PhoneWindow类的内部类，继承自FrameLayout ，所以调用 Activity 方法 setContetnView 后最终会生成一个 FrameLayout 类型的 DecorView 组件，该组件将作为整个应用窗口的顶层图，然后在 DecorView 容器中添加根布局，根布局中包含一个 id 为 contnet 的 FrameLayout 内容布局，我们的 Activity 加载的布局 xml 最后通过LayoutInflater 将 xml 内容布局解析成 View 树形结构，最后添加到 id 为 content 的 FrameLayout布局当中，至此，View 最终就会显示到手机屏幕上，如果想详细了解出门右转<a href="http://blog.csdn.net/feiduclear_up/article/details/46772477" target="_blank" rel="external">从ViewRootImpl类分析View绘制的流程——废墟的树</a>。整理流程梳理可以参考下面这张图片：</p>
<p>​                   <img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/decorView_view.png?raw=true" alt="decorView_view"></p>
<p>我们了解了上面得到流程后下面梳理一下如何进入到 view 的绘制流程：</p>
<p>ViewRoot 对应的实现类是 ViewRootImpl 类，他是连接 WindowManager 和DecorView 的纽带，view 的三大 流程均是通过 ViewRoot 来完成的。在 ActivityThread 中，当 activity 对象被创建完毕后，会将 DecorView 添加到Window 中，同时会创建 ViewRootImpl 对象，并将 ViewRootImpl 对象和 DecorView 建立关联。这个流程可以参考下图，图片来自<a href="http://blog.csdn.net/feiduclear_up/article/details/46772477" target="_blank" rel="external">从ViewRootImpl类分析View绘制的流程——废墟的树</a>：</p>
<p><img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/decorView.png?raw=true" alt="decorView"></p>
<p>View 的绘制流程是从 ViewRoot 的 performTraversals 方法开始的，它经过 measure、layout、draw 三个过程才能最终将一个 View 绘制出来，其中 measure 用来测量 View 的宽和高，layout 用来确定 View 在父容器的放置位置，而 draw 则负责将 View 绘制在屏幕上，参考下图（来源艺术探索截图） ：</p>
<p><img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/view.png?raw=true" alt="view"></p>
<p>performTraversals 会依次调用 performMeasure、performLayout、performDraw 三个方法，这三个方法分别完成顶级 View 的 measure、layout 和 draw 这三大流程，其中 performMeasure 会调用 measure 方法，在measure 方法中又会调用 onMeasure 方法，在 onMeasure 方法中对所有的子元素进行 measure 过程，这个时候 measure 流程就会从父容器传递到子元素中了，这样就完成了一次 measure 过程。接着子元素就会重复父容器的 measure 过程，如此反复就完成了整个 View 树的遍历，同理 perFormLayout 和 performDraw 的流程也是类似。</p>
<p>measure 过程决定了 view 的宽高，在几乎所有的情况下这个宽高都等同于 view 最终的宽高，但特殊情况除外。layout 过程决定了 view 的四个顶点的坐标和 view实 际的宽高，通过 <code>getWidth</code> 和 <code>getHeight</code> 方法可以得到最终的宽高。draw过程决定了view的显示。</p>
<p>DecorView 其实是一个 FrameLayout，其中包含了一个竖直方向的 LinearLayout，上面是标题栏，下面是内容栏(id为<code>android.R.id.content</code>)。</p>
<h1 id="3-理解MeasureSpec"><a href="#3-理解MeasureSpec" class="headerlink" title="3 理解MeasureSpec"></a>3 理解MeasureSpec</h1><p>MeasureSpec  是 View 测量过程中的一个关键参数，很大程度上决定了 View 的宽高，父容器会影响 View 的 MeasureSpec 的创建，MeasureSpec 不是唯一由 LayoutParams 决定的，LayoutParams 需要和父容器一起才能决定 View 的MeasureSpec，从而进一步确定 View 的宽高，在 View 测量过程中，系统会将该 View 的 LayoutParams 参数在父容器的约束下转换成对应的 MeasureSpec ，然后再根据这个 measureSpec 来测量 View 的宽高。</p>
<p>MeasureSpec 代表一个32位 int 值，高2位代表 SpecMode（测量模式），低30位代表 SpecSize（在某个测量模式下的规格大小），MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的内存分配，为了方便操作，其提供了打包和解包方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过将 SpecMode 和 SpecSize 打包，获取 MeasureSpec  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">        <span class="keyword">return</span> size + mode;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//将 MeasureSpec 解包获取 SpecMode</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">        &#125;</div><div class="line"><span class="comment">//将 MeasureSpec 解包获取 SpecSize</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p><strong>SpecMode 有三类，每一类都表示特殊的含义：</strong></p>
<ol>
<li>UNSPECIFIED 父容器不对 View 有任何的限制，要多大给多大，这种情况下一般用于系统内部，表示一种测量的状态。</li>
<li>EXACTLY 父容器已经检测出 View 所需要的精确大小，这个时候 View 的最终大小就是 SpecSize 所指定的值，它对应于LayoutParams 中的 match_parent 和具体的数值这两种模式</li>
<li>AT_MOST 父容器指定了一个可用大小即 SpecSize，View 的大小不能大于这个值，具体是什么值要看不同 View 的具体实现。它对应于 LayoutParams 中的 wrap_content。</li>
</ol>
<h1 id="4-MeasureSpec-和-LayoutParams-的对应关系"><a href="#4-MeasureSpec-和-LayoutParams-的对应关系" class="headerlink" title="4 MeasureSpec 和 LayoutParams 的对应关系"></a>4 MeasureSpec 和 LayoutParams 的对应关系</h1><p><strong>对于DecorView，它的 MeasureSpec 由窗口的尺寸和其自身的 LayoutParams 来决定；对于普通 View，它的MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定。</strong></p>
<p>对普通的 View 的 measure 方法的调用，是由其父容器传递而来的，这里先看一下 ViewGroup 的 measureChildWithMargins 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> * <span class="meta">@param</span> child 要被测量的 View</div><div class="line"> * <span class="meta">@param</span> parentWidthMeasureSpec 父容器的 WidthMeasureSpec</div><div class="line"> * <span class="meta">@param</span> widthUsed 父容器水平方向已经被占用的空间，比如被父容器的其他子 view 所占用的空间</div><div class="line"> * <span class="meta">@param</span> parentHeightMeasureSpec 父容器的 HeightMeasureSpec</div><div class="line"> * <span class="meta">@param</span> heightUsed 父容器竖直已经被占用的空间，比如被父容器的其他子 view 所占用的空间</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">   <span class="comment">//第一步，获取子 View 的 LayoutParams</span></div><div class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">   <span class="comment">//第二步，获取子 view 的 WidthMeasureSpec，其中传入的几个参数说明：</span></div><div class="line">   <span class="comment">//parentWidthMeasureSpec 父容器的 WidthMeasureSpec</span></div><div class="line">   <span class="comment">//mPaddingLeft + mPaddingRight view 本身的 Padding 值，即内边距值</span></div><div class="line">   <span class="comment">//lp.leftMargin + lp.rightMargin view 本身的 Margin 值，即外边距值</span></div><div class="line">   <span class="comment">//widthUsed 父容器已经被占用空间值</span></div><div class="line">   <span class="comment">// lp.width view 本身期望的宽度 with 值</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                    + widthUsed, lp.width);</div><div class="line">     <span class="comment">//获取子 view 的 HeightMeasureSpec</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                    + heightUsed, lp.height);</div><div class="line"><span class="comment">// 第三步，根据获取的子 veiw 的 WidthMeasureSpec 和 HeightMeasureSpec </span></div><div class="line">   <span class="comment">//对子 view 进行测量</span></div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上代码第二步可以看出，子 view 的 MeasureSpec 的创建与父容器的 MeasureSpec 、子 view 本身的 LayoutParams 有关，此外还与 view 本身的 margin 和 padding 值有关，具体看一下 getChildMeasureSpec 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param spec 父容器的 MeasureSpec，是对子 View 的约束条件</div><div class="line">     * @param padding 当前 View 的 padding、margins 和父容器已经被占用空间值</div><div class="line">     * @param childDimension View 期望大小值，即layout文件里设置的大小:可以是MATCH_PARENT,</div><div class="line">     *WRAP_CONTENT或者具体大小, 代码中分别对三种做不同的处理</div><div class="line">     * @return 返回 View 的 MeasureSpec 值</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</div><div class="line">  <span class="comment">// 获取父容器的 specMode，父容器的测量模式影响子 View  的测量模式</span></div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</div><div class="line">         <span class="comment">// 获取父容器的 specSize 尺寸，这个尺寸是父容器用来约束子 View 大小的</span></div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</div><div class="line"><span class="comment">// 父容器尺寸减掉已经被用掉的尺寸</span></div><div class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</div><div class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="comment">// 如果父容器是 EXACTLY 精准测量模式</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        <span class="comment">//如果子 View 期望尺寸为大于 0 的固定值，对应着 xml 文件中给定了 View 的具体尺寸大小</span></div><div class="line">        <span class="comment">//如 android:layout_width="100dp"</span></div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">          <span class="comment">//那么子 View 尺寸为期望值固定尺寸，测量模式为精准测量模式 EXACTLY</span></div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">             <span class="comment">//如果子 View 期望尺寸为 MATCH_PARENT 填充父布局</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            <span class="comment">// 那么子 View 尺寸为 size 最大值，即父容器剩余空间尺寸，为精准测量模式 EXACTLY</span></div><div class="line">          <span class="comment">//即子 View 填的是 Match_parent, 那么父 View 就给子 View 自己的size(去掉padding)，</span></div><div class="line">          <span class="comment">//即剩余全部未占用的尺寸, 然后告诉子 View 这是 Exactly 精准的大小，你就按照这个大小来设定自己的尺寸</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">          <span class="comment">//如果子 View 期望尺寸为 WRAP_CONTENT ，包裹内容</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">          <span class="comment">//子 View 尺寸为 size  最大值，即父容器剩余空间尺寸 ，测量模式为 AT_MOST 最大测量模式</span></div><div class="line">          <span class="comment">//即子 View 填的是 wrap_Content,那么父 View 就告诉子 View 自己的size(去掉padding),</span></div><div class="line">          <span class="comment">//即剩余全部未占用的尺寸,然后告诉子 View, 你最大的尺寸就这么多，不能超过这个值, </span></div><div class="line">          <span class="comment">//具体大小，你自己根据自身情况决定最终大小。一般当我们继承 View 基类进行自定义 View  的时候</span></div><div class="line">          <span class="comment">//需要在这种情况下计算给定 View 一个尺寸，否则当使用自定义的 View 的时候，使用 </span></div><div class="line">          <span class="comment">// android:layout_width="wrap_content" 属性就会失效</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 父容器为 AT_MOST 最大测量模式</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">           <span class="comment">// 子 View 期望尺寸为一个大于 0的具体值，对应着 xml 文件中给定了 View 的具体尺寸大小</span></div><div class="line">        <span class="comment">//如 android:layout_width="100dp"</span></div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">           <span class="comment">//那么子 View 尺寸为期望固定值尺寸，为精准测量模式 EXACTLY</span></div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">          <span class="comment">//如果子 View 期望尺寸为 MATCH_PARENT 最大测量模式</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">             <span class="comment">//子 View 尺寸为 size，测量模式为 AT_MOST  最大测量模式</span></div><div class="line">          <span class="comment">//即如果子 View 是 Match_parent,那么父 View 就会告诉子 View, </span></div><div class="line">          <span class="comment">//你的尺寸最大为 size 这么大（父容器尺寸减掉已经被用掉的尺寸，即父容器剩余未占用尺寸），</span></div><div class="line">          <span class="comment">//你最多有父 View的 size 这么大，不能超过这个尺寸，至于具体多大，你自己根据自身情况决定。</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">             <span class="comment">//同上</span></div><div class="line">            resultSize = size;</div><div class="line">            resultMode = MeasureSpec.AT_MOST;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 父容器为 UNSPECIFIED 模式</span></div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">           <span class="comment">// 子 View 期望尺寸为一个大于 0的具体值</span></div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">             <span class="comment">//那么子 View 尺寸为期望值固定尺寸，为精准测量模式 EXACTLY</span></div><div class="line">            resultSize = childDimension;</div><div class="line">            resultMode = MeasureSpec.EXACTLY;</div><div class="line">           <span class="comment">//如果子 View 期望尺寸为 MATCH_PARENT 最大测量模式</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">              <span class="comment">//子 View 尺寸为 0，测量模式为 UNSPECIFIED</span></div><div class="line">           <span class="comment">// 父容器不对 View 有任何的限制，要多大给多大</span></div><div class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">            resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">           <span class="comment">//如果子 View 期望尺寸为 WRAP_CONTENT ，包裹内容</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">             <span class="comment">//子 View 尺寸为 0，测量模式为 UNSPECIFIED</span></div><div class="line">             <span class="comment">// 父容器不对 View 有任何的限制，要多大给多大</span></div><div class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">            resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码主要作用就是根据父容器的  MeasureSpec 和 view 本身的 LayoutParams 来确定子元素的 MeasureSpec 的整个过程，这个过程清楚的展示了普通 view 的 MeasureSpec  的创建规则，整理一下可得到如下表格（来源艺术探索截图）：</p>
<p><img src="https://github.com/yongyu0102/WeeklyBlogImages/blob/master/phase3_view_measure/mesureSpec.png?raw=true" alt="mesureSpec">总结：</p>
<ol>
<li>当 View 采用固定宽高时，不管父容器的 MeasureSpec 是什么，View 的 MeasureSpec 都是精确模式，并且大小是LayoutParams 中的大小。</li>
<li>当 View 的宽高是 match_parent 时，如果父容器的模式是精确模式，那么 View 也是精确模式，并且大小是父容器的剩余空间；如果父容器是最大模式，那么 View 也是最大模式，并且大小是不会超过父容器的剩余空间。</li>
<li>当 View 的宽高是 wrap_content 时，不管父容器的模式是精确模式还是最大模式，View 的模式总是最大模式，并且大小不超过父容器的剩余空间。</li>
</ol>
<h1 id="5-View-的工作流程"><a href="#5-View-的工作流程" class="headerlink" title="5 View 的工作流程"></a>5 View 的工作流程</h1><p>View 的工作流程主要是指 measure、layout、draw 这三大流程，即测量、布局和绘制，其中 measure 确定 View 的测量宽和高，layout 确定 View  的最终宽和高及 View 的四个顶点位置，而 draw 是将 View 绘制到屏幕上。</p>
<h2 id="5-1-measure-过程"><a href="#5-1-measure-过程" class="headerlink" title="5.1 measure 过程"></a>5.1 measure 过程</h2><p>分两种情况：</p>
<ol>
<li>如果只是一个原始的 View，通过<code>measure</code>方法就完成了测量过程。</li>
<li>如果是一个 ViewGroup 除了完成自己的测量过程还会遍历调用所有子 View 的<code>measure</code>方法，而且各个子 View 还会递归执行这个过程。</li>
</ol>
<h3 id="5-1-1-View-的-measure-过程"><a href="#5-1-1-View-的-measure-过程" class="headerlink" title="5.1.1 View 的 measure 过程"></a>5.1.1 View 的 measure 过程</h3><p>View 的 measure 过程由 <code>measure</code> 方法来完成， <code>measure</code> 方法是一个 final 类型，子类不可以重写，而 View 的 measure() 方法中会调用 onMeasure 方法，因此我们只需要分析 onMeasure  方法即可，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> widthMeasureSpec 父容器所施加的水平方向约束条件</div><div class="line">     * <span class="doctag">@param</span> heightMeasureSpec 父容器所施加的竖直方向约束条件</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">  <span class="comment">//设置 view 高宽的测量值</span></div><div class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面方法很简单，就是给 View 设置了测量高宽的测量值，而这个测量值是通过 getDefaultSize 方法获取，那么接着分析 getDefaultSize 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> size view 的默认尺寸，一般表示设置了android:minHeight属性</div><div class="line">     *或者该View背景图片的大小值 </div><div class="line">     * <span class="doctag">@param</span> measureSpec 父容器的约束条件 measureSpec</div><div class="line">     * <span class="doctag">@return</span> 返回 view 的测量尺寸</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = size;</div><div class="line">  <span class="comment">//获取测量模式</span></div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">  <span class="comment">//获取尺寸</span></div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        <span class="comment">//如果 测量模式为 UNSPECIFIED ，表示对父容器对子 view 没有限制，那么 view 的测量尺寸为</span></div><div class="line">        <span class="comment">//默认尺寸 size</span></div><div class="line">        result = size;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        <span class="comment">//如果测量模式为 AT_MOST 最大测量模式或者 EXACTLY 精准测量模式，</span></div><div class="line">        <span class="comment">//那么 View 的测量尺寸为 MeasureSpec 的 specSize</span></div><div class="line">        <span class="comment">//即父容器给定尺寸（父容器当前剩余全部空间大小）。</span></div><div class="line">        result = specSize;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里来分析一下 UNSPECIFIED 条件下 View 的测量高宽默认值 size 是通过 getSuggestedMinimumWidth() 和 getSuggestedMinimumHeight()  函数获取，这两个方法原理一样，这里我们就看一下 getSuggestedMinimumHeight() 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码可以看出，如果 View 没有背景，View 的高度就是 mMinHeight，这个 mMinHeight 是由 android：minHeight 这个属性控制，可以为 0，如果有背景，就返回  mMinHeight 和背景的最小高度两者中的最大值。</p>
<p>从 getDefaultSize 方法可以看出，View 的高/宽由 父容器传递进来的 specSize 决定，因此可以得出结论：</p>
<p><strong>直接继承自 View 的自定义控件需要重写 onMeasure 方法来设置 wrap_content 时候的自身大小</strong>，而设置的具体值需要根据实际情况自己去计算或者直接给定一个默认固定值，否则在布局中使用 wrap_content  时候就相当于使用 match_parent ，因为在布局中使用 wrap_content 的时候，它的 specMode 是 AT_MOST 最大测量模式，在这种模式下 View 的宽/高等于 speceSize 大小，即父容器中可使用的大小，也就是父容器当前剩余全部空间大小，这种情况，很显然，View 的宽/高就是等于父容器剩余空间的大小，填充父布局，这种效果和布局中使用 match_parent  一样，解决这个问题代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">    <span class="keyword">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">  <span class="comment">// 在 MeasureSpec.AT_MOST 模式下，给定一个默认值</span></div><div class="line">  <span class="comment">//其他情况下沿用系统测量规则即可</span></div><div class="line">    <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST</div><div class="line">            &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        setMeasuredDimension(mWith, mHeight);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        setMeasuredDimension(mWith, heightSpecSize);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">        setMeasuredDimension(widthSpecSize, mHeight);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中在 widthSpecMode 或 heightSpecMode 为 MeasureSpec.AT_MOST 我们就给定一个对应的 mWith 和 mHeight 默认固定值宽高，而这个默认值没有固定依据，需要我们根据自定义的 view 的具体情况去计算给定。</p>
<h3 id="5-1-2-ViewGroup-的-measure-过程"><a href="#5-1-2-ViewGroup-的-measure-过程" class="headerlink" title="5.1.2 ViewGroup 的 measure 过程"></a>5.1.2 ViewGroup 的 measure 过程</h3><p>ViewGroup 除了完成自己的测量过程还会遍历调用所有子 View 的<code>measure</code>方法，而且各个子 View 还会递归执行这个过程，我们知道 View Group 继承自 View ，是一个抽象类，因此没有重写 View  onMeasure 方法，也就是没有提供具体如何测量自己的方法，但是它提供了一个 measureChildren 方法，定义了如何测量子 View 的规则，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> widthMeasureSpec 该 ViewGroup 水平方向约束条件</div><div class="line"> * <span class="doctag">@param</span> heightMeasureSpec 该 ViewGroup 竖直方向约束条件</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">    <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">      <span class="comment">//逐一遍历获取得到 ViewGroup 中的子 View</span></div><div class="line">        <span class="keyword">final</span> View child = children[i];</div><div class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">          <span class="comment">//对获取到的 子 view 进行测量</span></div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们再看一下对子 View 进行测量的 measureChild 方法 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> child 要进行测量的子 view </div><div class="line"> * <span class="doctag">@param</span> parentWidthMeasureSpec ViewGroup 对要进行测量的子 view 水平方向约束条件</div><div class="line"> * <span class="doctag">@param</span> parentHeightMeasureSpec  ViewGroup 对要进行测量的子 view 竖直方向约束条件</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">        <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">  <span class="comment">//第一步，获取 View 的 LayoutParams</span></div><div class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"><span class="comment">//第二步，获取 view 的 WidthMeasureSpec，其中传入的几个参数说明：</span></div><div class="line"><span class="comment">//parentWidthMeasureSpec 父容器的 WidthMeasureSpec</span></div><div class="line"><span class="comment">//mPaddingLeft + mPaddingRight view 本身的 Padding 值，即内边距值</span></div><div class="line"><span class="comment">// lp.width view 本身期望的宽度 with 值</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">            mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">  <span class="comment">//同上</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">            mPaddingTop + mPaddingBottom, lp.height);</div><div class="line">  <span class="comment">// 第三步，根据获取的子 veiw 的 WidthMeasureSpec 和 HeightMeasureSpec </span></div><div class="line">   <span class="comment">//调用子 view 的 measure 方法，对子 view 进行测量，具体后面的测量逻辑就是和我们前面分析 </span></div><div class="line">  <span class="comment">// view 的测量过程一样了。</span></div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中的第二步调用的方法 getChildMeasureSpec  在标题 4 MeasureSpec和LayoutParams的对应关系 中已经分析过。</p>
<p>ViewGroup 并没有定义具体的测量过程，这是因为 ViewGroup 是一个抽象类，其不同子类具有不同的特性，导致他们的测量过程有所不同，不能有一个统一的 onMeasure 方法，所以其测量过程的 onMeasure 方法需要子类去具体实现，比如 LinearLayout 和 RelativeLayout 等，下面通过 LinearLayout 的 onMeasure 方法来分析一下 ViewGroup 的测量过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">      <span class="comment">//垂直方向的 LinearLayout  测量方式</span></div><div class="line">        measureVertical(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//水平方向的 LinearLayout 测量方式</span></div><div class="line">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码可以看出 ViewGroup 内部测量方式分为垂直方向和水平方向，两者原理基本一样，下面看一下垂直方向的 LinearLayout  测量方式，由于这个方法代码比较长，所以贴出重点部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line"> ......................</div><div class="line">    <span class="comment">//记录总高度</span></div><div class="line">    <span class="keyword">float</span> totalWeight = <span class="number">0</span>;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</div><div class="line">  <span class="comment">//获取测量模式</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> widthMode = View.MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightMode = View.MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"> ...........</div><div class="line">    <span class="comment">//第1步，对 LinearLayout 中的子 view 进行第一次测量</span></div><div class="line">    <span class="comment">// See how tall everyone is. Also remember max width.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">            mTotalLength += measureNullChild(i);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class="line">            i += getChildrenSkipCount(child, i);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">            mTotalLength += mDividerHeight;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取子 view 的 LayoutParams 参数</span></div><div class="line">        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">        totalWeight += lp.weight;</div><div class="line">      <span class="comment">//第1.1步，满足该条件，第一次测量时不需要测量该子 view</span></div><div class="line">        <span class="keyword">if</span> (heightMode == View.MeasureSpec.EXACTLY &amp;&amp; lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 满足该条件的话，不需要现在计算该子视图的高度。</span></div><div class="line">            <span class="comment">//因为 LinearLayout 的高度测量规格为 EXACTLY ，说明高度 LinearLayout 是固定的，</span></div><div class="line">            <span class="comment">//不依赖子视图的高度计算自己的高度</span></div><div class="line">            <span class="comment">//lp.height == 0 &amp;&amp; lp.weight &gt; 0 说明子 view 使用了权重模式，即希望使用 LinearLayout 的剩余空间</span></div><div class="line">            <span class="comment">// 测量工作会在之后进行</span></div><div class="line">            <span class="comment">//相反，如果测量规格为 AT_MOST 或者 UNSPECIFIED ，LinearLayout</span></div><div class="line">            <span class="comment">// 只能根据子视图的高度来确定自己的高度，就必须对所有的子视图进行测量。</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</div><div class="line">            <span class="comment">//标记未进行测量</span></div><div class="line">            skippedMeasure = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">//  else 语句内部是对子 view 进行第一次测量</span></div><div class="line">            <span class="keyword">int</span> oldHeight = Integer.MIN_VALUE;</div><div class="line">            <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 如果 LiniearLayout 不是 EXACTLY 模式，高度没给定，</span></div><div class="line">              <span class="comment">//说明 LiniearLayout 高度需要根据子视图来测量，</span></div><div class="line">                <span class="comment">// 而此时子 view 模式为 lp.height == 0 &amp;&amp; lp.weight &gt; 0 ，是希望使用 LinearLayout 的剩余空间</span></div><div class="line">                <span class="comment">// 这种情况下，无法得出子 view 高度，而为了测量子视图的高度，</span></div><div class="line">              <span class="comment">//设置子视图 LayoutParams.height 为 wrap_content。</span></div><div class="line">                oldHeight = <span class="number">0</span>;</div><div class="line">                lp.height = LayoutParams.WRAP_CONTENT;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//该方法只是调用了 ViewGroup 的 measureChildWithMargins() 对子 view 进行测量</span></div><div class="line">            <span class="comment">// measureChildWithMargins() 方法在上面 4 MeasureSpec和LayoutParams的对应关系已经分析过</span></div><div class="line">            measureChildBeforeLayout(</div><div class="line">                    child, i, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec,</div><div class="line">                    totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (oldHeight != Integer.MIN_VALUE) &#123;</div><div class="line">                lp.height = oldHeight;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 获取测量到的子 view 高度</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">            <span class="comment">//第2步， 重新计算 LinearLayout 的 mTotalLength 总高度</span></div><div class="line">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</div><div class="line">                    lp.bottomMargin + getNextLocationOffset(child));</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (useLargestChild) &#123;</div><div class="line">                largestChildHeight = Math.max(childHeight, largestChildHeight);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    ..........................</div><div class="line">        <span class="comment">//以下方法是对 LinearLayout 宽度相关的测量工作，不是我们关心的</span></div><div class="line">        <span class="keyword">if</span> (widthMode != View.MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">            .........................</div><div class="line">    <span class="comment">//以上方法是对 LinearLayout 宽度相关的测量工作</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mTotalLength &gt; <span class="number">0</span> &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</div><div class="line">        mTotalLength += mDividerHeight;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//第3步，如果设置了 android:measureWithLargestChild="true"并且测量模式为 AT_MOST或者 UNSPECIFIED</span></div><div class="line">    <span class="comment">// 重新计算 mTotalLength 总高度</span></div><div class="line">    <span class="keyword">if</span> (useLargestChild &amp;&amp;</div><div class="line">            (heightMode == View.MeasureSpec.AT_MOST || heightMode == View.MeasureSpec.UNSPECIFIED)) &#123;</div><div class="line">        mTotalLength = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">                mTotalLength += measureNullChild(i);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</div><div class="line">                i += getChildrenSkipCount(child, i);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</div><div class="line">                    child.getLayoutParams();</div><div class="line">            <span class="comment">// Account for negative margins</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</div><div class="line">            <span class="comment">//每个子视图的高度为：最大子视图高度 ＋ 该子视图的上下外边距</span></div><div class="line">            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</div><div class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Add in our padding</span></div><div class="line">    mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> heightSize = mTotalLength;</div><div class="line"></div><div class="line">    <span class="comment">// Check against our minimum height</span></div><div class="line">    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</div><div class="line"></div><div class="line">    <span class="comment">//第4步，根据 heightMeasureSpec 测量模式 和已经测量得到的总高度 heightSize</span></div><div class="line">    <span class="comment">//来确定得到最终 LinearLayout 高度和状态</span></div><div class="line">    <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</div><div class="line">          </div><div class="line">    <span class="comment">//分割线=================以上代码就完成了对  LinearLayout 高度和状态 的测量</span></div><div class="line"></div><div class="line">    <span class="comment">//第5步，下面代码是根据已经测量得到的 LinearLayout 高度来重新测量确定各个子 view 的大小</span></div><div class="line"></div><div class="line">    <span class="comment">//获取 LinearLayout 高度值</span></div><div class="line">    heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</div><div class="line">    <span class="comment">//获取最终测量高度和经过测量各个子 view 得到的总高度差值</span></div><div class="line">    <span class="keyword">int</span> delta = heightSize - mTotalLength;</div><div class="line">    <span class="comment">//第5.1步（第5步中第1小步），如果在上面第一次测量子 view 的过程中有未进行测量的 view 那么执行下面代码</span></div><div class="line">    <span class="keyword">if</span> (skippedMeasure || delta != <span class="number">0</span> &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>) &#123;</div><div class="line">        <span class="keyword">float</span> weightSum = mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</div><div class="line">        mTotalLength = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">            <span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">            <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 计算 weight 属性分配的大小，可能为负值</span></div><div class="line">                <span class="keyword">int</span> share = (<span class="keyword">int</span>) (childExtra * delta / weightSum);</div><div class="line">                weightSum -= childExtra;</div><div class="line">                delta -= share;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</div><div class="line">                        mPaddingLeft + mPaddingRight +</div><div class="line">                                lp.leftMargin + lp.rightMargin, lp.width);</div><div class="line"></div><div class="line">                <span class="comment">// <span class="doctag">TODO:</span> Use a field like lp.isMeasured to figure out if this</span></div><div class="line">                <span class="comment">// child has been previously measured</span></div><div class="line">                <span class="keyword">if</span> ((lp.height != <span class="number">0</span>) || (heightMode != View.MeasureSpec.EXACTLY)) &#123;</div><div class="line">                    <span class="comment">// 子视图在第一次测量时候已经测量过</span></div><div class="line">                    <span class="comment">// 基于上次测量值再次进行新的测量</span></div><div class="line">                    <span class="keyword">int</span> childHeight = child.getMeasuredHeight() + share;</div><div class="line">                    <span class="keyword">if</span> (childHeight &lt; <span class="number">0</span>) &#123;</div><div class="line">                        childHeight = <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 调用子 view 的 measure 方法进行测量，后面逻辑就是 view 的测量逻辑</span></div><div class="line">                    child.measure(childWidthMeasureSpec,</div><div class="line">                            View.MeasureSpec.makeMeasureSpec(childHeight, View.MeasureSpec.EXACTLY));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 子视图第一次测量，即第一步进行测量的时候未得到测量</span></div><div class="line">                    <span class="comment">//对 view 进行测量</span></div><div class="line">                    child.measure(childWidthMeasureSpec,</div><div class="line">                            View.MeasureSpec.makeMeasureSpec(share &gt; <span class="number">0</span> ? share : <span class="number">0</span>,</div><div class="line">                                    View.MeasureSpec.EXACTLY));</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Child may now not fit in vertical dimension.</span></div><div class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState()</div><div class="line">                        &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 处理子视图宽度</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> margin =  lp.leftMargin + lp.rightMargin;</div><div class="line">           ...........................</div><div class="line">        <span class="comment">// Add in our padding</span></div><div class="line">        mTotalLength += mPaddingTop + mPaddingBottom;</div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//第5.2步（第5步中第2小步）执行到这里的代码，表明 view 是已经测量过的</span></div><div class="line">        alternativeMaxWidth = Math.max(alternativeMaxWidth,</div><div class="line">                weightedMaxWidth);</div><div class="line">        <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></div><div class="line">        <span class="comment">// Children will have already been measured once.</span></div><div class="line">        <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != View.MeasureSpec.EXACTLY) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">                <span class="keyword">final</span> View child = getVirtualChildAt(i);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">final</span> LinearLayout.LayoutParams lp =</div><div class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">                <span class="keyword">float</span> childExtra = lp.weight;</div><div class="line">                <span class="comment">//如果 view 使用了权重即 childExtra &gt; 0，使用最大子视图高度进行重新测量</span></div><div class="line">                <span class="comment">//否则不进行测量，保持第一次测量值，那么由于 LinearLayout 的高度使用了子 view 最大高度 ，</span></div><div class="line">                <span class="comment">// 但是子视图没有进行重新测量，没有进行拉伸，可能造成空间剩余。</span></div><div class="line">                <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">//使用最大子视图高度进行重新测量子 view </span></div><div class="line">                    child.measure(</div><div class="line">                            View.MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</div><div class="line">                                    View.MeasureSpec.EXACTLY),</div><div class="line">                            View.MeasureSpec.makeMeasureSpec(largestChildHeight,</div><div class="line">                                    View.MeasureSpec.EXACTLY));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != View.MeasureSpec.EXACTLY) &#123;</div><div class="line">        maxWidth = alternativeMaxWidth;</div><div class="line">    &#125;</div><div class="line">    maxWidth += mPaddingLeft + mPaddingRight;</div><div class="line">    <span class="comment">// Check against our minimum width</span></div><div class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</div><div class="line">    <span class="comment">//第6步，最终设置 LinearLayout 的测量高宽</span></div><div class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class="line">            heightSizeAndState);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (matchWidth) &#123;</div><div class="line">        forceUniformWidth(count, heightMeasureSpec);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码就是对 LinearLayout onMeasure 分析过程，整个过程原理已经在代码中加以注释说明，这里我们重点分析一下 resolveSizeAndState(heightSize, heightMeasureSpec, 0) 这个方法是如何实现最终确定 LinearLayout 高度值的，方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@param</span> size view 想要的大小，也就是根据子 view 高度测量得到的高度值.</div><div class="line"> * <span class="doctag">@param</span> measureSpec 父容器的约束条件</div><div class="line"> * <span class="doctag">@param</span> childMeasuredState 子 view 的测量信息</div><div class="line"> * <span class="doctag">@return</span> Size 返回得到的测量值和状态</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasuredState)</span> </span>&#123;</div><div class="line">  <span class="comment">//获取测量模式</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">  <span class="comment">//获取尺寸值</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> result;</div><div class="line">  <span class="comment">//根据不同测量模式决定最终测量结果</span></div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">        <span class="comment">//如果是 AT_MOST 最大测量模式 ，那么总高度值为测量得到的 size 值，但是最大不能超过 specSize 规定值</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">            <span class="keyword">if</span> (specSize &lt; size) &#123;</div><div class="line">              <span class="comment">//如果测量得到的 size 值超过 specSize 值，LinearLayout 高度就为 specSize 值</span></div><div class="line">                result = specSize | MEASURED_STATE_TOO_SMALL;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="comment">//如果测量得到的 size 值未超过 specSize 值，LinearLayout 高度就为 size 值</span></div><div class="line">                result = size;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">       <span class="comment">//如果是 EXACTLY 精准测量模式，即 LinearLayout 值为固定值，那么 最终 LinearLayout 高度值就为 specSize 值</span></div><div class="line">            result = specSize;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        <span class="comment">// 如果是 UNSPECIFIED 测量模式，即对子 view 没有限制 ， LinearLayout 高度值就为 size</span></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            result = size;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result | (childMeasuredState &amp; MEASURED_STATE_MASK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码总结起来就是 LinearLayout 会根据测量子 View 的情况和 MeasureSpec 约束条件来决定自己最终的大小，具体来说就是如果它的布局中高度才用 具体数值，那么它的测量过程和 View 一致，即高度为 specSize 值，如果它的布局中使用 wrap_content 那么它的高度是所有子 View 高度总和，但是不能超过父容器剩余空间。</p>
<p>最后对整个测量过程总结一下就是分为以下几步：</p>
<ol>
<li>对 LinearLayout 中的子 View 进行第一次遍历测量，主要是通过 measureChildBeforeLayout 这个方法，这个方法内部会调用 measureChildWithMargins 方法，而在 measureChildWithMargins 方法内部会去调用 child.measure(childWidthMeasureSpec, childHeightMeasureSpec) 方法进行测量。在这次的测量过程中，如果满足了第1.1步测量条件的子 view 不需要进行测量，会在后面的第5.1步中进行测量。</li>
<li>根据测量各个子 View 的高度会得到一个初步的 LinearLayout 总高度  mTotalLength 值。</li>
<li>如果 LinearLayout 设置了 android:measureWithLargestChild=”true” 属性并且测量模式为 AT_MOST或者 UNSPECIFIED 重新计算 mTotalLength 总高度。</li>
<li>根据 LinearLayout  的 heightMeasureSpec 测量模式 和已经测量得到的总高度 mTotalLength ，来确定得到最终 LinearLayout 高度和状态 。</li>
<li>根据已经测量得到的 LinearLayout 高度来重新测量确定各个子 View 的大小。</li>
<li>最终执行 setMeasuredDimension 方法设置 LinearLayout 的测量高宽。</li>
</ol>
<h1 id="6-实际问题解决"><a href="#6-实际问题解决" class="headerlink" title="6 实际问题解决"></a>6 实际问题解决</h1><p>View 的 measure 过程和 Activity 的生命周期方法不是同步执行的，因此无法保证 Activity 执行了onCreate、onStart、onResume 时某个 View 已经测量完毕了。如果View还没有测量完毕，那么获得的宽和高都是 0。下面是四种解决该问题的方法：</p>
<p>1、<strong>Activity/View#onWindowsChanged 方法</strong></p>
<p>onWindowFocusChanged 方法表示 View 已经初始化完毕了，宽高已经准备好了，这个时候去获取是没问题的。这个方法会被调用多次，当 Activity 继续执行或者暂停执行的时候，这个方法都会被调用，典型代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasWindowFocus)</span> </span>&#123;</div><div class="line">         <span class="keyword">super</span>.onWindowFocusChanged(hasWindowFocus);</div><div class="line">       <span class="keyword">if</span>(hasWindowFocus)&#123;</div><div class="line">       <span class="keyword">int</span> width=view.getMeasuredWidth();</div><div class="line">       <span class="keyword">int</span> height=view.getMeasuredHeight();</div><div class="line">      &#125;      </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>2、<strong>View.post(runnable)</strong> </p>
<p> 通过 post 将一个 Runnable 投递到消息队列的尾部，然后等待 Looper 调用此 runnable 的时候 View 也已经初始化好了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStart();</div><div class="line">    view.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> width=view.getMeasuredWidth();</div><div class="line">            <span class="keyword">int</span> height=view.getMeasuredHeight();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3、<strong>ViewTreeObsever</strong> </p>
<p> 使用 ViewTreeObserver 的众多回调方法可以完成这个功能，比如使用 onGlobalLayoutListener 接口，当 View 树的状态发生改变或者 View 树内部的 View 的可见性发生改变时，onGlobalLayout 方法将被回调。伴随着View树的变化，这个方法也会被多次调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStart();</div><div class="line">    ViewTreeObserver viewTreeObserver=view.getViewTreeObserver();</div><div class="line">    viewTreeObserver.addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</div><div class="line">            view.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">int</span> width=view.getMeasuredWidth();</div><div class="line">            <span class="keyword">int</span> height=view.getMeasuredHeight();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4、<strong>view.measure(int widthMeasureSpec, int heightMeasureSpec)</strong> </p>
<p> 通过手动对 View 进行 measure 来得到 View 的宽高，这个要根据 View 的 LayoutParams 来处理：</p>
<p>（1）<strong>match_parent</strong>：无法 measure 出具体的宽高，原因是根据上面我们分析 View 的measure 过程原理可知，此种 MeasureSpec 需要知道 parentSize ，即父容器剩余空间，而这个时候无法知道 parentSize  大小，所以无法测量。</p>
<p>（2）<strong>wrap_content:</strong> 可以采用设置最大值方法进  measure ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> widthMeasureSpec = MeasureSpec.makeMeasureSpec((<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>, MeasureSpec.AT_MOST);</div><div class="line"></div><div class="line"><span class="keyword">int</span> heightMeasureSpec = MeasureSpec.makeMeasureSpec((<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>, MeasureSpec.AT_MOST);</div><div class="line"></div><div class="line">view.measure(widthMeasureSpec, heightMeasureSpec);</div></pre></td></tr></table></figure>
<p>  <strong>注意这里作者为什么使用</strong> (1 &lt;&lt; 30) - 1 ) 来构造 MeasureSpec 呢？笔者解释是：”通过分析 MeasureSpec  的实现可以得知 View 的尺寸是使用 30 位的二进制表示，也就是说最大是 30 个 1 即（2^30-1)，也就是  (1 &lt;&lt; 30) - 1 )，在最大化模式下，使用 View 能支持的最大值去构造 MeasureSpec  是合理的“。为什么这样就合理呢？我们前面分析在子 View 使用 wrap_content 模式的时候，其测量规则是根据自身的情况去测量尺寸，但是不能超过父容器的剩余空间的最大值，换句话说就是父容器给子 View 一个最大值，然后告诉子 View 你自己看着办，但是别超过这个尺寸就行，但是现在我们自己去测量的时候不知道父容器给定的 MeasureSpec 情况， 也就是不知道父容器给多大的限定值，需要自己去构造一个MeasureSpec ，那么这个最大值我们给定多少合适呢？所以这里干脆就给一个 View 所能支持的最大值，然子 View 根据自身情况去测量，怎么也不能超过这个值就行了。</p>
<p>（3）具体数值（dp/px)：例如100px，如下 measure :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> widthMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">100</span>, MeasureSpec.EXACTLY);</div><div class="line"></div><div class="line"><span class="keyword">int</span> heightMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">100</span>, MeasureSpec.EXACTLY);</div><div class="line"></div><div class="line">view.measure(widthMeasureSpec, heightMeasureSpec);</div></pre></td></tr></table></figure>
<p> 以上四种解决方法的代码和原理上面已经详细说明，大家可以根据需要进行选择使用。</p>
<p><strong>结语：</strong></p>
<p>本次笔记主要记录 View 三大流程中的 onMeasure() 测量原理部分，笔者感觉这一部分也是比较重要和难懂的部分，在我们实际中很多问题会涉及到，所以静下心来详细记录，如有理解错误，还望指出，谢谢！！！！！</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android-View/" rel="tag"># Android View</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/28/view_touchEvent_dispatch/" rel="next" title="View 的事件分发机制（Android 开发艺术探索读书笔记）">
                <i class="fa fa-chevron-left"></i> View 的事件分发机制（Android 开发艺术探索读书笔记）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/10/05/view_layout_and_draw/" rel="prev" title="View 的工作原理下 View 的 layout 和 draw 过程 （Android 开发艺术探索读书笔记）">
                View 的工作原理下 View 的 layout 和 draw 过程 （Android 开发艺术探索读书笔记） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/09/11/view_measure/"
           data-title="View 的工作原理上 View 绘制流程梳理及 Measure 过程详解（Android 开发艺术探索笔记）" data-url="http://yoursite.com/2016/09/11/view_measure/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://github.com/yongyu0102/Images/blob/master/avatar/avatar.png?raw=true"
               alt="Yongyu" />
          <p class="site-author-name" itemprop="name">Yongyu</p>
          <p class="site-description motion-element" itemprop="description">这里记录你的故事！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://extremej.itscoder.com/" title="Joe" target="_blank">Joe</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://jaeger.itscoder.com/" title="写代码的猴子" target="_blank">写代码的猴子</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://brucezz.itscoder.com/" title="Brucezz" target="_blank">Brucezz</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://allenwu.itscoder.com/" title="小刚" target="_blank">小刚</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-前言"><span class="nav-number">1.</span> <span class="nav-text">1 前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-主要内容简介"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 主要内容简介</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-初识-ViewRoot-和-DecorView"><span class="nav-number">2.</span> <span class="nav-text">2 初识 ViewRoot 和 DecorView</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-理解MeasureSpec"><span class="nav-number">3.</span> <span class="nav-text">3 理解MeasureSpec</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-MeasureSpec-和-LayoutParams-的对应关系"><span class="nav-number">4.</span> <span class="nav-text">4 MeasureSpec 和 LayoutParams 的对应关系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-View-的工作流程"><span class="nav-number">5.</span> <span class="nav-text">5 View 的工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-measure-过程"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 measure 过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-View-的-measure-过程"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.1.1 View 的 measure 过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-ViewGroup-的-measure-过程"><span class="nav-number">5.1.2.</span> <span class="nav-text">5.1.2 ViewGroup 的 measure 过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-实际问题解决"><span class="nav-number">6.</span> <span class="nav-text">6 实际问题解决</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yongyu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
  document.write(unescape("%3Cspan id='cnzz_stat_icon_1260579440'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1260579440%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
  </script>
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
 </script>
 </br>本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"yongyu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>

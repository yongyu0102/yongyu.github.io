<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android View," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="-文章来源：itsCoder 的 WeeklyBolg 项目

itsCoder主页：http://itscoder.com/
作者：yongyu0102
审阅者：HanJie


前言在写这篇笔记的时候想了好久，也拖了好长时间，关于事件分发的博客看了很多，有的写的思路很清晰，画了事件分发的整体流程图，但是没有源码，看过之后只能知道事件是怎么分发的，但完全是记住的，而不是通过源码分析出来的，试想">
<meta property="og:type" content="article">
<meta property="og:title" content="View 的事件分发机制（Android 开发艺术探索读书笔记）">
<meta property="og:url" content="http://yoursite.com/2016/08/28/view_touchEvent_dispatch/index.html">
<meta property="og:site_name" content="一个写代码的地方">
<meta property="og:description" content="-文章来源：itsCoder 的 WeeklyBolg 项目

itsCoder主页：http://itscoder.com/
作者：yongyu0102
审阅者：HanJie


前言在写这篇笔记的时候想了好久，也拖了好长时间，关于事件分发的博客看了很多，有的写的思路很清晰，画了事件分发的整体流程图，但是没有源码，看过之后只能知道事件是怎么分发的，但完全是记住的，而不是通过源码分析出来的，试想">
<meta property="og:image" content="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/Activity_ViewGroup_View.png?raw=true">
<meta property="og:image" content="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/TouchEvent_disaptch.png?raw=true">
<meta property="og:updated_time" content="2016-08-28T10:11:37.738Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="View 的事件分发机制（Android 开发艺术探索读书笔记）">
<meta name="twitter:description" content="-文章来源：itsCoder 的 WeeklyBolg 项目

itsCoder主页：http://itscoder.com/
作者：yongyu0102
审阅者：HanJie


前言在写这篇笔记的时候想了好久，也拖了好长时间，关于事件分发的博客看了很多，有的写的思路很清晰，画了事件分发的整体流程图，但是没有源码，看过之后只能知道事件是怎么分发的，但完全是记住的，而不是通过源码分析出来的，试想">
<meta name="twitter:image" content="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/Activity_ViewGroup_View.png?raw=true">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/08/28/view_touchEvent_dispatch/"/>





  <title> View 的事件分发机制（Android 开发艺术探索读书笔记） | 一个写代码的地方 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一个写代码的地方</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">记录你的学习</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/28/view_touchEvent_dispatch/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Yongyu">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://github.com/yongyu0102/Images/blob/master/avatar/avatar.png?raw=true">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一个写代码的地方">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="一个写代码的地方" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                View 的事件分发机制（Android 开发艺术探索读书笔记）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-28T18:19:27+08:00">
                2016-08-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android-View/" itemprop="url" rel="index">
                    <span itemprop="name">Android View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/08/28/view_touchEvent_dispatch/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/28/view_touchEvent_dispatch/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>-文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</p>
<ul>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://github.com/yongyu0102" target="_blank" rel="external">yongyu0102</a></li>
<li>审阅者：<a href="https://github.com/melodyxxx" target="_blank" rel="external">HanJie</a></li>
</ul>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在写这篇笔记的时候想了好久，也拖了好长时间，关于事件分发的博客看了很多，有的写的思路很清晰，画了事件分发的整体流程图，但是没有源码，看过之后只能知道事件是怎么分发的，但完全是记住的，而不是通过源码分析出来的，试想，如果以后再遇到其他知识点还是这样，那么我们就完全成了不能靠自己去分析问题，只能去食他人知识，没有自我学习分析能力，所以笔者试着结合艺术探索的讲解，尝试在源码的基础上加以理解，本文的写作逻辑是先从文字描述上尽量让大家先大概了解，事件分发的概况，先有个感性认识，再结合源码进行分析，如果错误的地方，还请指出。</p>
<h3 id="1-1-点击事件的传递规则"><a href="#1-1-点击事件的传递规则" class="headerlink" title="1.1 点击事件的传递规则"></a>1.1 点击事件的传递规则</h3><p>在我们进行分析事件分发机制之前，先思考一下我们要研究哪些问题：</p>
<p><strong>1、事件分发的对象是什么？</strong></p>
<p>当用户触摸屏幕时，将创建一个 MotionEvent 对象即点击事件。MotionEvent 包含关于发生触摸的位置、时间、历史记录、手势动作等细节信息， Touch 事件相关细节被封装成了 MotionEvent 对象。理解了这一个知识点后，其实我们就很容易理解所谓点击事件的分发，其实就是对 MotionEvent 事件分发的过程，即当一个 MotionEvent 产生后，系统需要把这个事件传递给一个具体的 View 去处理, 而这个传递的过程就是分发过程。</p>
<p><strong>2、事件是在哪些对象之间传递？</strong></p>
<p>Android 与用户交互的界面就是由一系列 Activity（Fragment)、ViewGroup、View 组成如图：</p>
<p>​                                                 <img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/Activity_ViewGroup_View.png?raw=true" alt="Activity_ViewGroup_View"></p>
<p>当然一个界面可能由多个ViewGroup或者多个View 组成，所以事件就是在这三者之间进行传递，我们要分析的就是要捋清楚事件是由哪个对象发出，经过哪些对象，最终达到哪个对象，在某些条件改变的时候下他们之间的关系又是怎样的，理解了这些之后，当我们在遇到点击或者滑动事件冲突的情况，相信一切问题就迎刃而解了。</p>
<p><strong>3、这个分发过程由哪些对象协作完成？</strong></p>
<p>其实点击事件分发过程主要由三个重要方法共同完成：dispatchTouchEvent(MotionEvent event) 、onInterceptTouchEvent(MotionEvent event)和onTouchEvent(MotionEvent event)，下面先介绍一下这三个方法的主要作用，这样有利于后面我们对源码的分析：</p>
<ol>
<li><p>public boolean dispatchTouchEvent(MotionEvent event) ：用来进行事件的分发。如果事件能够传递给当前view，那么此方法一定会被调用，返回结果受当前 view 的 onTouchEvent 和下级 view 的 dispatchTouchEvent 方法的影响，表示是否消耗当前事件。返回值 true，表示触摸事件被消费，已经分发出去，后续事件会继续分发到该 View；返回值 false，则表示触摸事件没有被消费，即事件没有分发出去，那么后续事件就不会继续向该 View 分发，该方法在 View 和 ViewGroup 中都有。</p>
</li>
<li><p>public boolean onInterceptTouchEvent(MotionEvent event)<br>在 dispatchTouchEvent 方法内部调用，用来判断是否拦截某个事件，如果当前 view 拦截了某个事件，那么在同一个事件序列当中，此方法不会再被调用，返回结果表示是否拦截当前事件。只有 ViewGroup 中才有该方法 ，返回值 true，表示ViewGroup拦截了该触摸事件，该事件就不会分发给它的子 View 或者子 ViewGroup，事件会由自己的 onTouchEvent() 方法处理。返回值 false，表示 ViewGroup 没有拦截该事件，该事件就可以分发给它的子 View 和子 ViewGroup ，事件传递到子 view 的 dispatchTouchEvent() 方法中去处理。</p>
</li>
<li><p>public boolean onTouchEvent(MotionEvent event)<br>在 dispatchTouchEvent 方法内部调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果 ACTION_DOWN不消耗，则在同一个事件序列中，当前 view 无法再次接收到事件。返回值为 True ，事件由自己处理，后续事件序列让其处理；返回值为 False ，自己不消耗事件，向上返回让其他的父容器的onTouchEvent接受处理。</p>
<p>这三个方法都是通过 dispatchTouchEvent() 联系在一起，他们之间的关系可以用如下伪代码表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">  <span class="comment">//表示事件是否被分发出去（消耗），默认为false，即默认不拦截</span></div><div class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;</div><div class="line">      <span class="comment">//如果拦截了，那么事件交给当前view的onTouchEvent(ev)</span></div><div class="line">      <span class="comment">//方法进行处理，返回值即onTouchEvent(ev)的结果</span></div><div class="line">        consume = onTouchEvent(ev);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">     <span class="comment">//如果不拦截，那么事件交给子view的dispatchTouchEvent(ev)</span></div><div class="line">      <span class="comment">//方法进行处理，返回值即是dispatchTouchEvent(ev)事件</span></div><div class="line">      <span class="comment">//处理结果</span></div><div class="line">        consume = child.dispatchTouchEvent(ev);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> consume;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>结论：对于一个根 ViewGroup，点击事件产生后，首先会传递给它，这时 ViewGroup 的 dispatchTouchEvent 会调用，而在 dispatchTouchEvent 方法中会调用 onInterceptTouchEvent() 方法，如果它的 onInterceptTouchEvent 返回 true 表示要拦截当前事件，接下来事件会交给这个 ViewGroup 处理，此时 ViewGroup 的 onTouchEvent 方法就会被调用，如果这个ViewGroup 的 onInterceptTouchEvent 返回 false，则事件会继续传递给子元素，子元素的 dispatchTouchEvent 会调用，如此反复直到事件被处理。</p>
<p>当一个View需要处理事件时，如果设置了 OnTouchListener ，那么 OnTouchListener 的 onTouch方法会回调，如果 onTouch 返回 false，则当前 View 的 onTouchEvent 方法会被调用；如果返回 true，那么 onTouchEvent 方法将不会调用。由此可见，OnTouchListener 优先级高于 onTouchEvent。OnClickListener 优先级处在事件传递的尾端。</p>
<p><strong>4、事件的传递顺序是什么？</strong></p>
<p>这里就直接给出答案:一个点击事件产生后，传递顺序：Activity -&gt; Window -&gt; ViewGroup  -&gt; View；如果一个 View 的 onTouchEvent 返回 false 即 View 没有处理事件，那么它的父容器的onTouchEvent 会被调用，以此类推，所有元素都不处理该事件，最终将传递给 Activity 处理，即 Activity 的 onTouchEvent 会被调用，事件顺序为：View -&gt;  ViewGroup -&gt; Window -&gt;  Activity。</p>
<p>5、关于事件传递的其他一些结论这里先给出，以便我们更好的理解时间传递机制，结论如下：</p>
<ol>
<li>同一个事件序列是指从手指触摸屏幕那一刻开始，中间包含数量不定的 move 事件到手指离开屏幕那一刻（down-&gt;move…move-&gt;up)。</li>
<li>正常情况下一个事件序列只能被一个 View 拦截且消耗，每个 View  一旦决定拦截，同一个事件序列所有事件都会直接交给它处理，并且它的 onInterceptTouchEvent 不会再被调用。</li>
<li>某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN（ onTouchEvent  返回了 false ），那么同一事件序列中其他事件都不会再交给它来处理，事件将重新交给他的父元素处理，即父元素的 onTouchEvent 会被调用。</li>
<li>如果某个 View 不消耗除  ACTION_DOWN 以外的其他事件，那么这个点击事件会消失，此时父元素的 onTouchEvent 并不会被调用，并且当前 View 可以收到后续事件，最终这些消失的点击事件会传递给 Activity 处理。</li>
<li>ViewGroup 默认不拦截任何事件，ViewGroup 的 onInterceptTouchEvent 方法默认返回 false。</li>
<li>View 没有 onInterceptTouchEvent 方法，一旦有事件传递给它，那么它的 onTouchEvent 方法就会被调用。</li>
<li>View 的 onTouchEvent 方法默认消耗事件（返回 true ），除非他是不可点击的（ clickable 和 longClickable 同时为 false ）。View 的 longClickable 属性默认都为 false ，clickable 属性分情况，Button 默认为 true，TextView 默认为 false。</li>
<li>onClick 发生的前提是View可点击，并且它收到了down 和 up 事件。</li>
<li>事件传递过程是由外而内，事件总是先传递给父元素，然后在由父元素分发给子 View，通过requestDisallowInterceptTouchEvent 方法可以在子元素干预父元素的事件分发过程，但 ACTION_DOWN 事件除外。                </li>
</ol>
<h3 id="1-2-事件分发的源码解析"><a href="#1-2-事件分发的源码解析" class="headerlink" title="1.2 事件分发的源码解析"></a>1.2 事件分发的源码解析</h3><p>这里要分别分析 Activity  、ViewGroup 和 View 对事件的分发。</p>
<h4 id="1-Activity-对点击事件的分发过程"><a href="#1-Activity-对点击事件的分发过程" class="headerlink" title="1. Activity 对点击事件的分发过程"></a>1. Activity 对点击事件的分发过程</h4><p>   由于平时我们对 Activity 事件分发接触不是很多（笔者是这样），使用应该不是很多，所以这里只做简单介绍。</p>
<p>   (1) Activity 中与触摸事件相关API主要是 dispatchTouchEvent() 和 onTouchEvent()。dispatchTouchEvent() 是传递触摸事件的API，而 onTouchEvent() 则是 Activity 处理触摸事件的API。</p>
<p>   (2) Activity 中的 dispatchTouchEven 会将触摸事件传递给Activity 所包含的视图。具体的实现方式在通过调用到 Activity 所属 Window 的  superDispatchTouchEvent，进而调用到 Window 的 DecorView 的 superDispatchTouchEvent，进一步又调用到 ViewGroup 的 dispatchTouchEvent() ，这样事件就从 Activity 传递到了 ViewGroup 。<br>   如果 Activity 所包含的视图拦截或者消费了该触摸事件的话，就不会再执行 Activity 的 onTouchEvent() ；<br>   如果 Activity 所包含的视图没有拦截或者消费该触摸事件的话，则会执行 Activity 的 onTouchEvent() 。<br>   (3) Activity 中的 onTouchEvent 是 Activity 自身对触摸事件的处理。如果该 Activity 的 android:windowCloseOnTouchOutside 属性为 true，并且当前触摸事件是 ACTION_DOWN ，而且该触摸事件的坐标在 Activity 之外，同时 Activity 还包含了视图的话就会导致 Activity 被结束。</p>
<h4 id="2-View-对点击事件的处理过程"><a href="#2-View-对点击事件的处理过程" class="headerlink" title="2. View 对点击事件的处理过程"></a>2. View 对点击事件的处理过程</h4><p>   这里的 View 不包含 ViewGroup ，这里说下为什么先分析 View 而不是像书上那样先分析 ViewGroup ，因为在 ViewGroup 的事件分发过程中会调用到 View 对事件的处理，而且 View 的事件处理相比 ViewGroup 而言简单些，所以这里先分析 View 。</p>
<p>   我们来看一下 View 中 dispatchTouchEvent 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span> <span class="params">(MotionEvent event)</span></span>&#123;</div><div class="line">        .........</div><div class="line">        <span class="comment">//标记处理结果是否成功</span></div><div class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">        ...........</div><div class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            <span class="comment">// 如果 mListenerInfo 不为 null，且点击的控件是否是 enable 的</span></div><div class="line">            <span class="comment">//那么就会调用 mOnTouchListener.onTouch(this, event) 方法</span></div><div class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></div><div class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">                <span class="comment">//如果 mOnTouchListener.onTouch(this, event)</span></div><div class="line">                <span class="comment">//方法返回值为 Ture</span></div><div class="line">                <span class="comment">//那么 设置 result = true;即 dispatchTouchEvent </span></div><div class="line">                <span class="comment">//方法返回值为 true</span></div><div class="line">                result = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果 result 为 false ，则调用 onTouchEvent(event)方法</span></div><div class="line">        <span class="comment">//也就是如果 mOnTouchListener.onTouch(this, event)方法返回 true</span></div><div class="line">        <span class="comment">//那么 onTouchEvent(event)方法就不会调用</span></div><div class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">            <span class="comment">//如果 onTouchEvent(event) 返回值为 true ，</span></div><div class="line">            <span class="comment">//那么 dispatchTouchEvent 方法返回 true</span></div><div class="line">            result = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">.............</div><div class="line">    <span class="comment">//返回处理结果</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   从上面源码的10行代码可以看出，首先会判断 mOnTouchListener 是否为空，而mOnTouchListener 是在 setOnTouchListener 方法里赋值的，也就是说只要我们给控件注册了touch 事件，mOnTouchListener 就一定不为空，而(mViewFlags &amp; ENABLED_MASK) == ENABLED 是判断当前点击的控件是否是 enable 的，按钮默认都是 enable 的，因此这个条件恒定为 true。mOnTouchListener.onTouch(this, event)，其实也就是去回调控件注册 touch 事件时的 onTouch 方法。也就是说如果我们在 onTouch 方法里返回 true，就会让这三个条件全部成立，从而整个方法返回 true。在结合22行代码 if (!result &amp;&amp; onTouchEvent(event))，可以得出结论，如果我们在 onTouch 方法里返回 false，就会再去执行 onTouchEvent(event)方法，如果 onTouch 方法里返回 true ，onTouchEvent(event) 方法将不会执行, 可见 OnTouchListener 优先级高于 onTouchEvent(event) 方法。<br>   接下来我们分析一下 onTouchEvent(event) 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;   </div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</div><div class="line">      <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</div><div class="line">  <span class="comment">// 如果是不可用状态下</span></div><div class="line">      <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">          <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">              setPressed(<span class="keyword">false</span>);</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// A disabled view that is clickable</span></div><div class="line">          <span class="comment">//still consumes the touch</span></div><div class="line">          <span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">          <span class="comment">//只要 view 是 clickable 那么仍然会消费事件，</span></div><div class="line">          <span class="comment">//返回值为 true，</span></div><div class="line">          <span class="comment">//只不过不响应事件</span></div><div class="line">          <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</div><div class="line">                  || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class="line">                  || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 如果 view 是 CLICKABLE 或者 LONG_CLICKABLE，</span></div><div class="line">      <span class="comment">//即 view 是 clickable 状态</span></div><div class="line">      <span class="comment">// 就会进入以下方法的 switch 语句 ACTION_MOVE、ACTION_UP、</span></div><div class="line">      <span class="comment">// ACTION_DOWN、ACTION_CANCEL、ACTION_CANCEL</span></div><div class="line">      <span class="comment">//各种状态的处理</span></div><div class="line">      <span class="comment">//无论处于那种状态，最终返回结果都是 true</span></div><div class="line">      <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">              (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||(viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</div><div class="line">          <span class="keyword">switch</span> (action) &#123;</div><div class="line">              <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                  <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</div><div class="line">                  <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepresse</div><div class="line">                      <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</div><div class="line">                      <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class="line">                          focusTaken = requestFocus();</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                          setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class="line">                          removeLongPressCallback();</div><div class="line">                          <span class="keyword">if</span> (!focusTaken) &#123;</div><div class="line">                              <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</div><div class="line">                                  mPerformClick = <span class="keyword">new</span> PerformClick();</div><div class="line">                              &#125;</div><div class="line">                              <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                                  performClick();</div><div class="line">                              &#125;</div><div class="line">                          &#125;</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</div><div class="line">                          mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                          postDelayed(mUnsetPressedState,</div><div class="line">                                  ViewConfiguration.getPressedStateDuration());</div><div class="line">                      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</div><div class="line">                          mUnsetPressedState.run();</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      removeTapCallback();</div><div class="line">                  &#125;</div><div class="line">                  mIgnoreNextUpEvent = <span class="keyword">false</span>;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line"></div><div class="line">              <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                  mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                  <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  &#125;</div><div class="line">                  <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</div><div class="line"></div><div class="line">                  <span class="keyword">if</span> (isInScrollingContainer) &#123;</div><div class="line">                      mPrivateFlags |= PFLAG_PREPRESSED;</div><div class="line">                      <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</div><div class="line">                          mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</div><div class="line">                      &#125;</div><div class="line">                      mPendingCheckForTap.x = event.getX();</div><div class="line">                      mPendingCheckForTap.y = event.getY();</div><div class="line">                      postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class="line">                  &#125; <span class="keyword">else</span> &#123;</div><div class="line">                      setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                      checkForLongClick(<span class="number">0</span>);</div><div class="line">                  &#125;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line"></div><div class="line">              <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">                  setPressed(<span class="keyword">false</span>);</div><div class="line">                  removeTapCallback();</div><div class="line">                  removeLongPressCallback();</div><div class="line">                  mInContextButtonPress = <span class="keyword">false</span>;</div><div class="line">                  mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line">                  mIgnoreNextUpEvent = <span class="keyword">false</span>;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line"></div><div class="line">              <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                  drawableHotspotChanged(x, y);</div><div class="line">                  <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                      <span class="comment">// Outside button</span></div><div class="line">                      removeTapCallback();</div><div class="line">                      <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">                          removeLongPressCallback();</div><div class="line"></div><div class="line">                          setPressed(<span class="keyword">false</span>);</div><div class="line">                      &#125;</div><div class="line">                  &#125; </div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">      <span class="comment">//如果该控件是可以点击的就会进入 switch 判断中去，</span></div><div class="line">      <span class="comment">//最终返回值为 true ，即 onTouchEvent</span></div><div class="line">          <span class="comment">//返回值为 true 。</span></div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">  <span class="comment">//如果该控件是不可点击的返回 false ，如 TextView</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>   先看第7行代码 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) 这个条件是判断 view 是不可用状态，而在该条件下我们看第17行代码 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class="line"> || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div></pre></td></tr></table></figure>
<p>   这个返回结果是判断只要 view 是可点击状态 那么返回值就问 true ，即如果  view 是不可用状态，但只要 view 是可点击状态，就会消耗点击事件，只不过不响应结果。<br>   再看第33行会判断只要 view 是可点击的，那么就会进入到下面的 switch 语句，最终在第123行返回 true，即只要 view 是可点击的，那么 ontouchEvent（Event v) 方法就会返回 true 消费点击事件。<br>   然后在 ACTION_UP 事件触发的时候，在55行代码会执行 performClick() 方法，我们看一下这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> result;</div><div class="line">          <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</div><div class="line">          <span class="comment">//如果 mOnClickListener 不为null，就会调用</span></div><div class="line">          <span class="comment">// mOnClickListener.onClick(this) 方法</span></div><div class="line">          <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</div><div class="line">              playSoundEffect(SoundEffectConstants.CLICK);</div><div class="line">              <span class="comment">//这个方法就是 回调</span></div><div class="line">              <span class="comment">//我们给 view 设置的 view.setOnClickListener()方法</span></div><div class="line">              li.mOnClickListener.onClick(<span class="keyword">this</span>);</div><div class="line">              result = <span class="keyword">true</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              result = <span class="keyword">false</span>;</div><div class="line">          &#125;</div><div class="line">   sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</div><div class="line">     <span class="keyword">return</span> result;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>   上面第6行代码 if (li != null &amp;&amp; li.mOnClickListener != null) 判断如果给当前 view 设置了点击事件，那么就会执行回调设置的 onClick() 方法即 mOnClickListener.onClick(this)，这样 view 的 dispatchTouchEvent(MotionEvent event) 这里就分析结束了！</p>
<h4 id="3-ViewGroup-对点击事件的处理过程"><a href="#3-ViewGroup-对点击事件的处理过程" class="headerlink" title="3 ViewGroup 对点击事件的处理过程"></a>3 ViewGroup 对点击事件的处理过程</h4><p>   同样我们来看一下 ViewGroup 中 dispatchTouchEvent 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">  ............</div><div class="line"><span class="comment">//标记是否分发成功</span></div><div class="line"><span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</div><div class="line"><span class="comment">// 第1步：检测是否要分发该触摸事件</span></div><div class="line"><span class="comment">// 如果该 View 不是位于顶部，并且有设置属性使该 View 不在顶部时不响应触摸事件</span></div><div class="line"><span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        <span class="comment">// 如果是 ACTION_DOWN(即按下事件)，则清空之前的触摸事件处理目标和状态。</span></div><div class="line">        cancelAndClearTouchTargets(ev);</div><div class="line">        resetTouchState();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 标记 ViewGroup 是否要拦截事件</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</div><div class="line">  <span class="comment">//第2步，判断是否拦截事件</span></div><div class="line">    <span class="comment">// 如果是 ACTION_DOWN  或者 mFirstTouchTarget不为null , </span></div><div class="line">  <span class="comment">//记住 mFirstTouchTarget 在事件分发到</span></div><div class="line">    <span class="comment">// 子 view 的时候会被负值， 即一旦 事件传递到子 view 后 mFirstTouchTarget 不为 null ,而</span></div><div class="line">    <span class="comment">// 一旦在 ACTION_DOWN 时候拦截了事件，那么 mFirstTouchTarget=null ;此时 intercepted=true</span></div><div class="line">    <span class="comment">//进行拦截，这就是前面说的，一旦在 ACTION_DOWN 时候拦截了事件，那么后续事件将由 ViewGroup</span></div><div class="line">    <span class="comment">//处理，不分发到子 view 。</span></div><div class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">            || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 检查禁止拦截标记：FLAG_DISALLOW_INTERCEPT</span></div><div class="line">        <span class="comment">// 如果调用了子 view 调用了 requestDisallowInterceptTouchEvent()标记的话，</span></div><div class="line">      <span class="comment">//则FLAG_DISALLOW_INTERCEPT会为true。</span></div><div class="line">        <span class="comment">//意思是禁止父类进行拦截事件</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">            <span class="comment">// 如果禁止拦截标示为 false ,那么调用 ViewGroup 的onInterceptTouchEvent(ev) 方法</span></div><div class="line">            <span class="comment">//获取是否拦截标记 ，onInterceptTouchEvent(ev) 返回值默认为 false</span></div><div class="line">            intercepted = onInterceptTouchEvent(ev);</div><div class="line">            ev.setAction(action); <span class="comment">// restore action in case it was changed</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//如果子 view 调用了requestDisallowInterceptTouchEvent() ，</span></div><div class="line">          <span class="comment">//那么 !disallowIntercept 为false ，此时 intercepted=false，</span></div><div class="line">          <span class="comment">//ViewGroup 的 onInterceptTouchEvent(ev) 将失效</span></div><div class="line">            intercepted = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//这就是上面提到的 一旦在 ACTION_DOWN 时候拦截了事件，那么 mFirstTouchTarget=null</span></div><div class="line">        <span class="comment">//此时  intercepted = true; 继续拦截</span></div><div class="line">        intercepted = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ..............</div><div class="line"></div><div class="line">    TouchTarget newTouchTarget = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//  标记已经将事件是否发生到目标 view</span></div><div class="line">    <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</div><div class="line">        View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</div><div class="line">                ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</div><div class="line">         <span class="comment">//第3步，如果不拦截，不取消，进行事件分发</span></div><div class="line">        <span class="comment">// 在 ACTION_DOWN、ACTION_POINTER_DOWN 或者 ACTION_HOVER_MOVE 动作的时候执行</span></div><div class="line">        <span class="comment">// 在MotionEvent.ACTION_MOVE 、MotionEvent.ACTION_UP 动作的时候不会执行以下代码</span></div><div class="line">        <span class="comment">//会从下面 第7步开始执行</span></div><div class="line">      <span class="comment">//if (mFirstTouchTarget == null) 行代码执行，而如果从ACTION_DOWN开始没有事件传</span></div><div class="line">      <span class="comment">//递到子 view ，那么if (mFirstTouchTarget == null) 条件就会成立，</span></div><div class="line">      <span class="comment">// 否则会执行 while (target != null) ， </span></div><div class="line">      <span class="comment">//直接遍历mFirstTouchTarget链表，查找之前接受ACTION_DOWN的子view，</span></div><div class="line">        <span class="comment">// 并将触摸事件分配给这些子 view 。也就是前面说的说，</span></div><div class="line">      <span class="comment">//如果ViewGroup的某个孩子没有接受ACTION_DOWN事件；</span></div><div class="line">        <span class="comment">// 那么，ACTION_MOVE和ACTION_UP等事件也一定不会分发给这个孩子！</span></div><div class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</div><div class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</div><div class="line">                    : TouchTarget.ALL_POINTER_IDS;</div><div class="line"></div><div class="line">            <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></div><div class="line">            <span class="comment">// have become out of sync.</span></div><div class="line">            removePointersFromTouchTargets(idBitsToAssign);</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</div><div class="line">            <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</div><div class="line">                <span class="comment">// Find a child that can receive the event.</span></div><div class="line">                <span class="comment">// Scan children from front to back.</span></div><div class="line">                <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></div><div class="line">                        &amp;&amp; isChildrenDrawingOrderEnabled();</div><div class="line">                   <span class="comment">// 获取该 ViewGroup 包含的子 View 和 ViewGroup </span></div><div class="line">                <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">                <span class="comment">// 第4步，遍历 ViewGroup的 孩子，对触摸事件进行分发。</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder</div><div class="line">                            ? getChildDrawingOrder(childrenCount, i) : i;</div><div class="line">                    <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</div><div class="line">                            ? children[childIndex] : preorderedList.get(childIndex);</div><div class="line">                    <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line">                        childWithAccessibilityFocus = <span class="keyword">null</span>;</div><div class="line">                        i = childrenCount - <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//判断子 View 是否可以接受事件</span></div><div class="line">                    <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</div><div class="line">                            || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</div><div class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// getTouchTarget() 的作用是查找 child 是否存在于</span></div><div class="line">                  <span class="comment">//mFirstTouchTarget 的单链表中。</span></div><div class="line">                    <span class="comment">// 是的话，返回对应的 TouchTarge t对象；跳出循环</span></div><div class="line">                    newTouchTarget = getTouchTarget(child);</div><div class="line">                    <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// Child is already receiving touch within its bounds.</span></div><div class="line">                        <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></div><div class="line">                        newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    resetCancelNextUpFlag(child);</div><div class="line">                    <span class="comment">// 第5步，真正开始执行事件分发</span></div><div class="line">                  <span class="comment">//调用 dispatchTransformedTouchEvent() 执行触摸事件分发给 child。</span></div><div class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">                        <span class="comment">// Child wants to receive touch within its bounds.</span></div><div class="line">                        mLastTouchDownTime = ev.getDownTime();</div><div class="line">                        <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</div><div class="line">                            <span class="comment">// childIndex points into presorted list, find original index</span></div><div class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</div><div class="line">                                <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                                    mLastTouchDownIndex = j;</div><div class="line">                                    <span class="keyword">break</span>;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            mLastTouchDownIndex = childIndex;</div><div class="line">                        &#125;</div><div class="line">                        mLastTouchDownX = ev.getX();</div><div class="line">                        mLastTouchDownY = ev.getY();</div><div class="line">                           </div><div class="line">                        <span class="comment">//第6步，如果事件分发成功  调用 addTouchTarget()</span></div><div class="line">                      <span class="comment">//将 child 添加到 mFirstTouchTarget 链表中，</span></div><div class="line">                        <span class="comment">// 并返回表头对应的 TouchTarge ,mFirstTouchTarget 将被负值</span></div><div class="line">                        newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                        <span class="comment">// 分发成功 设置 alreadyDispatchedToNewTouchTarget </span></div><div class="line">                      <span class="comment">//标记为 true 跳出循环</span></div><div class="line">                        alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">// The accessibility focus didn't handle the event, so clear</span></div><div class="line">                    <span class="comment">// the flag and do a normal dispatch to all children.</span></div><div class="line">                    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Did not find a child to receive the event.</span></div><div class="line">                <span class="comment">// Assign the pointer to the least recently added target.</span></div><div class="line">                newTouchTarget = mFirstTouchTarget;</div><div class="line">                <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</div><div class="line">                    newTouchTarget = newTouchTarget.next;</div><div class="line">                &#125;</div><div class="line">                newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 第7步，进一步的对触摸事件进行分发，如果mFirstTouchTarget为null，</span></div><div class="line">    <span class="comment">// 意味着还没有任何View来接受该触摸事件；</span></div><div class="line">    <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 调用 ViewGroup 的父类，即 view 的dispatchTouchEvent(MotionEvent ev)方法处理</span></div><div class="line">      <span class="comment">//处理方法就是我们上面分析的 view 对点击事件的分发流程</span></div><div class="line">        <span class="comment">// 并将分发结果的返回值赋值给 handler 进行返回</span></div><div class="line">        handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</div><div class="line">                TouchTarget.ALL_POINTER_IDS);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></div><div class="line">        <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></div><div class="line">        TouchTarget predecessor = <span class="keyword">null</span>;</div><div class="line">        TouchTarget target = mFirstTouchTarget;</div><div class="line">        <span class="comment">// 如果mFirstTouchTarget ！= null，则循环从链表 mFirstTouchTarget 中取出 target</span></div><div class="line">        <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> TouchTarget next = target.next;</div><div class="line">            <span class="comment">// 如果 alreadyDispatchedToNewTouchTarget 为 true</span></div><div class="line">            <span class="comment">// 并且target == newTouchTarget 即事件(ACTION_DOWN)已经分发成功设置 handled=true</span></div><div class="line">            <span class="comment">// 返回事件分发成功</span></div><div class="line">            <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</div><div class="line">                handled = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</div><div class="line">                        || intercepted;</div><div class="line">                <span class="comment">// 如果 alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget 条件</span></div><div class="line">                <span class="comment">//不成立，说明该事件还没有进行分发(ACTION_MOVE、ACTION_UP）</span></div><div class="line">              <span class="comment">//那么将此事件分发给之前已经成功接收事件的子</span></div><div class="line">                <span class="comment">// view ，即 target.child ，并将执行 handled = true 表示事件分发结果成功</span></div><div class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class="line">                        target.child, target.pointerIdBits)) &#123;</div><div class="line">                    handled = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                ..........</div><div class="line">                <span class="comment">//返回事件处理结果</span></div><div class="line">                <span class="keyword">return</span> handled;</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>事件分发主要分为以上几个步骤，代码中已经标出，下面加以总结：</p>
<p>在上面执行第2步的时候，ViewGroup 在两种情况下会判断是否拦截事件即 事件类型为 ACTION_DOWN 和 mFirstTouchTarget ！= null 条件下， ACTION_DOWN  好理解，那么 mFirstTouchTarget ！= null  是什么意思呢，我们看一下在执行第5步，事件由 ViewGroup 子 View 处理成功的时候有一行代码是：newTouchTarget = addTouchTarget(child, idBitsToAssign);这行代码实现方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</div><div class="line">    TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</div><div class="line">    target.next = mFirstTouchTarget;</div><div class="line">    mFirstTouchTarget = target;</div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面代码可以看出，事件由 ViewGroup 子 View 处理成功的时候 mFirstTouchTarget 将会被赋值，即事件分发到子 view 的时候mFirstTouchTarget ！= null，反过来如果事件由 ViewGroup 进行拦截，那么mFirstTouchTarget ！= null 就不成立，那么当 ACTION_MOVE 和 ACIONT_UP 事件到来的时候  if (actionMasked == MotionEvent.ACTION_DOWN    || mFirstTouchTarget != null) 条件为 false，将导致 ViewGroup 的 onInterceptTouchEvent(ev) 方法不再调用，同一系列事件中的其他事件将由 ViewGroup 进行处理。当然有一种特殊情况，就是 FLAG_DISALLOW_INTERCEPT 这个标记位，这个标记位是子 view 调用了 requestDisallowInterceptTouchEvent() 来进行设置，ViewGroup 将无法进行拦截除了 ACTION_DOWN 以外的其他事件，这是因为在进行 ACTION_DOWN 的时候，会重置 FLAG_DISALLOW_INTERCEPT  这个标记位，这样导致子 view 设置的 requestDisallowInterceptTouchEvent() 失效。</p>
<p>在看一下第5步，是如何调用 dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)  方法进行事件分发的，这行代码实现方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></div><div class="line">        View child, <span class="keyword">int</span> desiredPointerIdBits) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</div><div class="line"></div><div class="line">    <span class="comment">// Canceling motions is a special case.  We don't need to perform any transformations</span></div><div class="line">    <span class="comment">// or filtering.  The important part is the action, not the contents.</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</div><div class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</div><div class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</div><div class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            handled = child.dispatchTouchEvent(event);</div><div class="line">        &#125;</div><div class="line">        event.setAction(oldAction);</div><div class="line">        <span class="keyword">return</span> handled;</div><div class="line">    &#125;</div><div class="line">    .......</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们只看与我们要分析目标相关的代码，上面代码中我们看到，如果 child!=null ，那么执行 handled = child.dispatchTouchEvent(event) 之后的逻辑就是前面分析的 view 的事件分发，这样就完成了事件分发到子 view 的流程，我们看 child.dispatchTouchEvent(event) 是由返回值的，即如果返回 true ，事件由子 view 消费，事件分发成功，跳出第4步 for 循环，停止遍历子 view。</p>
<p>我们再看一下第7步，如果 mFirstTouchTarget == null ，说明没有任何子 view 接受触摸事件，那么调用 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS) 注意这里第三个参数传入 null，就是我们上面分析的另一种情况 ，如果 child == null ，执行 handled = super.dispatchTouchEvent(event) ，而 ViewGroup 的父类是 view ，所以之后的处理逻辑又和前面说的 view 一样了，即 ViewGroup 的 onTouch 方法会得到执行 ，而如果 mFirstTouchTarget ！= null ，表明已经有事件分发成功了，那么会执行  while (target != null) 循环从从链表 mFirstTouchTarget 中取出 target，条件 if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget)  如果成立，那么说明这个事件是是已经分发过成功的事件，那么直接执行 handled = true ，即让 dispatchTouchEvent 方法返回 true， 表明事件分发成功，而如果 if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget)  不成立，表明该事件是新到来的事件还没进行分发，那么执行 dispatchTransformedTouchEvent(ev, cancelChild,  target.child, target.pointerIdBits)) ，进一步对事件进行分发，并将 分发处理结果进行返回，这这情况下就是前面 第3步所说，不执行第三步，直接执行第7步对事件进一步就行分发。</p>
<p>最后说了这么多，大家可以结合下面这张流程图来对整理分发流程进行梳理，图片引自：</p>
<p><a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="external">图解 Android 事件分发机制</a>  </p>
<p><img src="https://github.com/yongyu0102/yongyu0102.github.io/blob/master/images/TouchEvent_disaptch.png?raw=true" alt="TouchEvent_disaptch"></p>
<p>其中 super 表示调用关系，true 表示消费事件， false 表示没有消费事件。</p>
<p>到这里关于 View 的事件分发分析就结束了！</p>
<p>如果感觉笔者写的不好，可以参考以下博客：</p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/9153747" target="_blank" rel="external">郭神的 Android事件分发机制完全解析，带你从源码的角度彻底理解(下)</a></p>
<p><a href="http://wangkuiwu.github.io/2015/01/04/TouchEvent-ViewGroup/" target="_blank" rel="external">skywangkw 的Android 触摸事件机制(四) ViewGroup中触摸事件详解</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android-View/" rel="tag"># Android View</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/14/view_to_scroll/" rel="next" title="Android 开发艺术探索第3章 3.2-3.3 View 滑动和弹性滑动读书笔记">
                <i class="fa fa-chevron-left"></i> Android 开发艺术探索第3章 3.2-3.3 View 滑动和弹性滑动读书笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/11/view_measure/" rel="prev" title="View 的工作原理上 View 绘制流程梳理及 Measure 过程详解（Android 开发艺术探索笔记）">
                View 的工作原理上 View 绘制流程梳理及 Measure 过程详解（Android 开发艺术探索笔记） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/08/28/view_touchEvent_dispatch/"
           data-title="View 的事件分发机制（Android 开发艺术探索读书笔记）" data-url="http://yoursite.com/2016/08/28/view_touchEvent_dispatch/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://github.com/yongyu0102/Images/blob/master/avatar/avatar.png?raw=true"
               alt="Yongyu" />
          <p class="site-author-name" itemprop="name">Yongyu</p>
          <p class="site-description motion-element" itemprop="description">这里记录你的故事！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://extremej.itscoder.com/" title="Joe" target="_blank">Joe</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://jaeger.itscoder.com/" title="写代码的猴子" target="_blank">写代码的猴子</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://brucezz.itscoder.com/" title="Brucezz" target="_blank">Brucezz</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://allenwu.itscoder.com/" title="小刚" target="_blank">小刚</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-点击事件的传递规则"><span class="nav-number">2.</span> <span class="nav-text">1.1 点击事件的传递规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-事件分发的源码解析"><span class="nav-number">3.</span> <span class="nav-text">1.2 事件分发的源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Activity-对点击事件的分发过程"><span class="nav-number">3.1.</span> <span class="nav-text">1. Activity 对点击事件的分发过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-View-对点击事件的处理过程"><span class="nav-number">3.2.</span> <span class="nav-text">2. View 对点击事件的处理过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-ViewGroup-对点击事件的处理过程"><span class="nav-number">3.3.</span> <span class="nav-text">3 ViewGroup 对点击事件的处理过程</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yongyu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
  document.write(unescape("%3Cspan id='cnzz_stat_icon_1260579440'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1260579440%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
  </script>
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
 </script>
 </br>本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"yongyu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
